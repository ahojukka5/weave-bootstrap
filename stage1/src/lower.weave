(module
  (name "stage1-lower")
  (doc "Lower high-level forms to explicit typed forms for IR generation.")

  (include "prelude.weave")
  (include "arena.weave")
  (include "ir/util_lists.weave")
  (include "ir/util_strings.weave")
  (include "ir/util_structs.weave")

  ;; ============================================================
  ;; Type environment tracking
  ;; ============================================================

  (fn type-env-add
    (doc "Add name->type binding to environment.")
    (params
      (env-names ArrayString)
      (env-types ArrayString)
      (name String)
      (ty String)
    )
    (returns Int32)
    (body (do
      (array-str-append env-names name)
      (array-str-append env-types ty)
      (return 0)
    ))
  )

  (fn type-env-lookup
    (doc "Look up type of name in environment; returns empty string on miss.")
    (params
      (env-names ArrayString)
      (env-types ArrayString)
      (name String)
    )
    (returns String)
    (body (do
      (let i Int32 (- (array-str-len env-names) 1))
      (while (>= i 0)
        (do
          (if-stmt (string-eq (array-str-get env-names i) name)
            (return (array-str-get env-types i))
            (set i (- i 1))
          )
        )
      )
      (return "")
    ))
  )

  ;; ============================================================
  ;; Extract base struct type from pointer type
  ;; ============================================================

  (fn extract-struct-type
    (doc "Extract struct name from (ptr StructName) or return empty.")
    (params (ty String))
    (returns String)
    (body (do
      ;; Type string looks like "(ptr Arena)" or "Arena" etc.
      ;; We need to check if it starts with "(ptr " and extract the inner type
      (if-stmt (string-starts-with ty "(ptr ")
        (do
          ;; Extract the struct name between "(ptr " and ")"
          (let len Int32 (string-length ty))
          ;; Skip "(ptr " which is 5 chars, and remove trailing ")"
          (return (string-slice ty 5 (- (- len 5) 1)))
        )
        (return "")
      )
    ))
  )

  ;; ============================================================
  ;; Build AST nodes for lowered forms
  ;; ============================================================

  (fn make-atom
    (doc "Create an atom node.")
    (params (a (ptr Arena)) (val String))
    (returns Int32)
    (body (arena-add-node a (node-kind-atom) val))
  )

  (fn make-list
    (doc "Create a list node with first child, return the list node id.")
    (params (a (ptr Arena)) (first-child Int32))
    (returns Int32)
    (body (do
      (let id Int32 (arena-add-node a (node-kind-list) ""))
      (arena-set-first-child a id first-child)
      (return id)
    ))
  )

  (fn link-siblings
    (doc "Link two nodes as siblings.")
    (params (a (ptr Arena)) (prev Int32) (next Int32))
    (returns Int32)
    (body (do
      (arena-set-next-sibling a prev next)
      (return 0)
    ))
  )

  (fn build-struct-type-node
    (doc "Build (struct Name) list node.")
    (params (a (ptr Arena)) (struct-name String))
    (returns Int32)
    (body (do
      (let struct-atom Int32 (make-atom a "struct"))
      (let name-atom Int32 (make-atom a struct-name))
      (link-siblings a struct-atom name-atom)
      (return (make-list a struct-atom))
    ))
  )

  ;; ============================================================
  ;; Lower get-field: (get-field ptr fname) -> (get-field (struct T) idx ptr)
  ;; ============================================================

  (fn lower-get-field
    (doc "Lower (get-field ptr field-name) to (get-field (struct T) idx ptr).")
    (params
      (a (ptr Arena))
      (node Int32)
      (env-names ArrayString)
      (env-types ArrayString)
      (struct-names ArrayString)
      (struct-fields ArrayString)
    )
    (returns Int32)
    (body (do
      ;; Current form: (get-field ptr-expr field-name)
      ;; We have: head="get-field", child1=ptr-expr, child2=field-name
      (let head Int32 (arena-first-child a node))
      (let ptr-expr Int32 (arena-next-sibling a head))
      (let field-node Int32 (arena-next-sibling a ptr-expr))
      
      ;; Get pointer expression - could be variable or (addr x)
      (let ptr-kind Int32 (arena-kind a ptr-expr))
      (let ptr-type String "")
      
      (if-stmt (== ptr-kind (node-kind-atom))
        (do
          ;; Simple variable - look up its type
          (let var-name String (arena-value a ptr-expr))
          (set ptr-type (type-env-lookup env-names env-types var-name))
        )
        (do 0) ;; TODO: handle complex expressions
      )
      
      ;; Extract struct name from pointer type
      (let struct-name String (extract-struct-type ptr-type))
      (if-stmt (== (string-length struct-name) 0)
        (do
          ;; Can't determine struct type - leave unchanged
          (return 0)
        )
        (do 0)
      )
      
      ;; Get field name and look up index
      (let field-name String (arena-value a field-node))
      (let field-idx Int32 (struct-field-index struct-names struct-fields struct-name field-name))
      (if-stmt (== field-idx (- 0 1))
        (do
          ;; Unknown field - leave unchanged for error reporting
          (return 0)
        )
        (do 0)
      )
      
      ;; Build new lowered form: (get-field (struct T) idx ptr-expr)
      ;; We'll rewrite the existing node's children
      
      ;; Create new nodes
      (let struct-type-node Int32 (build-struct-type-node a struct-name))
      (let idx-atom Int32 (make-atom a (int-to-string field-idx)))
      
      ;; Relink: head -> struct-type-node -> idx-atom -> ptr-expr (copy) -> nil
      ;; We need to copy ptr-expr since it might have children
      ;; For now, just relink existing nodes
      
      ;; Update links: head's next = struct-type-node
      (link-siblings a head struct-type-node)
      ;; struct-type-node's next = idx-atom
      (link-siblings a struct-type-node idx-atom)
      ;; idx-atom's next = ptr-expr (original)
      (link-siblings a idx-atom ptr-expr)
      ;; ptr-expr's next = nil (remove field-name)
      (arena-set-next-sibling a ptr-expr (- 0 1))
      
      (return 1)
    ))
  )

  ;; ============================================================
  ;; Lower set-field: (set-field ptr fname val) -> (set-field (struct T) idx ptr val)
  ;; ============================================================

  (fn lower-set-field
    (doc "Lower (set-field ptr field-name val) to (set-field (struct T) idx ptr val).")
    (params
      (a (ptr Arena))
      (node Int32)
      (env-names ArrayString)
      (env-types ArrayString)
      (struct-names ArrayString)
      (struct-fields ArrayString)
    )
    (returns Int32)
    (body (do
      ;; Current form: (set-field ptr-expr field-name val-expr)
      (let head Int32 (arena-first-child a node))
      (let ptr-expr Int32 (arena-next-sibling a head))
      (let field-node Int32 (arena-next-sibling a ptr-expr))
      (let val-expr Int32 (arena-next-sibling a field-node))
      
      ;; Get pointer type
      (let ptr-kind Int32 (arena-kind a ptr-expr))
      (let ptr-type String "")
      
      (if-stmt (== ptr-kind (node-kind-atom))
        (do
          (let var-name String (arena-value a ptr-expr))
          (set ptr-type (type-env-lookup env-names env-types var-name))
        )
        (do 0)
      )
      
      (let struct-name String (extract-struct-type ptr-type))
      (if-stmt (== (string-length struct-name) 0)
        (return 0)
        (do 0)
      )
      
      (let field-name String (arena-value a field-node))
      (let field-idx Int32 (struct-field-index struct-names struct-fields struct-name field-name))
      (if-stmt (== field-idx (- 0 1))
        (return 0)
        (do 0)
      )
      
      ;; Build: (set-field (struct T) idx ptr-expr val-expr)
      (let struct-type-node Int32 (build-struct-type-node a struct-name))
      (let idx-atom Int32 (make-atom a (int-to-string field-idx)))
      
      ;; Relink
      (link-siblings a head struct-type-node)
      (link-siblings a struct-type-node idx-atom)
      (link-siblings a idx-atom ptr-expr)
      (link-siblings a ptr-expr val-expr)
      (arena-set-next-sibling a val-expr (- 0 1))
      
      (return 1)
    ))
  )

  ;; ============================================================
  ;; Lower make: (make Type (f1 v1) ...) -> (make (struct T) v1 v2 ...)
  ;; ============================================================

  (fn lower-make
    (doc "Lower (make Type (f1 v1) ...) to (make (struct T) v1 v2 ...).")
    (params
      (a (ptr Arena))
      (node Int32)
      (struct-names ArrayString)
      (struct-fields ArrayString)
    )
    (returns Int32)
    (body (do
      ;; Current form: (make TypeName (field1 val1) (field2 val2) ...)
      (let head Int32 (arena-first-child a node))
      (let type-node Int32 (arena-next-sibling a head))
      
      ;; Check if type-node is already (struct Name) form
      (if-stmt (== (arena-kind a type-node) (node-kind-list))
        (do
          ;; Already lowered or complex type - skip
          (return 0)
        )
        (do 0)
      )
      
      ;; Get struct name
      (let struct-name String (arena-value a type-node))
      
      ;; Check if this is a known struct
      (let struct-idx Int32 (struct-find struct-names struct-name))
      (if-stmt (== struct-idx (- 0 1))
        (return 0)
        (do 0)
      )
      
      ;; Build (struct Name) type node
      (let struct-type-node Int32 (build-struct-type-node a struct-name))
      
      ;; Now we need to extract just the values from (field val) pairs
      ;; and link them directly: (make (struct T) v1 v2 ...)
      (let first-pair Int32 (arena-next-sibling a type-node))
      
      ;; Collect values from field pairs
      (let first-val Int32 (- 0 1))
      (let prev-val Int32 (- 0 1))
      (let pair Int32 first-pair)
      
      (while (!= pair (- 0 1))
        (do
          ;; Each pair is (fieldname value) - extract the value (second child)
          (let pair-head Int32 (arena-first-child a pair))
          (let val-node Int32 (arena-next-sibling a pair-head))
          
          (if-stmt (== first-val (- 0 1))
            (set first-val val-node)
            (link-siblings a prev-val val-node)
          )
          (set prev-val val-node)
          
          (set pair (arena-next-sibling a pair))
        )
      )
      
      ;; Terminate the value chain
      (if-stmt (!= prev-val (- 0 1))
        (arena-set-next-sibling a prev-val (- 0 1))
        (do 0)
      )
      
      ;; Relink: head -> struct-type-node -> values...
      (link-siblings a head struct-type-node)
      (if-stmt (!= first-val (- 0 1))
        (link-siblings a struct-type-node first-val)
        (arena-set-next-sibling a struct-type-node (- 0 1))
      )
      
      (return 1)
    ))
  )

  ;; ============================================================
  ;; Recursive expression lowering
  ;; ============================================================

  (fn lower-expr
    (doc "Lower expressions recursively, tracking types.")
    (params
      (a (ptr Arena))
      (node Int32)
      (env-names ArrayString)
      (env-types ArrayString)
      (struct-names ArrayString)
      (struct-fields ArrayString)
    )
    (returns Int32)
    (body (do
      (if-stmt (== node (- 0 1))
        (return 0)
        (do 0)
      )
      
      (let kind Int32 (arena-kind a node))
      (if-stmt (== kind (node-kind-atom))
        (return 0)
        (do 0)
      )
      
      ;; It's a list - check the head
      (let head Int32 (arena-first-child a node))
      (if-stmt (== head (- 0 1))
        (return 0)
        (do 0)
      )
      
      (let head-val String (arena-value a head))
      
      ;; Check for get-field with 3 children (high-level form: head + ptr + field-name)
      (if-stmt (string-eq head-val "get-field")
        (do
          ;; Count children to distinguish forms
          (let child-count Int32 (count-children a node))
          (if-stmt (== child-count 3)
            (do
              ;; High-level form: (get-field ptr field-name)
              (lower-get-field a node env-names env-types struct-names struct-fields)
            )
            (do 0)
          )
        )
        (do 0)
      )
      
      ;; Check for set-field with 4 children (high-level form: head + ptr + field-name + val)
      (if-stmt (string-eq head-val "set-field")
        (do
          (let child-count Int32 (count-children a node))
          (if-stmt (== child-count 4)
            (do
              ;; High-level form: (set-field ptr field-name val)
              (lower-set-field a node env-names env-types struct-names struct-fields)
            )
            (do 0)
          )
        )
        (do 0)
      )
      
      ;; Check for make with field pairs
      (if-stmt (string-eq head-val "make")
        (do
          (let type-node Int32 (arena-next-sibling a head))
          (if-stmt (!= type-node (- 0 1))
            (do
              ;; Check if first arg after type is a list (field pair)
              (let first-arg Int32 (arena-next-sibling a type-node))
              (if-stmt (&& (!= first-arg (- 0 1)) (== (arena-kind a first-arg) (node-kind-list)))
                (lower-make a node struct-names struct-fields)
                (do 0)
              )
            )
            (do 0)
          )
        )
        (do 0)
      )
      
      ;; Recurse into children
      (let child Int32 (arena-first-child a node))
      (while (!= child (- 0 1))
        (do
          (lower-expr a child env-names env-types struct-names struct-fields)
          (set child (arena-next-sibling a child))
        )
      )
      
      (return 0)
    ))
  )

  ;; ============================================================
  ;; Lower statements (handles let to track types)
  ;; ============================================================

  (fn lower-stmt
    (doc "Lower a statement, tracking variable types from let bindings.")
    (params
      (a (ptr Arena))
      (node Int32)
      (env-names ArrayString)
      (env-types ArrayString)
      (struct-names ArrayString)
      (struct-fields ArrayString)
    )
    (returns Int32)
    (body (do
      (if-stmt (== node (- 0 1))
        (return 0)
        (do 0)
      )
      
      (let kind Int32 (arena-kind a node))
      (if-stmt (== kind (node-kind-atom))
        (return 0)
        (do 0)
      )
      
      (let head Int32 (arena-first-child a node))
      (if-stmt (== head (- 0 1))
        (return 0)
        (do 0)
      )
      
      (let head-val String (arena-value a head))
      
      ;; Handle let: (let name type init body...)
      (if-stmt (string-eq head-val "let")
        (do
          (let name-node Int32 (arena-next-sibling a head))
          (let type-node Int32 (arena-next-sibling a name-node))
          (let init-node Int32 (arena-next-sibling a type-node))
          
          (if-stmt (!= name-node (- 0 1))
            (do
              (let var-name String (arena-value a name-node))
              ;; Get the type - could be atom or (ptr T) list
              (let var-type String "")
              (if-stmt (== (arena-kind a type-node) (node-kind-atom))
                (set var-type (arena-value a type-node))
                (do
                  ;; Complex type like (ptr Arena) - stringify it
                  (set var-type (stringify-type-node a type-node))
                )
              )
              
              ;; Lower the init expression first
              (lower-expr a init-node env-names env-types struct-names struct-fields)
              
              ;; Add to environment
              (type-env-add env-names env-types var-name var-type)
              
              ;; Lower remaining body expressions
              (let body Int32 (arena-next-sibling a init-node))
              (while (!= body (- 0 1))
                (do
                  (lower-stmt a body env-names env-types struct-names struct-fields)
                  (set body (arena-next-sibling a body))
                )
              )
            )
            (do 0)
          )
          (return 0)
        )
        (do 0)
      )
      
      ;; Handle do block
      (if-stmt (string-eq head-val "do")
        (do
          (let child Int32 (arena-next-sibling a head))
          (while (!= child (- 0 1))
            (do
              (lower-stmt a child env-names env-types struct-names struct-fields)
              (set child (arena-next-sibling a child))
            )
          )
          (return 0)
        )
        (do 0)
      )

      ;; Handle block (similar to do but used as expression)
      (if-stmt (string-eq head-val "block")
        (do
          (let child Int32 (arena-next-sibling a head))
          (while (!= child (- 0 1))
            (do
              (lower-stmt a child env-names env-types struct-names struct-fields)
              (set child (arena-next-sibling a child))
            )
          )
          (return 0)
        )
        (do 0)
      )
      
      ;; Handle while, if-stmt, etc - recurse
      (if-stmt (|| (string-eq head-val "while") (string-eq head-val "if-stmt"))
        (do
          (let child Int32 (arena-next-sibling a head))
          (while (!= child (- 0 1))
            (do
              (lower-stmt a child env-names env-types struct-names struct-fields)
              (set child (arena-next-sibling a child))
            )
          )
          (return 0)
        )
        (do 0)
      )
      
      ;; Default: lower as expression
      (lower-expr a node env-names env-types struct-names struct-fields)
      (return 0)
    ))
  )

  ;; ============================================================
  ;; Stringify type node for environment
  ;; ============================================================

  (fn stringify-type-node
    (doc "Convert a type AST node to string representation.")
    (params (a (ptr Arena)) (node Int32))
    (returns String)
    (body (do
      (if-stmt (== (arena-kind a node) (node-kind-atom))
        (return (arena-value a node))
        (do
          ;; List like (ptr T) - build string
          (let head Int32 (arena-first-child a node))
          (let head-val String (arena-value a head))
          (if-stmt (string-eq head-val "ptr")
            (do
              (let inner Int32 (arena-next-sibling a head))
              (let inner-str String (stringify-type-node a inner))
              (return (string-concat "(ptr " (string-concat inner-str ")")))
            )
            (return "")
          )
        )
      )
    ))
  )

  ;; ============================================================
  ;; Lower function body
  ;; ============================================================

  (fn lower-fn-body
    (doc "Lower a function's body with param types in environment.")
    (params
      (a (ptr Arena))
      (fn-node Int32)
      (struct-names ArrayString)
      (struct-fields ArrayString)
    )
    (returns Int32)
    (body (do
      ;; Find params and body in function
      (let child Int32 (arena-first-child a fn-node))
      (let params-node Int32 (- 0 1))
      (let body-node Int32 (- 0 1))
      
      (while (!= child (- 0 1))
        (do
          (if-stmt (== (arena-kind a child) (node-kind-list))
            (do
              (let ch Int32 (arena-first-child a child))
              (if-stmt (!= ch (- 0 1))
                (do
                  (let ch-val String (arena-value a ch))
                  (if-stmt (string-eq ch-val "params")
                    (set params-node child)
                    (do 0)
                  )
                  (if-stmt (string-eq ch-val "body")
                    (set body-node child)
                    (do 0)
                  )
                )
                (do 0)
              )
            )
            (do 0)
          )
          (set child (arena-next-sibling a child))
        )
      )
      
      ;; Create type environment with params
      (let env-names ArrayString (array-str-new))
      (let env-types ArrayString (array-str-new))
      
      ;; Add parameters to environment
      (if-stmt (!= params-node (- 0 1))
        (do
          (let param Int32 (arena-next-sibling a (arena-first-child a params-node)))
          (while (!= param (- 0 1))
            (do
              ;; param is (name type) or just (name type) list
              (if-stmt (== (arena-kind a param) (node-kind-list))
                (do
                  (let pname-node Int32 (arena-first-child a param))
                  (let ptype-node Int32 (arena-next-sibling a pname-node))
                  (if-stmt (&& (!= pname-node (- 0 1)) (!= ptype-node (- 0 1)))
                    (do
                      (let pname String (arena-value a pname-node))
                      (let ptype String (stringify-type-node a ptype-node))
                      (type-env-add env-names env-types pname ptype)
                    )
                    (do 0)
                  )
                )
                (do 0)
              )
              (set param (arena-next-sibling a param))
            )
          )
        )
        (do 0)
      )
      
      ;; Lower body statements
      (if-stmt (!= body-node (- 0 1))
        (do
          (let stmt Int32 (arena-next-sibling a (arena-first-child a body-node)))
          (while (!= stmt (- 0 1))
            (do
              (lower-stmt a stmt env-names env-types struct-names struct-fields)
              (set stmt (arena-next-sibling a stmt))
            )
          )
        )
        (do 0)
      )
      
      (return 0)
    ))
  )

  ;; ============================================================
  ;; Main lowering pass entry point
  ;; ============================================================

  (fn lower-program
    (doc "Lower all high-level forms in the program.")
    (params
      (a (ptr Arena))
      (root Int32)
    )
    (returns Int32)
    (body (do
      ;; First collect struct definitions
      (let struct-names ArrayString (array-str-new))
      (let struct-fields ArrayString (array-str-new))
      (collect-structs a root struct-names struct-fields)
      
      ;; Walk all top-level declarations
      (let top Int32 (arena-first-child a root))
      (while (!= top (- 0 1))
        (do
          (if-stmt (== (arena-kind a top) (node-kind-list))
            (do
              (let head Int32 (arena-first-child a top))
              (if-stmt (!= head (- 0 1))
                (do
                  (let head-val String (arena-value a head))
                  ;; Lower fn and entry bodies
                  (if-stmt (|| (string-eq head-val "fn") (string-eq head-val "entry"))
                    (lower-fn-body a top struct-names struct-fields)
                    (do 0)
                  )
                )
                (do 0)
              )
            )
            (do 0)
          )
          (set top (arena-next-sibling a top))
        )
      )
      
      (return 0)
    ))
  )
) ;; module
