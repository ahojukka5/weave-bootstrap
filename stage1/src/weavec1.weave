(program
  (name "weavec1")
  (doc "Stage1 compiler: tokenize, parse, and emit LLVM IR using stage1 runtime.")
  (version "0.1")

  (include "string.weave")
  (include "file_io.weave")
  (include "buffers.weave")
  (include "arrays.weave")
  (include "cli.weave")
  (include "tokenizer.weave")
  (include "arena.weave")
  (include "sexpr_parser.weave")
  (include "typecheck/typecheck.weave")
  (include "include_expand.weave")
  (include "lower.weave")
  (include "ir_gen.weave")

  (type ExitCode
    (alias Int32)
  ) ;; type ExitCode

  (entry main
    (doc "Compile input file: default executable; -S for assembly; -emit-llvm for LLVM IR; -c for object.")
    (params (argc Int32) (argv (ptr String)))
    (returns ExitCode)
    (body
      (do
        ;; Parse command-line arguments via Weave CLI helpers (clang-compatible)
        (let input-path String (weave-get-input argc argv))
        (let output-path String (weave-get-option "o" argc argv))
        (let has-emit-llvm Int32 (weave-has-flag "emit-llvm" argc argv))
        (let has-S Int32 (weave-has-flag "S" argc argv))
        (let has-c Int32 (weave-has-flag "c" argc argv))
        ;; Optimization, includes and linking flags
        (let opt-O String (weave-get-option "O" argc argv))
        (let opt-I String (weave-get-option "I" argc argv))
        ;; Normalize NULL options to empty strings to avoid libc NULL deref
        (if-stmt (== input-path 0) (set input-path "") (do 0))
        (if-stmt (== output-path 0) (set output-path "") (do 0))
        (if-stmt (== opt-O 0) (set opt-O "") (do 0))
        (if-stmt (== opt-I 0) (set opt-I "") (do 0))
        (let has-static Int32 (weave-has-flag "static" argc argv))
        ;; Build extra clang flags string
        (let extra String "")
        (if-stmt (!= (string-length opt-O) 0)
          (set extra (string-concat extra (string-concat " -O" opt-O)))
          (do 0)
        )
        (if-stmt (!= (string-length opt-I) 0)
          (do
            (let len Int32 (string-length opt-I))
            (let i Int32 0)
            (let start Int32 0)
            (while (< i len)
              (do
                (let ch Int32 (string-char-at opt-I i))
                (let is-delim Int32 0)
                (if-stmt (== ch 44) (set is-delim 1) (do 0))
                (if-stmt (== ch 58) (set is-delim 1) (do 0))
                (if-stmt (!= is-delim 0)
                  (do
                    (let segLen Int32 (- i start))
                    (if-stmt (> segLen 0)
                      (do
                        (let seg String (string-slice opt-I start segLen))
                        (set extra (string-concat extra (string-concat " -I" seg)))
                      )
                      (do 0)
                    )
                    (set start (+ i 1))
                  )
                  (do 0)
                )
                (set i (+ i 1))
              )
            )
            (if-stmt (< start len)
              (do
                (let segLen Int32 (- len start))
                (let seg String (string-slice opt-I start segLen))
                (set extra (string-concat extra (string-concat " -I" seg)))
              )
              (do 0)
            )
          )
          (do 0)
        )
        (if-stmt (!= has-static 0)
          (set extra (string-concat extra " -static"))
          (do 0)
        )
        ;; Always silence known runtime warning
        (set extra (string-concat extra " -Wno-null-character"))
        ;; Disable FastISel to avoid clang crash on PHI handling
        (set extra (string-concat extra " -mllvm -fast-isel=false"))
        
        (let has-input Int32 0)
        (if-stmt (!= (string-length input-path) 0) (set has-input 1) (do 0))
        
        ;; Default output name per mode
        (if-stmt (== (string-length output-path) 0)
          (if-stmt (!= has-emit-llvm 0)
            (set output-path "a.ll")
            (if-stmt (!= has-S 0)
              (set output-path "a.s")
              (if-stmt (!= has-c 0)
                (set output-path "a.o")
                (set output-path "a.out")
              )
            )
          )
          (do 0)
        )
        
        ;; Check if input was provided
        (if-stmt (== has-input 0)
          (do
            (ccall "puts" (returns Int32) (args (String "Usage: weavec1 input.weave [options]")))
            (ccall "puts" (returns Int32) (args (String "Options:")))
            (ccall "puts" (returns Int32) (args (String "  -o <file>         Output file (default per mode)")))
            (ccall "puts" (returns Int32) (args (String "  -S                 Emit assembly (.s)")))
            (ccall "puts" (returns Int32) (args (String "  -emit-llvm         Emit LLVM IR (.ll)")))
            (ccall "puts" (returns Int32) (args (String "  -c                 Emit object (.o)")))
            (ccall "puts" (returns Int32) (args (String "  -O<N>              Optimization level (e.g., -O2)")))
            (ccall "puts" (returns Int32) (args (String "  -I<dir>            Add include directory for C compilation")))
            (ccall "puts" (returns Int32) (args (String "  -static            Link statically")))
            (return 2)
          )
          (do 0)
        )
        
        (let arena (ptr Arena) (arena-new))
        ;; Expand includes to bring in prelude and all modules before typecheck/codegen
        (let out-root Int32 0)
        (let rc Int32 (expand-root input-path arena (addr out-root)))
        (if-stmt (!= rc 0) (return 1) (do 0))
        (let root Int32 out-root)
        (ccall "puts" (returns Int32) (args (String "[weavec1] lowering...")))
        (let lc Int32 (lower-program arena root))
        (ccall "puts" (returns Int32) (args (String "[weavec1] typechecking...")))
        (let tc Int32 (typecheck_program arena root))
        (ccall "puts" (returns Int32) (args (String "[weavec1] typechecking done")))
        (if-stmt (!= tc 0) (return 1) (do 0))
        (ccall "puts" (returns Int32) (args (String "[weavec1] generating IR...")))
        (let ir-buf Buffer (buffer-new))
        (generate-ir arena root ir-buf 0)
        
        ;; Mode selection and output
        (if-stmt (!= has-emit-llvm 0)
          (do
            ;; Write IR directly
            (let write-rc Int32 (weave_write_file output-path (buffer-to-string ir-buf)))
            (if-stmt (== write-rc 0) (return 0) (return 1))
          )
          (do
            ;; Parse optimization level from -O flag (default to 0)
            (let opt-level Int32 0)
            (if-stmt (!= (string-length opt-O) 0)
              (set opt-level (c-atoi opt-O))
              (do 0)
            )
            ;; Clamp opt-level to valid range (0-3)
            (if-stmt (< opt-level 0) (set opt-level 0) (do 0))
            (if-stmt (> opt-level 3) (set opt-level 3) (do 0))
            
            ;; Get IR string from buffer
            (let ir-string String (buffer-to-string ir-buf))
            
            (if-stmt (!= has-S 0)
              (do
                ;; Assembly - use LLVM API
                (let rc Int32 (ccall "llvm-compile-ir-to-assembly" (returns Int32) (args (String ir-string) (String output-path) (Int32 opt-level))))
                (if-stmt (== rc 0) (return 0) (return 1))
              )
              (if-stmt (!= has-c 0)
                (do
                  ;; Object file - use LLVM API
                  (let rc Int32 (ccall "llvm-compile-ir-to-object" (returns Int32) (args (String ir-string) (String output-path) (Int32 opt-level))))
                  (if-stmt (== rc 0) (return 0) (return 1))
                )
                (do
                  ;; Executable - compile to object first, then link
                  (let runtime-path String (ccall "getenv" (returns String) (args (String "WEAVE_RUNTIME"))))
                  (let has-runtime Int32 0)
                  (if-stmt (!= (string-length runtime-path) 0) (set has-runtime 1) (do 0))
                  (if-stmt (== has-runtime 0)
                    (do
                      (ccall "puts" (returns Int32) (args (String "Error: WEAVE_RUNTIME environment variable not set")))
                      (return 1)
                    )
                    (do 0)
                  )
                  ;; Compile IR to object file using LLVM API
                  (let obj-tmp-path String "/tmp/weavec1_tmp.o")
                  (let rc Int32 (ccall "llvm-compile-ir-to-object" (returns Int32) (args (String ir-string) (String obj-tmp-path) (Int32 opt-level))))
                  (if-stmt (!= rc 0) (return 1) (do 0))
                  ;; Link object file to executable using LLVM API
                  (let obj-files String (string-concat obj-tmp-path (string-concat " " runtime-path)))
                  (let link-flags String (string-concat extra " -lm"))
                  (let link-rc Int32 (ccall "llvm-link-objects" (returns Int32) (args (String obj-files) (String link-flags) (String output-path))))
                  (if-stmt (== link-rc 0) (return 0) (return 1))
                )
              )
            )
          )
        )
      )
    ) ;; body
  ) ;; entry main
) ;; program
