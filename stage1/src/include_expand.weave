;;; @weave-allow-long-file: include expansion involves multiple helpers
(module
  (name "stage1-include-expand-core-a")
  (doc "Core helpers for include expansion: printable path, dirname, resolve, parse.")

  (include "tokenizer.weave")
  (include "sexpr_parser.weave")
  (include "arena.weave")
  (include "ir/util_strings_core.weave")

  (fn log-include
    (doc "Debug helper: print include path, current dir, and resolved path.")
    (params (label String) (inc String) (cur String) (resolved String)) (returns Int32)
    (body
      (ccall "puts" (returns Int32)
        (args (String (string-concat label (string-concat ": " (string-concat inc (string-concat " | " (string-concat cur (string-concat " -> " resolved))))))))
      )
      (return 0)
    )
    (tests
      (test log-include-basic
        (doc "returns 0 after printing composed path string")
        (tags unit include)
        (body
          (expect-eq (log-include "inc" "foo.weave" "/tmp" "/tmp/foo.weave") 0)
        )
      )
    )
  ) ;; fn log-include

  (fn is-printable-path
    (doc "Return 1 if path is non-empty, ends with .weave, contains '/', and all chars are ASCII [A-Za-z0-9._/\\-].")
    (params (path String)) (returns Int32)
    (body
      (let len Int32 (string-length path))
      (if-stmt (<= len 6) (return 0) (do 0))
      (if-stmt (!= (string-ends-with path ".weave") 1) (return 0) (do 0))
      (let has-slash Int32 0)
      (let i Int32 0)
      (while (< i len)
        (do
          (let ch Int32 (string-char-at path i))
          (if-stmt (== ch 47) (set has-slash 1) (do 0))  ;; Check for '/'
          (if-stmt
            (||
              (&& (>= ch 48) (<= ch 57))    ;; 0-9
              (||
                (&& (>= ch 65) (<= ch 90)) ;; A-Z
                (||
                  (&& (>= ch 97) (<= ch 122)) ;; a-z
                  (|| (== ch 46) (|| (== ch 47) (|| (== ch 45) (== ch 95)))) ;; . / - _
                )
              )
            )
            (do 0)
            (return 0)
          )
          (set i (+ i 1))
        )
      )
      (if-stmt (== has-slash 0) (return 0) (do 0))  ;; Require at least one '/'
      (return 1)
    )
    (tests
      (test printable-path-cases
        (doc "accepts ASCII paths ending in .weave, rejects others")
        (tags unit include)
        (body
          (expect-eq (is-printable-path "foo/bar.weave") 1)
          (expect-eq (is-printable-path "bad?.weave") 0)
          (expect-eq (is-printable-path "a.weave") 0)
        )
      )
    )
  ) ;; fn is-printable-path

  (fn dirname
    (doc "Return directory portion of path (up to last '/'); empty if none.")
    (params (path String)) (returns String)
    (body
      (let len Int32 (string-length path))
      (let i Int32 (- len 1))
      (while (&& (>= i 0) (!= (string-char-at path i) 47))
        (set i (- i 1))
      )
      (if-stmt (< i 0)
        (return "")
        (return (string-slice path 0 i))
      )
    )
    (tests
      (test dirname-cases
        (doc "extracts directory or empty when none")
        (tags unit include)
        (body
          (expect-eq (dirname "path/to/file.weave") "path/to")
          (expect-eq (dirname "file.weave") "")
          (expect-eq (dirname "/abs/path/file.weave") "/abs/path")
        )
      )
    )
  ) ;; fn dirname

  (fn resolve-path
    (doc "Resolve inc against current dir; absolute or explicit prefixes stay as-is.")
    (params (inc String) (current String)) (returns String)
    (body
      (if-stmt
        (||
          (string-starts-with inc "stage0/")
          (|| (string-starts-with inc "stage1/") (string-starts-with inc "stdlib/"))
        )
        (return inc)
        (do 0)
      )
      (if-stmt (string-starts-with inc "/") (return inc) (do 0))
      ;; If no current directory, just return inc.
      (if-stmt (== (string-length current) 0) (return inc) (do 0))
      ;; Normalize ./ prefix.
      (if-stmt (string-starts-with inc "./")
        (set inc (string-slice inc 2 (- (string-length inc) 2)))
        (do 0)
      )
      ;; Normalize ../ and simple relative by joining to current.
      (return (string-concat (string-concat current "/") inc))
    )
    (tests
      (test resolve-path-cases
        (doc "handles explicit prefixes, absolute, and relative resolution")
        (tags unit include)
        (body
          (expect-eq (resolve-path "stage1/foo.weave" "dir") "stage1/foo.weave")
          (expect-eq (resolve-path "/abs/foo.weave" "dir") "/abs/foo.weave")
          (expect-eq (resolve-path "./bar.weave" "dir") "dir/bar.weave")
          (expect-eq (resolve-path "baz.weave" "dir") "dir/baz.weave")
        )
      )
    )
  ) ;; fn resolve-path

  (fn parse-file-into
    (doc "Read and parse a file into arena a; returns root node id.")
    (params (path String) (a (ptr Arena))) (returns Int32)
    (body
      (let p String path)
      (if-stmt (== (is-string-literal p) 1)
        (set p (string-literal-value p))
        (set p p)
      )
      (let src String (ccall "weave_read_file" (returns String) (args (String p))))
      (ccall "puts" (returns Int32) (args (String "[include_expand] read file attempted")))
      (if-stmt (== (string-length src) 0)
        (do
          (let alt String (string-concat "bootstrap/" p))
          (set src (ccall "weave_read_file" (returns String) (args (String alt))))
           (if-stmt (== (string-length src) 0)
            (do
              (let alt2 String (string-concat "stdlib/" p))
              (set src (ccall "weave_read_file" (returns String) (args (String alt2))))
               (if-stmt (== (string-length src) 0) (return (- 0 1)) (do 0))
            )
            (do 0)
          )
        )
        (do 0)
      )
      (ccall "puts" (returns Int32) (args (String "[include_expand] read file ok")))
      (let tokens ArrayString (array-str-new))
      (tokenize src tokens)
      (ccall "puts" (returns Int32) (args (String "[include_expand] tokenized ok")))
      (return (parse-top a tokens))
    )
    (tests
      (test parse-file-into-missing
        (doc "returns -1 when file not found in any location")
        (tags unit include)
        (body
          (let a Arena (arena-new))
          (expect-eq (parse-file-into "not_exist.weave" (addr a)) (- 0 1))
        )
      )
    )
  ) ;; fn parse-file-into
) ;; module
(module
  (name "stage1-include-expand-core-b")
  (doc "Core expansion routines: copy-subtree, append-child, expand-children, expand-root.")

  (fn copy-subtree
    (doc "Deep-copy node from src arena into dst arena; returns new node id.")
    (params (src (ptr Arena)) (dst (ptr Arena)) (node Int32)) (returns Int32)
    (body
      (let kind Int32 (arena-kind src node))
      (let val String (arena-value src node))
      (let new-id Int32 (arena-add-node dst kind val))
      (let child Int32 (arena-first-child src node))
      (let prev Int32 (- 0 1))
      (while (!= child (- 0 1))
        (do
          (let copied Int32 (copy-subtree src dst child))
          (if-stmt (== prev (- 0 1))
            (arena-set-first-child dst new-id copied)
            (arena-set-next-sibling dst prev copied)
          )
          (set prev copied)
          (set child (arena-next-sibling src child))
        )
      )
      (return new-id)
    )
    (tests
      (test copy-subtree-basic
        (doc "copies node kind/value and child chain to dst")
        (tags unit include)
        (body
          (let src Arena (arena-new))
          (let dst Arena (arena-new))
          (let list Int32 (arena-add-node (addr src) (node-kind-list) ""))
          (let h Int32 (arena-add-node (addr src) (node-kind-atom) "x"))
          (let c1 Int32 (arena-add-node (addr src) (node-kind-atom) "y"))
          (arena-set-first-child (addr src) list h)
          (arena-set-next-sibling (addr src) h c1)
          (let new Int32 (copy-subtree (addr src) (addr dst) list))
          (expect-eq (arena-kind (addr dst) new) (node-kind-list))
          (let dh Int32 (arena-first-child (addr dst) new))
          (expect-eq (arena-kind (addr dst) dh) (node-kind-atom))
          (expect-eq (arena-value (addr dst) dh) "x")
          (let dc1 Int32 (arena-next-sibling (addr dst) dh))
          (expect-eq (arena-value (addr dst) dc1) "y")
        )
      )
    )
  ) ;; fn copy-subtree

  (fn append-child
    (doc "Append child to the end of parent's child list in arena a.")
    (params (a (ptr Arena)) (parent Int32) (child Int32)) (returns Int32)
    (body
      (let first Int32 (arena-first-child a parent))
      (if-stmt (== first (- 0 1))
        (arena-set-first-child a parent child)
        (do
          (let cur Int32 first)
          (while (!= (arena-next-sibling a cur) (- 0 1))
            (set cur (arena-next-sibling a cur))
          )
          (arena-set-next-sibling a cur child)
        )
      )
      (return 0)
    )
    (tests
      (test append-child-cases
        (doc "sets first child when empty and appends at end when not")
        (tags unit include)
        (body
          (let a Arena (arena-new))
          (let parent Int32 (arena-add-node (addr a) (node-kind-list) ""))
          (let c1 Int32 (arena-add-node (addr a) (node-kind-atom) "h"))
          (let c2 Int32 (arena-add-node (addr a) (node-kind-atom) "t"))
          (expect-eq (arena-first-child (addr a) parent) (- 0 1))
          (append-child (addr a) parent c1)
          (expect-eq (arena-first-child (addr a) parent) c1)
          (append-child (addr a) parent c2)
          (expect-eq (arena-next-sibling (addr a) c1) c2)
        )
      )
    )
  ) ;; fn append-child

  (fn expand-children
    (doc "Expand children of src-root into dst-root, splicing includes; visited guards duplicates. allow-inc=1 only when expanding a file root.")
    (params (src (ptr Arena)) (src-root Int32) (dst (ptr Arena)) (dst-root Int32) (visited ArrayString) (current-dir String) (allow-inc Int32)) (returns Int32)
    (body
      (let child Int32 (arena-first-child src src-root))
      (while (!= child (- 0 1))
        (do
          (if-stmt
            (&& (== (arena-kind src child) (node-kind-list)) (== allow-inc 1))
            (do
              (let head Int32 (arena-first-child src child))
              (if-stmt (== head (- 0 1))
                (do 0)
                (do
                  (let head-kind Int32 (arena-kind src head))
                  (if-stmt (!= head-kind (node-kind-atom))
                    (do
                      (let copied Int32 (copy-subtree src dst child))
                      (append-child dst dst-root copied)
                    )
                    (do
                      (let head-val String (arena-value src head))
                      (if-stmt (string-eq head-val "include")
                        (do
                          (let path-node Int32 (arena-next-sibling src head))
                          (let extra Int32 (arena-next-sibling src path-node))
                          (if-stmt (|| (== path-node (- 0 1)) (!= extra (- 0 1)))
                            (do
                              ;; Not a well-formed (include <path>) list; just copy it through.
                              (let copied Int32 (copy-subtree src dst child))
                              (append-child dst dst-root copied)
                            )
                            (do
                              (if-stmt (!= (arena-kind src path-node) (node-kind-atom))
                                (return (- 0 1))
                                (do 0)
                              )
                              (let inc-path String (arena-value src path-node))
                              (if-stmt (<= (string-length inc-path) 0) (return (- 0 1)) (do 0))
                              (if-stmt (!= (is-string-literal inc-path) 1)
                                (do
                                  ;; Require string literal include paths.
                                  (let copied Int32 (copy-subtree src dst child))
                                  (append-child dst dst-root copied)
                                )
                                (do
                                  (set inc-path (string-literal-value inc-path))
                                  (if-stmt (== (is-printable-path inc-path) 1)
                                    (do
                                      (let resolved String (resolve-path inc-path current-dir))
                                      (log-include "include" inc-path current-dir resolved)
                                      (ccall "puts" (returns Int32) (args (String "[include_expand] parsing include...")))
                                      (if-stmt (<= (string-length resolved) 0) (return (- 0 1)) (do 0))
                                      (if-stmt (== (array-str-contains visited resolved) 1)
                                        (do 0)
                                        (do
                                          (array-str-append visited resolved)
                                          (let tmp Arena (arena-new))
                                          (let inc-root Int32 (parse-file-into resolved (addr tmp)))
                                          (ccall "puts" (returns Int32) (args (String "[include_expand] include parsed.")))
                                          (if-stmt (== inc-root (- 0 1))
                                            (do
                                              ;; Could not load include; treat as plain node copy.
                                              (let copied Int32 (copy-subtree src dst child))
                                              (append-child dst dst-root copied)
                                            )
                                            (do
                                              (let next-dir String (dirname resolved))
                                              ;; Check if inc-root is (multi-top ...) - if so, expand each top-level form
                                              (let inc-head Int32 (arena-first-child (addr tmp) inc-root))
                                              (ccall "puts" (returns Int32) (args (String "[include_expand] expanding children of include...")))
                                              (let is-multi Int32 0)
                                              (if-stmt (&& (!= inc-head (- 0 1)) (== (arena-kind (addr tmp) inc-head) (node-kind-atom)))
                                                (if-stmt (string-eq (arena-value (addr tmp) inc-head) "multi-top")
                                                  (set is-multi 1)
                                                  (do 0)
                                                )
                                                (do 0)
                                              )
                                              (if-stmt (== is-multi 1)
                                                (do
                                                  ;; Expand each child of multi-top (skip the "multi-top" atom)
                                                  (let mt-child Int32 (arena-next-sibling (addr tmp) inc-head))
                                                  (while (!= mt-child (- 0 1))
                                                    (do
                                                      ;; Check what kind of top-level form this is
                                                      (let mt-head Int32 (arena-first-child (addr tmp) mt-child))
                                                      (let is-mod Int32 0)
                                                      (if-stmt (&& (!= mt-head (- 0 1)) (== (arena-kind (addr tmp) mt-head) (node-kind-atom)))
                                                        (if-stmt (string-eq (arena-value (addr tmp) mt-head) "module")
                                                          (set is-mod 1)
                                                          (do 0)
                                                        )
                                                        (do 0)
                                                      )
                                                      (if-stmt (== is-mod 1)
                                                        (do
                                                          ;; Module: expand its children (fn, type, include, etc.)
                                                          (let rc Int32 (expand-children (addr tmp) mt-child dst dst-root visited next-dir 1))
                                                          (if-stmt (== rc (- 0 1)) (return (- 0 1)) (do 0))
                                                        )
                                                        (do
                                                          ;; Not a module (fn, type, etc.): just copy the whole form
                                                          (let copied Int32 (copy-subtree (addr tmp) dst mt-child))
                                                          (append-child dst dst-root copied)
                                                        )
                                                      )
                                                      (set mt-child (arena-next-sibling (addr tmp) mt-child))
                                                    )
                                                  )
                                                )
                                                (do
                                                  ;; Not multi-top: if included root is a module, flatten its children;
                                                  ;; otherwise, copy the root as-is into destination.
                                                  (let inc-root-head Int32 (arena-first-child (addr tmp) inc-root))
                                                  (let is-inc-module Int32 0)
                                                  (if-stmt (&& (!= inc-root-head (- 0 1)) (== (arena-kind (addr tmp) inc-root-head) (node-kind-atom)))
                                                    (if-stmt (string-eq (arena-value (addr tmp) inc-root-head) "module")
                                                      (set is-inc-module 1)
                                                      (do 0)
                                                    )
                                                    (do 0)
                                                  )
                                                  (if-stmt (== is-inc-module 1)
                                                    (do
                                                      ;; Flatten module contents into destination
                                                      (let rc2 Int32 (expand-children (addr tmp) inc-root dst dst-root visited next-dir 1))
                                                      (if-stmt (== rc2 (- 0 1)) (return (- 0 1)) (do 0))
                                                      (ccall "puts" (returns Int32) (args (String "[include_expand] flattened module children")))
                                                    )
                                                    (do
                                                      ;; Copy non-module root as-is
                                                      (let copied Int32 (copy-subtree (addr tmp) dst inc-root))
                                                      (append-child dst dst-root copied)
                                                      (ccall "puts" (returns Int32) (args (String "[include_expand] appended included root")))
                                                    )
                                                  )
                                                )
                                              )
                                            )
                                          )
                                        )
                                      )
                                    )
                                    (do
                                      ;; Malformed include path: treat as a normal node copy.
                                      (let copied Int32 (copy-subtree src dst child))
                                      (append-child dst dst-root copied)
                                    )
                                  )
                                )
                              )
                            )
                          )
                        )
                        (do
                          (let copied Int32 (copy-subtree src dst child))
                          (append-child dst dst-root copied)
                        )
                      )
                    )
                  )
                )
              )
            )
            (do
              (let copied Int32 (copy-subtree src dst child))
              (append-child dst dst-root copied)
            )
          )
          (set child (arena-next-sibling src child))
        )
      )
      (return 0)
    )
    (tests
      (test expand-children-copy-through
        (doc "copies non-include forms when allow-inc=0")
        (tags unit include)
        (body
          (let src Arena (arena-new))
          (let dst Arena (arena-new))
          (let srcRoot Int32 (arena-add-node (addr src) (node-kind-list) ""))
          (let form Int32 (arena-add-node (addr src) (node-kind-list) ""))
          (let head Int32 (arena-add-node (addr src) (node-kind-atom) "foo"))
          (let arg Int32 (arena-add-node (addr src) (node-kind-atom) "bar"))
          (arena-set-first-child (addr src) srcRoot form)
          (arena-set-first-child (addr src) form head)
          (arena-set-next-sibling (addr src) head arg)
          (let dstRoot Int32 (arena-add-node (addr dst) (node-kind-list) ""))
          (let visited ArrayString (array-str-new))
          (let rc Int32 (expand-children (addr src) srcRoot (addr dst) dstRoot visited "" 0))
          (expect-eq rc 0)
          (let copied Int32 (arena-first-child (addr dst) dstRoot))
          (expect-eq (arena-kind (addr dst) copied) (node-kind-list))
          (let chead Int32 (arena-first-child (addr dst) copied))
          (expect-eq (arena-value (addr dst) chead) "foo")
        )
      )
    )
  ) ;; fn expand-children

  (fn expand-root
    (doc "Parse path and return a new arena with includes expanded.")
    (params (path String) (out-arena (ptr Arena)) (out-root (ptr Int32))) (returns Int32)
    (body
      (let tmp Arena (arena-new))
      (let tmp-root Int32 (parse-file-into path (addr tmp)))
      (if-stmt (== tmp-root (- 0 1)) (return (- 0 1)) (do 0))
      ;; If tmp-root is (multi-top X), unwrap to get X as the actual root
      (let actual-root Int32 tmp-root)
      (let head Int32 (arena-first-child (addr tmp) tmp-root))
      (if-stmt (&& (!= head (- 0 1)) (== (arena-kind (addr tmp) head) (node-kind-atom)))
        (if-stmt (string-eq (arena-value (addr tmp) head) "multi-top")
          (do
            (let first-child Int32 (arena-next-sibling (addr tmp) head))
            (if-stmt (!= first-child (- 0 1))
              (set actual-root first-child)
              (do 0)
            )
          )
          (do 0)
        )
        (do 0)
      )
      (let root-kind Int32 (arena-kind (addr tmp) actual-root))
      (let root-val String (arena-value (addr tmp) actual-root))
      ;; Expand includes recursively with validation/arity checks.
      (let new-root Int32 (arena-add-node out-arena root-kind root-val))
      (let visited ArrayString (array-str-new))
      (array-str-append visited path)
      (let base String (dirname path))
      (let rc Int32 (expand-children (addr tmp) actual-root out-arena new-root visited base 1))
      (if-stmt (== rc (- 0 1))
        (return (- 0 1))
        (do
          (store Int32 out-root new-root)
          (return 0)
        )
      )
    )
    (tests
      (test expand-root-missing
        (doc "returns -1 when parse-file-into fails to read path")
        (tags unit include)
        (body
          (let out Arena (arena-new))
          (let outRoot Int32 0)
          (expect-eq (expand-root "not_exist.weave" (addr out) (addr outRoot)) (- 0 1))
        )
      )
    )
  ) ;; fn expand-root
) ;; module
