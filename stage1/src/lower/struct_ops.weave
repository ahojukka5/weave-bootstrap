  ;; (Deprecated) Lower get-field: handled in IR now; keep minimal tests

  (fn lower-get-field
    (doc "Deprecated: no-op; IR handles get-field directly.")
    (params
      (a (ptr Arena))
      (node Int32)
      (env-names ArrayString)
      (env-types ArrayString)
      (struct-names ArrayString)
      (struct-fields ArrayString)
    )
    (returns Int32)
    (body (return 0))
    (tests
      (test lower-get-field-noop-basic
        (doc "returns 0 and leaves node unchanged")
        (tags unit lower)
        (body
          (let a (ptr Arena) (arena-create 256))
          (let node Int32 (parse-string a "(get-field p x)"))
          (let rc Int32 (lower-get-field a node (array-str-new) (array-str-new) (array-str-new) (array-str-new)))
          (expect-eq rc 0)
        )
      )
    )
  )

  ;; ============================================================
  ;; (Deprecated) Lower set-field: handled in IR now
  ;; ============================================================

  (fn lower-set-field
    (doc "Deprecated: no-op; IR handles set-field directly.")
    (params
      (a (ptr Arena))
      (node Int32)
      (env-names ArrayString)
      (env-types ArrayString)
      (struct-names ArrayString)
      (struct-fields ArrayString)
    )
    (returns Int32)
    (body (return 0))
    (tests
      (test lower-set-field-noop-basic
        (doc "returns 0")
        (tags unit lower)
        (body
          (let a (ptr Arena) (arena-create 256))
          (let node Int32 (parse-string a "(set-field p b x)"))
          (let rc Int32 (lower-set-field a node (array-str-new) (array-str-new) (array-str-new) (array-str-new)))
          (expect-eq rc 0)
        )
      )
    )
  )

  ;; ============================================================
  ;; Lower make: (make Type (f1 v1) ...) -> (make (struct T) v1 v2 ...)
  ;; ============================================================

  (fn lower-make
    (doc "Lower (make Type (f1 v1) ...) to (make (struct T) v1 v2 ...).")
    (params
      (a (ptr Arena))
      (node Int32)
      (struct-names ArrayString)
      (struct-fields ArrayString)
    )
    (returns Int32)
    (body (do
      ;; Current form: (make TypeName (field1 val1) (field2 val2) ...)
      (let head Int32 (arena-first-child a node))
      (let type-node Int32 (arena-next-sibling a head))
      
      ;; Check if type-node is already (struct Name) form
      (if-stmt (== (arena-kind a type-node) (node-kind-list))
        (do
          ;; Already lowered or complex type - skip
          (return 0)
        )
        (do 0)
      )
      
      ;; Get struct name
      (let struct-name String (arena-value a type-node))
      
      ;; Check if this is a known struct
      (let struct-idx Int32 (struct-find struct-names struct-name))
      (if-stmt (== struct-idx (- 0 1))
        (return 0)
        (do 0)
      )
      
      ;; Build (struct Name) type node
      (let struct-type-node Int32 (build-struct-type-node a struct-name))
      
      ;; Now we need to extract just the values from (field val) pairs
      ;; and link them directly: (make (struct T) v1 v2 ...)
      (let first-pair Int32 (arena-next-sibling a type-node))
      
      ;; Collect values from field pairs
      (let first-val Int32 (- 0 1))
      (let prev-val Int32 (- 0 1))
      (let pair Int32 first-pair)
      
      (while (!= pair (- 0 1))
        (do
          ;; Each pair is (fieldname value) - extract the value (second child)
          (let pair-head Int32 (arena-first-child a pair))
          (let val-node Int32 (arena-next-sibling a pair-head))
          
          (if-stmt (== first-val (- 0 1))
            (set first-val val-node)
            (link-siblings a prev-val val-node)
          )
          (set prev-val val-node)
          
          (set pair (arena-next-sibling a pair))
        )
      )
      
      ;; Terminate the value chain
      (if-stmt (!= prev-val (- 0 1))
        (arena-set-next-sibling a prev-val (- 0 1))
        (do 0)
      )
      
      ;; Relink: head -> struct-type-node -> values...
      (link-siblings a head struct-type-node)
      (if-stmt (!= first-val (- 0 1))
        (link-siblings a struct-type-node first-val)
        (arena-set-next-sibling a struct-type-node (- 0 1))
      )
      
      (return 1)
    ))
    (tests
      (test lower-make-basic
        (doc "lowers to (make (struct T) v1 v2 ...)")
        (tags unit lower)
        (body
          (let a (ptr Arena) (arena-create 256))
          (let node Int32 (parse-string a "(make Foo (a 1) (b x))"))
          (let struct-names ArrayString (array-str-new))
          (let struct-fields ArrayString (array-str-new))
          (array-str-append struct-names "Foo")
          (array-str-append struct-fields "a:Int32,b:String")
          (let rc Int32 (lower-make a node struct-names struct-fields))
          (expect-eq rc 1)
          (let head Int32 (arena-first-child a node))
          (let s Int32 (arena-next-sibling a head))
          (expect-eq (arena-kind a s) (node-kind-list))
        )
      )
    )
  )
