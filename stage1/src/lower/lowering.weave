  ;; ============================================================
  ;; Recursive expression lowering
  ;; ============================================================

  (fn lower-expr
    (doc "Lower expressions recursively, tracking types.")
    (params
      (a (ptr Arena))
      (node Int32)
      (env-names ArrayString)
      (env-types ArrayString)
      (struct-names ArrayString)
      (struct-fields ArrayString)
    )
    (returns Int32)
    (body (do
      (if-stmt (== node (- 0 1))
        (return 0)
        (do 0)
      )
      
      (let kind Int32 (arena-kind a node))
      (if-stmt (== kind (node-kind-atom))
        (return 0)
        (do 0)
      )
      
      ;; It's a list - check the head
      (let head Int32 (arena-first-child a node))
      (if-stmt (== head (- 0 1))
        (return 0)
        (do 0)
      )
      
      (let head-val String (arena-value a head))
      
      ;; Check for get-field with 3 children (high-level form: head + ptr + field-name)
      (if-stmt (string-eq head-val "get-field")
        (do
          ;; Count children to distinguish forms
          (let child-count Int32 (count-children a node))
          (if-stmt (== child-count 3)
            (do
              ;; High-level form: (get-field ptr field-name)
              (lower-get-field a node env-names env-types struct-names struct-fields)
            )
            (do 0)
          )
        )
        (do 0)
      )
      
      ;; Check for set-field with 4 children (high-level form: head + ptr + field-name + val)
      (if-stmt (string-eq head-val "set-field")
        (do
          (let child-count Int32 (count-children a node))
          (if-stmt (== child-count 4)
            (do
              ;; High-level form: (set-field ptr field-name val)
              (lower-set-field a node env-names env-types struct-names struct-fields)
            )
            (do 0)
          )
        )
        (do 0)
      )
      
      ;; Check for make with field pairs
      (if-stmt (string-eq head-val "make")
        (do
          (let type-node Int32 (arena-next-sibling a head))
          (if-stmt (!= type-node (- 0 1))
            (do
              ;; Check if first arg after type is a list (field pair)
              (let first-arg Int32 (arena-next-sibling a type-node))
              (if-stmt (&& (!= first-arg (- 0 1)) (== (arena-kind a first-arg) (node-kind-list)))
                (lower-make a node struct-names struct-fields)
                (do 0)
              )
            )
            (do 0)
          )
        )
        (do 0)
      )
      
      ;; Recurse into children
      (let child Int32 (arena-first-child a node))
      (while (!= child (- 0 1))
        (do
          (lower-expr a child env-names env-types struct-names struct-fields)
          (set child (arena-next-sibling a child))
        )
      )
      
      (return 0)
    ))
  )

  ;; ============================================================
  ;; Lower statements (handles let to track types)
  ;; ============================================================

  (fn lower-stmt
    (doc "Lower a statement, tracking variable types from let bindings.")
    (params
      (a (ptr Arena))
      (node Int32)
      (env-names ArrayString)
      (env-types ArrayString)
      (struct-names ArrayString)
      (struct-fields ArrayString)
    )
    (returns Int32)
    (body (do
      (if-stmt (== node (- 0 1))
        (return 0)
        (do 0)
      )
      
      (let kind Int32 (arena-kind a node))
      (if-stmt (== kind (node-kind-atom))
        (return 0)
        (do 0)
      )
      
      (let head Int32 (arena-first-child a node))
      (if-stmt (== head (- 0 1))
        (return 0)
        (do 0)
      )
      
      (let head-val String (arena-value a head))
      
      ;; Handle let: (let name type init body...)
      (if-stmt (string-eq head-val "let")
        (do
          (let name-node Int32 (arena-next-sibling a head))
          (let type-node Int32 (arena-next-sibling a name-node))
          (let init-node Int32 (arena-next-sibling a type-node))
          
          (if-stmt (!= name-node (- 0 1))
            (do
              (let var-name String (arena-value a name-node))
              ;; Get the type - could be atom or (ptr T) list
              (let var-type String "")
              (if-stmt (== (arena-kind a type-node) (node-kind-atom))
                (set var-type (arena-value a type-node))
                (do
                  ;; Complex type like (ptr Arena) - stringify it
                  (set var-type (stringify-type-node a type-node))
                )
              )
              
              ;; Lower the init expression first
              (lower-expr a init-node env-names env-types struct-names struct-fields)
              
              ;; Add to environment
              (type-env-add env-names env-types var-name var-type)
              
              ;; Lower remaining body expressions
              (let body Int32 (arena-next-sibling a init-node))
              (while (!= body (- 0 1))
                (do
                  (lower-stmt a body env-names env-types struct-names struct-fields)
                  (set body (arena-next-sibling a body))
                )
              )
            )
            (do 0)
          )
          (return 0)
        )
        (do 0)
      )
      
      ;; Handle do block
      (if-stmt (string-eq head-val "do")
        (do
          (let child Int32 (arena-next-sibling a head))
          (while (!= child (- 0 1))
            (do
              (lower-stmt a child env-names env-types struct-names struct-fields)
              (set child (arena-next-sibling a child))
            )
          )
          (return 0)
        )
        (do 0)
      )

      ;; Handle block (similar to do but used as expression)
      (if-stmt (string-eq head-val "block")
        (do
          (let child Int32 (arena-next-sibling a head))
          (while (!= child (- 0 1))
            (do
              (lower-stmt a child env-names env-types struct-names struct-fields)
              (set child (arena-next-sibling a child))
            )
          )
          (return 0)
        )
        (do 0)
      )
      
      ;; Handle while, if-stmt, etc - recurse
      (if-stmt (|| (string-eq head-val "while") (string-eq head-val "if-stmt"))
        (do
          (let child Int32 (arena-next-sibling a head))
          (while (!= child (- 0 1))
            (do
              (lower-stmt a child env-names env-types struct-names struct-fields)
              (set child (arena-next-sibling a child))
            )
          )
          (return 0)
        )
        (do 0)
      )
      
      ;; Default: lower as expression
      (lower-expr a node env-names env-types struct-names struct-fields)
      (return 0)
    ))
  )

  ;; ============================================================
  ;; Lower function body
  ;; ============================================================

  (fn lower-fn-body
    (doc "Lower a function's body with param types in environment.")
    (params
      (a (ptr Arena))
      (fn-node Int32)
      (struct-names ArrayString)
      (struct-fields ArrayString)
    )
    (returns Int32)
    (body (do
      ;; Find params and body in function
      (let child Int32 (arena-first-child a fn-node))
      (let params-node Int32 (- 0 1))
      (let body-node Int32 (- 0 1))
      
      (while (!= child (- 0 1))
        (do
          (if-stmt (== (arena-kind a child) (node-kind-list))
            (do
              (let ch Int32 (arena-first-child a child))
              (if-stmt (!= ch (- 0 1))
                (do
                  (let ch-val String (arena-value a ch))
                  (if-stmt (string-eq ch-val "params")
                    (set params-node child)
                    (do 0)
                  )
                  (if-stmt (string-eq ch-val "body")
                    (set body-node child)
                    (do 0)
                  )
                )
                (do 0)
              )
            )
            (do 0)
          )
          (set child (arena-next-sibling a child))
        )
      )
      
      ;; Create type environment with params
      (let env-names ArrayString (array-str-new))
      (let env-types ArrayString (array-str-new))
      
      ;; Add parameters to environment
      (if-stmt (!= params-node (- 0 1))
        (do
          (let param Int32 (arena-next-sibling a (arena-first-child a params-node)))
          (while (!= param (- 0 1))
            (do
              ;; param is (name type) or just (name type) list
              (if-stmt (== (arena-kind a param) (node-kind-list))
                (do
                  (let pname-node Int32 (arena-first-child a param))
                  (let ptype-node Int32 (arena-next-sibling a pname-node))
                  (if-stmt (&& (!= pname-node (- 0 1)) (!= ptype-node (- 0 1)))
                    (do
                      (let pname String (arena-value a pname-node))
                      (let ptype String (stringify-type-node a ptype-node))
                      (type-env-add env-names env-types pname ptype)
                    )
                    (do 0)
                  )
                )
                (do 0)
              )
              (set param (arena-next-sibling a param))
            )
          )
        )
        (do 0)
      )
      
      ;; Lower body statements
      (if-stmt (!= body-node (- 0 1))
        (do
          (let stmt Int32 (arena-next-sibling a (arena-first-child a body-node)))
          (while (!= stmt (- 0 1))
            (do
              (lower-stmt a stmt env-names env-types struct-names struct-fields)
              (set stmt (arena-next-sibling a stmt))
            )
          )
        )
        (do 0)
      )
      
      (return 0)
    ))
  )

  ;; ============================================================
  ;; Main lowering pass entry point
  ;; ============================================================

  (fn lower-program
    (doc "Lower all high-level forms in the program.")
    (params
      (a (ptr Arena))
      (root Int32)
    )
    (returns Int32)
    (body (do
      ;; First collect struct definitions
      (let struct-names ArrayString (array-str-new))
      (let struct-fields ArrayString (array-str-new))
      (collect-structs a root struct-names struct-fields)
      
      ;; Walk all top-level declarations
      (let top Int32 (arena-first-child a root))
      (while (!= top (- 0 1))
        (do
          (if-stmt (== (arena-kind a top) (node-kind-list))
            (do
              (let head Int32 (arena-first-child a top))
              (if-stmt (!= head (- 0 1))
                (do
                  (let head-val String (arena-value a head))
                  ;; Lower fn and entry bodies
                  (if-stmt (|| (string-eq head-val "fn") (string-eq head-val "entry"))
                    (lower-fn-body a top struct-names struct-fields)
                    (do 0)
                  )
                )
                (do 0)
              )
            )
            (do 0)
          )
          (set top (arena-next-sibling a top))
        )
      )
      
      (return 0)
    ))
  )
