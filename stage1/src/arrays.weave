(module
  (name "arrays")
  (doc "Array implementation in Weave - replaces C runtime functions.")
  (include "libc.weave")

  (struct ArrayInt32Data
    (field data (ptr Int32))
    (field len Int32)
    (field cap Int32)
  )

  (struct ArrayStringData
    (field data (ptr String))
    (field len Int32)
    (field cap Int32)
  )

  (type ArrayString (alias (ptr ArrayStringData)))
  (type ArrayInt32 (alias (ptr ArrayInt32Data)))

  ;; Compatibility wrappers for legacy call sites
  (fn array-string-create
    (doc "Create a new dynamic array of strings (compat wrapper).")
    (params ())
    (returns ArrayString)
    (body (return (array-str-new)))
    (tests
      (test array-string-create-compat
        (doc "array-string-create delegates to array-str-new")
        (tags unit arrays)
        (body
          (let result ArrayString (array-string-create))
          (expect-true (!= result 0))
        )
      )
    )
  )

  (fn array-int32-create
    (doc "Create a new dynamic array of Int32 (compat wrapper).")
    (params ())
    (returns ArrayInt32)
    (body (return (array-i32-new)))
    (tests
      (test array-int32-create-compat
        (doc "array-int32-create delegates to array-i32-new")
        (tags unit arrays)
        (body
          (let result ArrayInt32 (array-int32-create))
          (expect-true (!= result 0))
        )
      )
    )
  )

  (fn array-str-grow
    (doc "Internal: grow String array to at least 'need' capacity.")
    (params (a ArrayString) (need Int32)) (returns Int32)
    (body
      (do
        (if-stmt (< need 0) (return (- 0 1)) (do 0))
        (let current-cap Int32 (get-field a cap))
        (if-stmt (>= current-cap need) (return 0) (do 0))
        (let ncap Int32 (if-stmt (== current-cap 0) 8 current-cap))
        (while (< ncap need) (set ncap (* ncap 2)))
        (let old-data (ptr String) (get-field a data))
        (let new-data (ptr String) (bitcast (ptr String) (c-malloc (* ncap 8))))
        (if-stmt (== new-data 0) (return (- 0 1)) (do 0))
        (if-stmt (!= old-data 0)
          (do
            (let current-len Int32 (get-field a len))
            (if-stmt (> current-len 0)
              (c-memcpy (bitcast (ptr Int8) new-data) (bitcast (ptr Int8) old-data) (* current-len 8))
              (do 0)
            )
            (c-free (bitcast (ptr Int8) old-data))
          )
          (do 0)
        )
        (set-field a data new-data)
        (set-field a cap ncap)
        (return 0)
      )
    )
    (tests
      (test array-str-grow-basic
        (doc "grow should increase capacity when needed")
        (tags unit arrays)
        (body
          (let arr ArrayString (array-str-new))
          (let result Int32 (array-str-grow arr 100))
          (expect-eq result 0)
        )
      )
    )
  )

  (fn array-str-new
    (doc "Create a new dynamic array of strings.")
    (params ())
    (returns ArrayString)
    (body
      (do
        (let raw (ptr Int8) (c-malloc 12))
        (if-stmt (== raw 0) (return 0) (do 0))
        (let arr (ptr ArrayStringData) (bitcast (ptr ArrayStringData) raw))
        (set-field arr data (bitcast (ptr String) 0))
        (set-field arr len 0)
        (set-field arr cap 0)
        (return arr)
      )
    )
    (tests
      (test array-str-new-creates
        (doc "array-str-new should return non-zero")
        (tags unit arrays)
        (body
          (let result ArrayString (array-str-new))
          (expect-true (!= result 0))
        )
      )
    )
  )

  (fn array-str-len
    (doc "Return the element count of a string array.")
    (params (a ArrayString))
    (returns Int32)
    (body
      (return (if-stmt (== a 0) 0 (get-field a len)))
    )
    (tests
      (test array-str-len-empty
        (doc "new array has length 0")
        (tags unit arrays)
        (body
          (let arr ArrayString (array-str-new))
          (let len Int32 (array-str-len arr))
          (expect-eq len 0)
        )
      )
    )
  )

  (fn array-str-append
    (doc "Append a string to the end of the array.")
    (params (a ArrayString) (v String))
    (returns Int32)
    (body
      (do
        (if-stmt (== a 0) (return (- 0 1)) (do 0))
        (let current-len Int32 (get-field a len))
        (let need Int32 (+ current-len 1))
        (if-stmt (!= (array-str-grow a need) 0) (return (- 0 1)) (do 0))
        (let data (ptr String) (get-field a data))
        (let target (ptr String) (ptr-add String data current-len))
        (store String v target)
        (set-field a len need)
        (return 0)
      )
    )
    (tests
      (test array-str-append-basic
        (doc "append two strings then verify length and values")
        (tags unit arrays)
        (body
          (let arr ArrayString (array-str-new))
          (array-str-append arr "foo")
          (array-str-append arr "bar")
          (let len Int32 (array-str-len arr))
          (expect-eq len 2)
          (let s0 String (array-str-get arr 0))
          (let eq0 Int32 (string-eq s0 "foo"))
          (expect-eq eq0 1)
          (let s1 String (array-str-get arr 1))
          (let eq1 Int32 (string-eq s1 "bar"))
          (expect-eq eq1 1)
        )
      )
    )
  )

  (fn array-str-get
    (doc "Get the string at idx.")
    (params (a ArrayString) (idx Int32))
    (returns String)
    (body
      (do
        (if-stmt (== a 0) (return 0) (do 0))
        (let len Int32 (get-field a len))
        (if-stmt (|| (< idx 0) (>= idx len)) (return 0) (do 0))
        (let data (ptr String) (get-field a data))
        (let ptr (ptr String) (ptr-add String data idx))
        (return (load String ptr))
      )
    )
    (tests
      (test array-str-get-basic
        (doc "append then get should return same string")
        (tags unit arrays)
        (body
          (let arr ArrayString (array-str-new))
          (array-str-append arr "hello")
          (let s String (array-str-get arr 0))
          (let eq Int32 (string-eq s "hello"))
          (expect-eq eq 1)
        )
      )
    )
  )

  (fn array-i32-grow
    (doc "Internal: grow Int32 array to at least 'need' capacity.")
    (params (a ArrayInt32) (need Int32)) (returns Int32)
    (body
      (do
        (if-stmt (< need 0) (return (- 0 1)) (do 0))
        (let current-cap Int32 (get-field a cap))
        (if-stmt (>= current-cap need) (return 0) (do 0))
        (let ncap Int32 (if-stmt (== current-cap 0) 16 current-cap))
        (while (< ncap need) (set ncap (* ncap 2)))
        (let old-data (ptr Int32) (get-field a data))
        (let new-data (ptr Int32) (bitcast (ptr Int32) (c-malloc (* ncap 4))))
        (if-stmt (== new-data 0) (return (- 0 1)) (do 0))
        (if-stmt (!= old-data 0)
          (do
            (let current-len Int32 (get-field a len))
            (if-stmt (> current-len 0)
              (c-memcpy (bitcast (ptr Int8) new-data) (bitcast (ptr Int8) old-data) (* current-len 4))
              (do 0)
            )
            (c-free (bitcast (ptr Int8) old-data))
          )
          (do 0)
        )
        (set-field a data new-data)
        (set-field a cap ncap)
        (return 0)
      )
    )
    (tests
      (test array-i32-grow-basic
        (doc "grow should increase capacity when needed")
        (tags unit arrays)
        (body
          (let arr ArrayInt32 (array-i32-new))
          (let result Int32 (array-i32-grow arr 100))
          (expect-eq result 0)
        )
      )
    )
  )

  (fn array-i32-new
    (doc "Create a new dynamic array of 32-bit integers.")
    (params ())
    (returns ArrayInt32)
    (body
      (do
        (let raw (ptr Int8) (c-malloc 12))
        (if-stmt (== raw 0) (return 0) (do 0))
        (let arr (ptr ArrayInt32Data) (bitcast (ptr ArrayInt32Data) raw))
        (set-field arr data (bitcast (ptr Int32) 0))
        (set-field arr len 0)
        (set-field arr cap 0)
        (return arr)
      )
    )
    (tests
      (test array-i32-new-creates
        (doc "array-i32-new should return non-zero")
        (tags unit arrays)
        (body
          (let result ArrayInt32 (array-i32-new))
          (expect-true (!= result 0))
        )
      )
    )
  )

  (fn array-i32-len
    (doc "Return the element count of an int array.")
    (params (a ArrayInt32))
    (returns Int32)
    (body
      (return (if-stmt (== a 0) 0 (get-field a len)))
    )
    (tests
      (test array-i32-len-empty
        (doc "new array has length 0")
        (tags unit arrays)
        (body
          (let arr ArrayInt32 (array-i32-new))
          (let len Int32 (array-i32-len arr))
          (expect-eq len 0)
        )
      )
    )
  )

  (fn array-i32-append
    (doc "Append an Int32 to the end of the array.")
    (params (a ArrayInt32) (v Int32))
    (returns Int32)
    (body
      (do
        (if-stmt (== a 0) (return (- 0 1)) (do 0))
        (let current-len Int32 (get-field a len))
        (let need Int32 (+ current-len 1))
        (if-stmt (!= (array-i32-grow a need) 0) (return (- 0 1)) (do 0))
        (let data (ptr Int32) (get-field a data))
        (let target (ptr Int32) (ptr-add Int32 data current-len))
        (store Int32 v target)
        (set-field a len need)
        (return 0)
      )
    )
    (tests
      (test array-i32-append-basic
        (doc "append ints then verify length and values")
        (tags unit arrays)
        (body
          (let arr ArrayInt32 (array-i32-new))
          (array-i32-append arr 1)
          (array-i32-append arr 2)
          (let len Int32 (array-i32-len arr))
          (expect-eq len 2)
          (let v0 Int32 (array-i32-get arr 0))
          (expect-eq v0 1)
          (let v1 Int32 (array-i32-get arr 1))
          (expect-eq v1 2)
        )
      )
    )
  )

  (fn array-i32-get
    (doc "Get the Int32 at idx.")
    (params (a ArrayInt32) (idx Int32))
    (returns Int32)
    (body
      (do
        (if-stmt (== a 0) (return 0) (do 0))
        (let len Int32 (get-field a len))
        (if-stmt (|| (< idx 0) (>= idx len)) (return 0) (do 0))
        (let data (ptr Int32) (get-field a data))
        (let ptr (ptr Int32) (ptr-add Int32 data idx))
        (return (load Int32 ptr))
      )
    )
    (tests
      (test array-i32-get-basic
        (doc "append then get should return same int")
        (tags unit arrays)
        (body
          (let arr ArrayInt32 (array-i32-new))
          (array-i32-append arr 42)
          (let v Int32 (array-i32-get arr 0))
          (expect-eq v 42)
        )
      )
    )
  )

  (fn array-i32-set
    (doc "Set the Int32 at idx to v.")
    (params (a ArrayInt32) (idx Int32) (v Int32))
    (returns Int32)
    (body
      (do
        (if-stmt (== a 0) (return (- 0 1)) (do 0))
        (let len Int32 (get-field a len))
        (if-stmt (|| (< idx 0) (>= idx len)) (return (- 0 1)) (do 0))
        (let data (ptr Int32) (get-field a data))
        (let ptr (ptr Int32) (ptr-add Int32 data idx))
        (store Int32 v ptr)
        (return 0)
      )
    )
    (tests
      (test array-i32-set-and-get
        (doc "set and get should roundtrip")
        (tags unit arrays)
        (body
          (let arr ArrayInt32 (array-i32-new))
          (array-i32-append arr 0)
          (array-i32-set arr 0 42)
          (let result Int32 (array-i32-get arr 0))
          (expect-eq result 42)
        )
      )
    )
  )
)
