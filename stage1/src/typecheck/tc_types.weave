;; Type validation utilities for type checking

  (fn is-builtin
    (doc "Return 1 if name is an external/builtin function tolerated by typecheck.")
    (params (name String))
    (returns Int32)
    (body
      (if-stmt (string-eq name "get-cli-string") (return 1) (do 0))
      (if-stmt (string-eq name "read-file") (return 1) (do 0))
      (if-stmt (string-eq name "write-file") (return 1) (do 0))
      (if-stmt (string-eq name "malloc") (return 1) (do 0))
      (if-stmt (string-eq name "free") (return 1) (do 0))
      (if-stmt (string-eq name "memcpy") (return 1) (do 0))
      (if-stmt (string-eq name "exit") (return 1) (do 0))
      (return 0)
    )
    (tests
      (test is-builtin-basic
        (doc "identifies known builtins and rejects unknown")
        (tags unit typecheck)
        (body
          (expect-eq (is-builtin "malloc") 1)
          (expect-eq (is-builtin "exit") 1)
          (expect-eq (is-builtin "not-a-builtin") 0)
        )
      )
    )
  )

  (fn child-count
    (doc "Count children after head in a list node.")
    (params (a (ptr Arena)) (node Int32))
    (returns Int32)
    (body
      (let cnt Int32 0)
      (let cur Int32 (arena-next-sibling a (arena-first-child a node)))
      (while (!= cur (- 0 1))
        (do
          (set cnt (+ cnt 1))
          (set cur (arena-next-sibling a cur))
        )
      )
      (return cnt)
    )
    (tests
      (test child-count-simple
        (doc "counts siblings after the head correctly")
        (tags unit typecheck)
        (body
          (let a (ptr Arena) (arena-new))
          (let list Int32 (arena-add-node a (node-kind-list) ""))
          (let head Int32 (arena-add-node a (node-kind-atom) "params"))
          (let p1 Int32 (arena-add-node a (node-kind-atom) "x"))
          (let p2 Int32 (arena-add-node a (node-kind-atom) "y"))
          (arena-set-first-child a list head)
          (arena-set-next-sibling a head p1)
          (arena-set-next-sibling a p1 p2)
          (expect-eq (child-count a list) 2)
        )
      )
    )
  )

  (fn is-valid-type-node
    (doc "Check if a type AST node is valid: Int32, String, Void, (ptr T), (struct Name).")
    (params (a (ptr Arena)) (node Int32))
    (returns Int32)
    (body
      (do
        (let result Int32 0)
        (if-stmt (== (arena-kind a node) (node-kind-atom))
          (do
            (let name String (arena-value a node))
            ;; Recognize built-in atom types
            (if-stmt (string-eq name "Int32") (set result 1) (do 0))
            (if-stmt (string-eq name "Int8") (set result 1) (do 0))
            (if-stmt (string-eq name "String") (set result 1) (do 0))
            (if-stmt (string-eq name "Void") (set result 1) (do 0))
            ;; Allow any non-empty identifier as a potential user type
            (if-stmt (> (string-length name) 0)
              (set result 1)
              (do 0)
            )
          )
          (do
            ;; List type: (ptr T) or (struct Name)
            (let head Int32 (arena-first-child a node))
            (if-stmt (== head (- 0 1))
              (set result 0)
              (do
                (let head-val String (arena-value a head))
                (if-stmt (string-eq head-val "ptr")
                  (do
                    (let inner Int32 (arena-next-sibling a head))
                    (if-stmt (== inner (- 0 1))
                      (set result 0)
                      (set result (is-valid-type-node a inner))
                    )
                  )
                  (do 0)
                )
                (if-stmt (string-eq head-val "struct")
                  (do
                    (let name-node Int32 (arena-next-sibling a head))
                    (if-stmt (== name-node (- 0 1))
                      (set result 0)
                      (do
                        (if-stmt (== (arena-kind a name-node) (node-kind-atom))
                          (set result 1)
                          (set result 0)
                        )
                      )
                    )
                  )
                  (do 0)
                )
              )
            )
          )
        )
        (return result)
      )
    )
    (tests
      (test valid-type-node-cases
        (doc "accepts basic atoms and ptr/struct forms")
        (tags unit typecheck)
        (body
          (let a (ptr Arena) (arena-new))
          (let int32 Int32 (arena-add-node a (node-kind-atom) "Int32"))
          (expect-eq (is-valid-type-node a int32) 1)
          (let list Int32 (arena-add-node a (node-kind-list) ""))
          (let head Int32 (arena-add-node a (node-kind-atom) "ptr"))
          (let inner Int32 (arena-add-node a (node-kind-atom) "Int32"))
          (arena-set-first-child a list head)
          (arena-set-next-sibling a head inner)
          (expect-eq (is-valid-type-node a list) 1)
          (let sList Int32 (arena-add-node a (node-kind-list) ""))
          (let sHead Int32 (arena-add-node a (node-kind-atom) "struct"))
          (let sName Int32 (arena-add-node a (node-kind-atom) "Foo"))
          (arena-set-first-child a sList sHead)
          (arena-set-next-sibling a sHead sName)
          (expect-eq (is-valid-type-node a sList) 1)
        )
      )
    )
  )

  (fn is-valid-type
    (doc "Accept basic types: Int32, String, Void (kept for compatibility).")
    (params (ty String))
    (returns Int32)
    (body
      (if-stmt
        (||
          (string-eq ty "Int32")
          (||
            (string-eq ty "Int8")
            (||
              (string-eq ty "String")
              (string-eq ty "Void")
            )
          )
        )
        (return 1)
        (do 0)
      )
      ;; Allow any other identifier as potentially valid
      (if-stmt (> (string-length ty) 0)
        (return 1)
        (return 0)
      )
    )
    (tests
      (test is-valid-type-basic
        (doc "accepts known types and identifiers, rejects empty")
        (tags unit typecheck)
        (body
          (expect-eq (is-valid-type "Int32") 1)
          (expect-eq (is-valid-type "MyType") 1)
          (expect-eq (is-valid-type "") 0)
        )
      )
    )
  )
