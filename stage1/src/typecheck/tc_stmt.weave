;; Statement type checking

  (fn tc-stmt
    (doc "Check a statement list; returns 0 or 1 on error.")
    (params
      (a (ptr Arena))
      (node Int32)
      (names ArrayString)
      (param-counts ArrayInt32)
      (struct-names ArrayString)
      (struct-fields ArrayString)
      (ret-type String)
    )
    (returns Int32)
    (body
      (if-stmt (!= (arena-kind a node) (node-kind-list))
        (return 0)
        (do
          (let head Int32 (arena-first-child a node))
          (if-stmt (== head (- 0 1)) (return 0) (do 0))
          (let head-val String (arena-value a head))
          (if-stmt (string-eq head-val "doc") (return 0) (do 0))

          (if-stmt (string-eq head-val "body")
            (do
              (let stmt Int32 (second-child a node))
              (while (!= stmt (- 0 1))
                (do
                  (let rc Int32 (tc-stmt a stmt names param-counts struct-names struct-fields ret-type))
                  (if-stmt (!= rc 0) (return rc) (do 0))
                  (set stmt (arena-next-sibling a stmt))
                )
              )
              (return 0)
            )
            (do 0)
          )

          (if-stmt (string-eq head-val "return")
            (do
              (if-stmt (string-starts-with ret-type "Void")
                (do
                  (let expr Int32 (second-child a node))
                  (if-stmt (!= expr (- 0 1)) (return (tc-error "Return value in void function")) (return 0))
                )
                (do
                  (let expr Int32 (second-child a node))
                  (if-stmt (== expr (- 0 1))
                    (return (tc-error "Non-void return missing value"))
                    (return (tc-expr a expr names param-counts struct-names struct-fields))
                  )
                )
              )
            )
            (do 0)
          )

          (if-stmt (string-eq head-val "let")
            (do
              (let init Int32 (fourth-child a node))
              (if-stmt (!= init (- 0 1))
                (return (tc-expr a init names param-counts struct-names struct-fields))
                (return 0)
              )
            )
            (do 0)
          )

          (if-stmt (string-eq head-val "set")
            (do
              (let expr Int32 (third-child a node))
              (if-stmt (!= expr (- 0 1))
                (return (tc-expr a expr names param-counts struct-names struct-fields))
                (return 0)
              )
            )
            (do 0)
          )

          (if-stmt (string-eq head-val "do")
            (do
              (let stmt Int32 (second-child a node))
              (while (!= stmt (- 0 1))
                (do
                  (let rc Int32 (tc-stmt a stmt names param-counts struct-names struct-fields ret-type))
                  (if-stmt (!= rc 0) (return rc) (do 0))
                  (set stmt (arena-next-sibling a stmt))
                )
              )
              (return 0)
            )
            (do 0)
          )

          ;; (block stmt... expr) - sequence with implicit return
          (if-stmt (string-eq head-val "block")
            (do
              (let stmt Int32 (second-child a node))
              (while (!= stmt (- 0 1))
                (do
                  (let rc Int32 (tc-stmt a stmt names param-counts struct-names struct-fields ret-type))
                  (if-stmt (!= rc 0) (return rc) (do 0))
                  (set stmt (arena-next-sibling a stmt))
                )
              )
              (return 0)
            )
            (do 0)
          )

          (if-stmt (string-eq head-val "if-stmt")
            (do
              (let cond Int32 (second-child a node))
              (let then Int32 (third-child a node))
              (let els Int32 (fourth-child a node))
              (let rc Int32 (tc-expr a cond names param-counts struct-names struct-fields))
              (if-stmt (!= rc 0) (return rc) (do 0))
              (let rc2 Int32 (tc-stmt a then names param-counts struct-names struct-fields ret-type))
              (if-stmt (!= rc2 0) (return rc2) (do 0))
              (let rc3 Int32 (tc-stmt a els names param-counts struct-names struct-fields ret-type))
              (return rc3)
            )
            (do 0)
          )

          (if-stmt (string-eq head-val "while")
            (do
              (let cond Int32 (second-child a node))
              (let body Int32 (third-child a node))
              (let rc Int32 (tc-expr a cond names param-counts struct-names struct-fields))
              (if-stmt (!= rc 0) (return rc) (do 0))
              (return (tc-stmt a body names param-counts struct-names struct-fields ret-type))
            )
            (do 0)
          )

          (return (tc-expr a node names param-counts struct-names struct-fields))
        )
      )
    )
    (tests
      (test tc-stmt-return-void-error
        (doc "returning a value in void function errors")
        (tags unit typecheck)
        (body
          (let a Arena (arena-new))
          (let ret Int32 (arena-add-node (addr a) (node-kind-list) ""))
          (let head Int32 (arena-add-node (addr a) (node-kind-atom) "return"))
          (let val Int32 (arena-add-node (addr a) (node-kind-atom) "x"))
          (arena-set-first-child (addr a) ret head)
          (arena-set-next-sibling (addr a) head val)
          (let names ArrayString (array-str-new))
          (let pcs ArrayInt32 (array-i32-new))
          (let sn ArrayString (array-str-new))
          (let sf ArrayString (array-str-new))
          (let rc Int32 (tc-stmt (addr a) ret names pcs sn sf "Void"))
          (expect-eq (> rc 0) 1)
        )
      )
      (test tc-stmt-return-nonvoid-missing
        (doc "non-void return missing value errors")
        (tags unit typecheck)
        (body
          (let a Arena (arena-new))
          (let ret Int32 (arena-add-node (addr a) (node-kind-list) ""))
          (let head Int32 (arena-add-node (addr a) (node-kind-atom) "return"))
          (arena-set-first-child (addr a) ret head)
          (let names ArrayString (array-str-new))
          (let pcs ArrayInt32 (array-i32-new))
          (let sn ArrayString (array-str-new))
          (let sf ArrayString (array-str-new))
          (let rc Int32 (tc-stmt (addr a) ret names pcs sn sf "Int32"))
          (expect-eq (> rc 0) 1)
        )
      )
      (test tc-stmt-body-do-ok
        (doc "body with nested do passes")
        (tags unit typecheck)
        (body
          (let a Arena (arena-new))
          (let body Int32 (arena-add-node (addr a) (node-kind-list) ""))
          (let head Int32 (arena-add-node (addr a) (node-kind-atom) "body"))
          (let do1 Int32 (arena-add-node (addr a) (node-kind-list) ""))
          (let doHead Int32 (arena-add-node (addr a) (node-kind-atom) "do"))
          (arena-set-first-child (addr a) body head)
          (arena-set-next-sibling (addr a) head do1)
          (arena-set-first-child (addr a) do1 doHead)
          (let names ArrayString (array-str-new))
          (let pcs ArrayInt32 (array-i32-new))
          (let sn ArrayString (array-str-new))
          (let sf ArrayString (array-str-new))
          (expect-eq (tc-stmt (addr a) body names pcs sn sf "Void") 0)
        )
      )
    )
  )

  (fn is-implicit-return-expr
    (doc "Return 1 if node is an expression that can be implicit return.")
    (params (a (ptr Arena)) (node Int32))
    (returns Int32)
    (body
      (if-stmt (== (arena-kind a node) (node-kind-atom))
        (return 1)
        (do
          (let head Int32 (arena-first-child a node))
          (if-stmt (== head (- 0 1)) (return 0) (do 0))
          (let head-val String (arena-value a head))
          ;; These are statements that don't produce values
          ;; 5-child let (let name type init body) IS an expression - recurse into body
          (if-stmt (string-eq head-val "let")
            (do
              (let n-children Int32 (count-children a node))
              (if-stmt (== n-children 5)
                (do
                  ;; 5-child let: check if body (5th child) is implicit return
                  (let body Int32 (fifth-child a node))
                  (return (is-implicit-return-expr a body))
                )
                ;; 4-child let without body is a statement, not expr
                (return 0)
              )
            )
            (do 0)
          )
          (if-stmt (string-eq head-val "set") (return 0) (do 0))
          (if-stmt (string-eq head-val "while") (return 0) (do 0))
          (if-stmt (string-eq head-val "do") (return 0) (do 0))
          ;; if-stmt CAN be an expression if both branches return values
          ;; Everything else (make, function calls, if-stmt, etc.) is an expression
          (return 1)
        )
      )
    )
    (tests
      (test implicit-return-cases
        (doc "atom is expr; set/while/do are not; let(5) recurses")
        (tags unit typecheck)
        (body
          (let a Arena (arena-new))
          (let atom Int32 (arena-add-node (addr a) (node-kind-atom) "x"))
          (expect-eq (is-implicit-return-expr (addr a) atom) 1)
          (let setn Int32 (arena-add-node (addr a) (node-kind-list) ""))
          (let seth Int32 (arena-add-node (addr a) (node-kind-atom) "set"))
          (arena-set-first-child (addr a) setn seth)
          (expect-eq (is-implicit-return-expr (addr a) setn) 0)
          (let letn Int32 (arena-add-node (addr a) (node-kind-list) ""))
          (let leth Int32 (arena-add-node (addr a) (node-kind-atom) "let"))
          (let name Int32 (arena-add-node (addr a) (node-kind-atom) "n"))
          (let ty Int32 (arena-add-node (addr a) (node-kind-atom) "Int32"))
          (let init Int32 (arena-add-node (addr a) (node-kind-atom) "1"))
          (let body Int32 (arena-add-node (addr a) (node-kind-atom) "y"))
          (arena-set-first-child (addr a) letn leth)
          (arena-set-next-sibling (addr a) leth name)
          (arena-set-next-sibling (addr a) name ty)
          (arena-set-next-sibling (addr a) ty init)
          (arena-set-next-sibling (addr a) init body)
          (expect-eq (is-implicit-return-expr (addr a) letn) 1)
        )
      )
    )
  )

  (fn has-return
    (doc "Return 1 if any return exists under node.")
    (params (a (ptr Arena)) (node Int32))
    (returns Int32)
    (body
      (if-stmt (== (arena-kind a node) (node-kind-atom))
        (return 0)
        (do
          (let head Int32 (arena-first-child a node))
          (if-stmt (== head (- 0 1)) (return 0) (do 0))
          (let head-val String (arena-value a head))
          (if-stmt (string-eq head-val "return") (return 1) (do 0))
          (if-stmt (string-eq head-val "doc")
            (return 0)
            (do 0)
          )
          ;; For body forms, check if last statement is an implicit return expr
          (if-stmt (string-eq head-val "body")
            (do
              (let last-child Int32 (- 0 1))
              (let child Int32 (arena-next-sibling a head))
              (while (!= child (- 0 1))
                (do
                  (set last-child child)
                  (set child (arena-next-sibling a child))
                )
              )
              (if-stmt (!= last-child (- 0 1))
                (if-stmt (== (is-implicit-return-expr a last-child) 1)
                  (return 1)
                  (do 0)
                )
                (do 0)
              )
            )
            (do 0)
          )
          ;; Recurse into children
          (let child2 Int32 (arena-first-child a node))
          (while (!= child2 (- 0 1))
            (do
              (if-stmt (== (has-return a child2) 1) (return 1) (do 0))
              (set child2 (arena-next-sibling a child2))
            )
          )
          (return 0)
        )
      )
    )
    (tests
      (test has-return-detect
        (doc "detects direct return and implicit body return")
        (tags unit typecheck)
        (body
          (let a Arena (arena-new))
          ;; Direct return
          (let ret Int32 (arena-add-node (addr a) (node-kind-list) ""))
          (let rhead Int32 (arena-add-node (addr a) (node-kind-atom) "return"))
          (arena-set-first-child (addr a) ret rhead)
          (expect-eq (has-return (addr a) ret) 1)
          ;; Body with last child an expr
          (let body Int32 (arena-add-node (addr a) (node-kind-list) ""))
          (let bhead Int32 (arena-add-node (addr a) (node-kind-atom) "body"))
          (let expr Int32 (arena-add-node (addr a) (node-kind-atom) "x"))
          (arena-set-first-child (addr a) body bhead)
          (arena-set-next-sibling (addr a) bhead expr)
          (expect-eq (has-return (addr a) body) 1)
        )
      )
    )
  )
