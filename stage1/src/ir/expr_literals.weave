;; Literal and variable compilation helpers

  (fn get-struct-name-from-type-node
    (doc "Extract struct name from a type node (atom 'Arena' or list '(struct Arena)').")
    (params (a (ptr Arena)) (ty-node Int32))
    (returns String)
    (body
      (if-stmt (== (arena-kind a ty-node) (node-kind-atom))
        (return (arena-value a ty-node))
        (do
          (let head Int32 (arena-first-child a ty-node))
          (if-stmt (== head (- 0 1)) (return "") (do 0))
          (let head-val String (arena-value a head))
          (if-stmt (string-eq head-val "struct")
            (do
              (let name-node Int32 (arena-next-sibling a head))
              (if-stmt (== name-node (- 0 1)) (return "") (do 0))
              (return (arena-value a name-node))
            )
            (return "")
          )
        )
      )
    )
    (tests
      (test get-struct-name-from-type-node-atom
        (doc "should extract name from atom type node")
        (tags unit ir literals)
        (body
          (let a (ptr Arena) (arena-new))
          (let node Int32 (arena-add-node a (node-kind-atom) "Arena"))
          (let name String (get-struct-name-from-type-node a node))
          (let eq Int32 (string-eq name "Arena"))
          (expect-eq eq 1)
        )
      )
      (test get-struct-name-from-type-node-struct-list
        (doc "should extract name from (struct Name) list")
        (tags unit ir literals)
        (body
          (let a (ptr Arena) (arena-new))
          (let list Int32 (arena-add-node a (node-kind-list) ""))
          (let head Int32 (arena-add-node a (node-kind-atom) "struct"))
          (let name-node Int32 (arena-add-node a (node-kind-atom) "Buffer"))
          (arena-set-first-child a list head)
          (arena-set-next-sibling a head name-node)
          (let name String (get-struct-name-from-type-node a list))
          (let eq Int32 (string-eq name "Buffer"))
          (expect-eq eq 1)
        )
      )
    )
  )

  (fn compile-int-lit
    (doc "Emit an add that materializes the integer literal into temp.")
    (params
      (out Buffer)
      (value String)
      (temp Int32)
    )
    (returns Int32)
    (body
      (do
        (buffer-append-string out "  ")
        (emit-temp out temp)
        (buffer-append-string out " = add i32 0, ")
        (buffer-append-string out value)
        (buffer-append-string out "\n")
        (return temp)
      )
    )
    (tests
      (test compile-int-lit-positive
        (doc "should emit add instruction for positive integer")
        (tags unit ir literals)
        (body
          (let b Buffer (buffer-new))
          (let result Int32 (compile-int-lit b "42" 10))
          (let s String (buffer-to-string b))
          (expect-true (> (string-length s) 10))
        )
      )
      (test compile-int-lit-zero
        (doc "should emit add instruction for zero")
        (tags unit ir literals)
        (body
          (let b Buffer (buffer-new))
          (let result Int32 (compile-int-lit b "0" 5))
          (expect-eq result 5)
        )
      )
    )
  )

  (fn compile-var
    (doc "Load a variable of type ty-node into temp (assumes an alloca exists).")
    (params
      (a (ptr Arena))
      (out Buffer)
      (name String)
      (ty-node Int32)
      (struct-names ArrayString)
      (temp Int32)
    )
    (returns Int32)
    (body
      (do
        (let nm String name)
        (if-stmt (== (string-length nm) 0)
          (set nm "tmp")
          (set nm nm)
        )
        (buffer-append-string out "  ")
        (emit-temp out temp)
        (buffer-append-string out " = load ")
        (emit-type-node out a ty-node struct-names)
        (buffer-append-string out ", ")
        (emit-pointer-type-node out a ty-node struct-names)
        (buffer-append-string out " %")
        (buffer-append-string out nm)
        (buffer-append-string out "\n")
        (return temp)
      )
    )
    (tests
      (test compile-var-named
        (doc "should emit load instruction for named variable")
        (tags unit ir literals)
        (body
          (let a (ptr Arena) (arena-new))
          (let ty Int32 (arena-add-node a (node-kind-atom) "Int32"))
          (let b Buffer (buffer-new))
          (let result Int32 (compile-var a b "myvar" ty (array-str-new) 7))
          (let s String (buffer-to-string b))
          (expect-true (> (string-length s) 10))
        )
      )
      (test compile-var-empty-name
        (doc "should use tmp for empty variable name")
        (tags unit ir literals)
        (body
          (let a (ptr Arena) (arena-new))
          (let ty Int32 (arena-add-node a (node-kind-atom) "Int32"))
          (let b Buffer (buffer-new))
          (let result Int32 (compile-var a b "" ty (array-str-new) 8))
          (expect-eq result 8)
        )
      )
    )
  )
