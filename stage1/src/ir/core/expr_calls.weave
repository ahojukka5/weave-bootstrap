  (fn compile-function-call-expr
    (doc "Compile a function call: (fn-name arg1 arg2 ...) - general function call.")
    (tests
      (test compile-function-call-expr-basic
        (doc "Test that compile-function-call-expr exists")
        (tags unit)
        (body
          (expect-true 1)
        )
      )
    )
    (params
      (a (ptr Arena))
      (node Int32)
      (head-val String)
      (env-names ArrayString)
      (env-safe ArrayString)
      (env-types ArrayInt32)
      (declared ArrayString)
      (struct-names ArrayString)
      (struct-fields ArrayString)
      (decls Buffer)
      (str-counter (ptr Int32))
      (out Buffer)
      (temp (ptr Int32))
      (fn-sig-names ArrayString)
      (fn-sig-ret-types ArrayInt32)
    )
    (returns Int32)
    (body
      (let arg Int32 (arena-next-sibling a (arena-first-child a node)))
      (let arg-regs ArrayInt32 (array-i32-new))
      (let arg-types ArrayString (array-str-new))
      (let max-args Int32 (- 0 1))
      (if-stmt (string-eq head-val "buffer-append-string")
        (set max-args 2)
        (do 0)
      )
      (while (!= arg (- 0 1))
        (do
          (if-stmt (&& (!= max-args (- 0 1)) (>= (array-i32-len arg-regs) max-args))
            (set arg (- 0 1))
            (do
              (let arg-type String (infer-arg-type a arg env-names env-types fn-sig-names fn-sig-ret-types))
              (compile-expr a arg env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types)
              (array-i32-append arg-regs (- (load Int32 temp) 1))
              (array-str-append arg-types arg-type)
              (set arg (arena-next-sibling a arg))
            )
          )
        )
      )
      (let hv-len-fc Int32 (string-length head-val))
      (if-stmt (== hv-len-fc 7)
        (do
          (let c0-fc Int32 (string-char-at head-val 0))
          (let c1-fc Int32 (string-char-at head-val 1))
          (let c2-fc Int32 (string-char-at head-val 2))
          (let c3-fc Int32 (string-char-at head-val 3))
          (let c4-fc Int32 (string-char-at head-val 4))
          (let c5-fc Int32 (string-char-at head-val 5))
          (let c6-fc Int32 (string-char-at head-val 6))
          ;; Check for "ptr-add": p=112, t=116, r=114, -=45, a=97, d=100, d=100
          (if-stmt (&& (== c0-fc 112) (&& (== c1-fc 116) (&& (== c2-fc 114) (&& (== c3-fc 45) (&& (== c4-fc 97) (&& (== c5-fc 100) (== c6-fc 100)))))))
            (do
              (compile-expr a (third-child a node) env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types)
              (let ptr-reg Int32 (- (load Int32 temp) 1))
              (compile-expr a (fourth-child a node) env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types)
              (let idx-reg Int32 (- (load Int32 temp) 1))
              (return (compile-ptr-add-node a (second-child a node) ptr-reg idx-reg struct-names out temp))
            )
            (do 0)
          )
        )
        (do 0)
      )
      (let ret-type String (lookup-fn-ret-type a head-val fn-sig-names fn-sig-ret-types))
      (let result-reg Int32 (load Int32 temp))
      (buffer-append-string out "  ")
      (emit-temp out result-reg)
      (buffer-append-string out " = call ")
      (buffer-append-string out ret-type)
      (buffer-append-string out " @")
      (buffer-append-string out head-val)
      (buffer-append-string out "(")
      (let i Int32 0)
      (let argc Int32 (array-i32-len arg-regs))
      (while (< i argc)
        (do
          (if-stmt (> i 0)
            (buffer-append-string out ", ")
            (do 0)
          )
          (buffer-append-string out (array-str-get arg-types i))
          (buffer-append-string out " ")
          (emit-temp out (array-i32-get arg-regs i))
          (set i (+ i 1))
        )
      )
      (buffer-append-string out ")\n")
      (store Int32 temp (+ result-reg 1))
      (return result-reg)
    )
  )

  (fn compile-general-call
    (params
      (a (ptr Arena))
      (node Int32)
      (fn-name String)
      (env-names ArrayString)
      (env-safe ArrayString)
      (env-types ArrayInt32)
      (declared ArrayString)
      (struct-names ArrayString)
      (struct-fields ArrayString)
      (decls Buffer)
      (str-counter (ptr Int32))
      (out Buffer)
      (temp (ptr Int32))
      (fn-sig-names ArrayString)
      (fn-sig-ret-types ArrayInt32)
    )
    (returns Int32)
    (body
      (let arg-node Int32 (second-child a node))
      (let arg-regs ArrayInt32 (array-i32-new))
      (let arg-types ArrayString (array-str-new))
      (while (!= arg-node (- 0 1))
        (do
          (compile-expr a arg-node env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types)
          (let reg Int32 (- (load Int32 temp) 1))
          (array-i32-append arg-regs reg)
          (let aty String (infer-arg-type a arg-node env-names env-types fn-sig-names fn-sig-ret-types))
          (array-str-append arg-types aty)
          (set arg-node (arena-next-sibling a arg-node))
        )
      )
      (let ret-ty-str String (lookup-fn-ret-type a fn-name fn-sig-names fn-sig-ret-types))
      (let t Int32 (load Int32 temp))
      (if-stmt (string-eq ret-ty-str "void")
        (do
          (buffer-append-string out "  call void @")
          (buffer-append-string out fn-name)
          (buffer-append-string out "(")
        )
        (do
          (buffer-append-string out "  ")
          (emit-temp out t)
          (buffer-append-string out " = call ")
          (buffer-append-string out ret-ty-str)
          (buffer-append-string out " @")
          (buffer-append-string out fn-name)
          (buffer-append-string out "(")
        )
      )
      (let i Int32 0)
      (while (< i (array-i32-len arg-regs))
        (do
          (if-stmt (> i 0)
            (buffer-append-string out ", ")
            (do 0)
          )
          (buffer-append-string out (array-str-get arg-types i))
          (buffer-append-string out " ")
          (emit-temp out (array-i32-get arg-regs i))
          (set i (+ i 1))
        )
      )
      (buffer-append-string out ")\n")
      (if-stmt (string-eq ret-ty-str "void")
        (do (store Int32 temp (+ t 0)) (return t))
        (do (store Int32 temp (+ t 1)) (return t))
      )
    )
    (tests
      (test compile-general-call-min
        (tags unit)
        (body (let ok Int32 1) (expect-eq ok 1))
      )
    )
  )
