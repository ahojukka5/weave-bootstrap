;;; @weave-allow-long-file: compile-expr is a large recursive dispatcher handling all expression forms (atoms, control flow, memory ops, binary ops, function calls, null pointer handling). Splitting would require complex mutual recursion between files or force artificial extraction that harms readability. The function naturally grows with language features.
  (fn compile-expr
    (doc "Dispatch expression kinds and update temp counter; returns last temp.")
    (params
      (a (ptr Arena))
      (node Int32)
      (env-names ArrayString)
      (env-safe ArrayString)
      (env-types ArrayInt32)
      (declared ArrayString)
      (struct-names ArrayString)
      (struct-fields ArrayString)
      (decls Buffer)
      (str-counter (ptr Int32))
      (out Buffer)
      (temp (ptr Int32))
      (fn-sig-names ArrayString)
      (fn-sig-ret-types ArrayInt32)
    ) ;; params
    (returns Int32)
    (body
      (if-stmt (== (arena-kind a node) (node-kind-atom))
        (do
          (let v String
            (arena-value a node)
            (do
              (if-stmt (== (is-string-literal v) 1)
                (do
                  (let raw String (string-literal-value v))
                  (let idx Int32 (load Int32 str-counter))
                  (store Int32 str-counter (+ idx 1))
                  
                  (let byte-count Int32 0)
                  (let escaped String (escape-llvm-string raw (addr byte-count)))
                  (let total-len Int32 (+ byte-count 1)) ;; +1 for null terminator

                  (let gname Buffer (buffer-new))
                  (buffer-append-string gname "@.str")
                  (buffer-append-string gname (int-to-string idx))

                  (let gbuf Buffer (buffer-new))
                  (buffer-append-string gbuf (buffer-to-string gname))
                  (buffer-append-string gbuf " = private unnamed_addr constant [")
                  (buffer-append-string gbuf (int-to-string total-len))
                  (buffer-append-string gbuf " x i8] c\"")
                  (buffer-append-string gbuf escaped)
                  (buffer-append-string gbuf "\\00\"\n")

                  (if-stmt (== (array-str-contains declared (buffer-to-string gname)) 0)
                    (do
                      (array-str-append declared (buffer-to-string gname))
                      (buffer-append-string decls (buffer-to-string gbuf))
                    )
                    (do 0)
                  ) ;; if-stmt

                  (let t Int32 (load Int32 temp))
                  (buffer-append-string out "  ")
                  (emit-temp out t)
                  (buffer-append-string out " = getelementptr inbounds [")
                  (buffer-append-string out (int-to-string total-len))
                  (buffer-append-string out " x i8], [")
                  (buffer-append-string out (int-to-string total-len))
                  (buffer-append-string out " x i8]* ")
                  (buffer-append-string out (buffer-to-string gname))
                  (buffer-append-string out ", i32 0, i32 0\n")
                  (store Int32 temp (+ t 1))
                  (return t)
                )
                (do 0)
              ) ;; if-stmt

              (if-stmt (== (is-number-string v) 1)
                (do
                  (let t Int32 (compile-int-lit out v (load Int32 temp)))
                  (store Int32 temp (+ t 1))
                  (return t)
                )
                (do
                  (let ty-node Int32 (env-find-type env-names env-types v))
                  (let t Int32 (compile-var a out (env-find-safe env-names env-safe v) ty-node struct-names (load Int32 temp)))
                  (store Int32 temp (+ t 1))
                  (return t)
                ) ;; do
              ) ;; if-stmt
            ) ;; do
          ) ;; let v
        ) ;; do
        (do
          (let head Int32 (arena-first-child a node))
          (if-stmt (== head (- 0 1))
            (return 0)
            (do 0)
          )
          (let head-val String (arena-value a head))
          ;; ptr-add will be handled in function call handler via lookup-fn-ret-type
          (if-stmt (string-eq head-val "doc")
            (return (load Int32 temp))
            (do 0)
          )

          (if-stmt (string-eq head-val "do")
            (return (compile-do-expr a node env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types))
            (do 0)
          ) ;; if-stmt

          (if-stmt (string-eq head-val "let")
            (return (compile-let-expr a node env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types))
            (do 0)
          ) ;; if-stmt

          (if-stmt (string-eq head-val "set")
            (return (compile-set-expr a node env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types))
            (do 0)
          ) ;; if-stmt

          (if-stmt (string-eq head-val "return")
            (return (compile-return-expr a node env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types))
            (do 0)
          ) ;; if-stmt

          (if-stmt (string-eq head-val "if-stmt")
            (return (compile-if-expr a node env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types))
            (do 0)
          ) ;; if-stmt

          (if-stmt (string-eq head-val "while")
            (return (compile-while-expr a node env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types))
            (do 0)
          ) ;; if-stmt

          (if-stmt (string-eq head-val "addr")
            (return (compile-addr node a env-names env-safe env-types struct-names out temp))
            (do 0)
          ) ;; if-stmt
          (if-stmt (string-eq head-val "load")
            (do
              (let ty-node Int32 (second-child a node))
              (let ptr-node Int32 (third-child a node))
              (compile-expr a ptr-node env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types)
              (let ptr-reg Int32 (- (load Int32 temp) 1))
              (let reg Int32 (compile-load-node a ty-node ptr-reg struct-names out temp))
              (return reg)
            )
            (do 0)
          ) ;; if-stmt

          (if-stmt (string-eq head-val "store")
            (do
              (let ty-node Int32 (second-child a node))
              (let n3 Int32 (third-child a node))
              (let n4 Int32 (fourth-child a node))
              (let ptr-node Int32 n3)
              (let val-node Int32 n4)
              (if-stmt (== (is-pointer-expr a n3 env-names env-types) 1)
                (do
                  (set ptr-node n3)
                  (set val-node n4)
                )
                (do
                  (set ptr-node n4)
                  (set val-node n3)
                )
              )
              (compile-expr a val-node env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types)
              (let val-reg Int32 (- (load Int32 temp) 1))
              (compile-expr a ptr-node env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types)
              (let ptr-reg Int32 (- (load Int32 temp) 1))
              (compile-store-node a ty-node val-reg ptr-reg struct-names out)
              (return val-reg)
            )
            (do 0)
          ) ;; if-stmt

          (if-stmt (string-eq head-val "bitcast")
            (do
              (let ty-node Int32 (second-child a node))
              (let src-node Int32 (third-child a node))
              (compile-expr a src-node env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types)
              (let src-reg Int32 (- (load Int32 temp) 1))
              (let reg Int32 (compile-bitcast-node a ty-node src-reg struct-names out temp))
              (return reg)
            )
            (do 0)
          ) ;; if-stmt

          ;; Check for ptr-add BEFORE get-field
          (if-stmt (string-eq head-val "ptr-add")
            (do
              (let ty-node Int32 (second-child a node))
              (let ptr-node Int32 (third-child a node))
              (let idx-node Int32 (fourth-child a node))
              (if-stmt (&& (!= ty-node (- 0 1)) (&& (!= ptr-node (- 0 1)) (!= idx-node (- 0 1))))
                (do
                  (compile-expr a ptr-node env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types)
                  (let ptr-reg Int32 (- (load Int32 temp) 1))
                  (compile-expr a idx-node env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types)
                  (let idx-reg Int32 (- (load Int32 temp) 1))
                  (return (compile-ptr-add-node a ty-node ptr-reg idx-reg struct-names out temp))
                )
                (return 0)
              )
            )
            (do 0)
          )
          (if-stmt (string-eq head-val "get-field")
            (do
              ;; New form: (get-field base-ptr field-name) -> compile base, infer struct from result type, emit GEP then load
              ;; This matches stage0's approach: compile base first, get type from result
              (let base-node Int32 (second-child a node))
              (let fname-node Int32 (third-child a node))
              (let fname String (arena-value a fname-node))
              ;; Compile base expression first (like stage0)
              (compile-expr a base-node env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types)
              (let ptr-reg Int32 (- (load Int32 temp) 1))
              ;; Infer struct type from the base expression's type (not from AST)
              ;; Use infer-arg-type to get the type of the compiled expression
              (let base-type-str String (infer-arg-type a base-node env-names env-types fn-sig-names fn-sig-ret-types))
              ;; base-type-str should be something like "%Arena*" for a pointer to struct
              ;; Extract struct name: remove trailing "*" if present
              (let struct-name String "")
              (let base-len Int32 (string-length base-type-str))
              (if-stmt (> base-len 0)
                (do
                  (let last-char Int32 (string-char-at base-type-str (- base-len 1)))
                  (if-stmt (== last-char 42) ;; '*'
                    (do
                      ;; Remove trailing "*" to get struct type
                      (set struct-name (string-slice base-type-str 0 (- base-len 1)))
                      ;; Remove leading "%" if present
                      (if-stmt (&& (> (string-length struct-name) 0) (== (string-char-at struct-name 0) 37)) ;; '%'
                        (set struct-name (string-slice struct-name 1 (- (string-length struct-name) 1)))
                        (do 0)
                      )
                    )
                    (do 0)
                  )
                )
                (do 0)
              )
              ;; Fallback: try to infer from AST if type inference failed
              (if-stmt (== (string-length struct-name) 0)
                (do
                  (if-stmt (== (arena-kind a base-node) (node-kind-atom))
                    (do
                      (let base-name String (arena-value a base-node))
                      (let ty-node Int32 (env-find-type env-names env-types base-name))
                      (if-stmt (!= ty-node (- 0 1))
                        (do
                          (if-stmt (== (arena-kind a ty-node) (node-kind-list))
                            (do
                              (let h Int32 (arena-first-child a ty-node))
                              (if-stmt (string-eq (arena-value a h) "ptr")
                                (do
                                  (let inner Int32 (arena-next-sibling a h))
                                  (set struct-name (get-struct-name-from-type-node a inner))
                                )
                                (do 0)
                              )
                            )
                            (do 0)
                          )
                        )
                        (do 0)
                      )
                    )
                    (do 0)
                  )
                )
                (do 0)
              )
              (let fi Int32 (struct-field-index struct-names struct-fields struct-name fname))
              (if-stmt (< fi 0) (set fi 0) (do 0))
              (let pfield Int32 (load Int32 temp))
              (buffer-append-string out "  ")
              (emit-temp out pfield)
              (buffer-append-string out " = getelementptr inbounds %")
              (buffer-append-string out (sanitize-name struct-name))
              (buffer-append-string out ", %")
              (buffer-append-string out (sanitize-name struct-name))
              (buffer-append-string out "* ")
              (emit-temp out ptr-reg)
              (buffer-append-string out ", i32 0, i32 ")
              (buffer-append-string out (int-to-string fi))
              (buffer-append-string out "\n")
              (store Int32 temp (+ pfield 1))
              (let fty String (struct-field-type struct-names struct-fields struct-name fi))
              (if-stmt (== (string-length fty) 0) (set fty "Int32") (do 0))
              (let loadt Int32 (load Int32 temp))
              (buffer-append-string out "  ")
              (emit-temp out loadt)
              (buffer-append-string out " = load ")
              (let fty-llvm String (map-simple-type-name fty))
              (buffer-append-string out fty-llvm)
              (buffer-append-string out ", ")
              (buffer-append-string out fty-llvm)
              (buffer-append-string out "* ")
              (emit-temp out pfield)
              (buffer-append-string out "\n")
              (store Int32 temp (+ loadt 1))
              ;; If pointer type, convert 0 to null using select (proper fix)
              (if-stmt (string-ends-with fty-llvm "*")
                (do
                  (let t1 Int32 (load Int32 temp))
                  (buffer-append-string out "  %t")
                  (buffer-append-string out (int-to-string t1))
                  (buffer-append-string out " = ptrtoint ")
                  (buffer-append-string out fty-llvm)
                  (buffer-append-string out " %t")
                  (buffer-append-string out (int-to-string loadt))
                  (buffer-append-string out " to i32\n")
                  (let t2 Int32 (+ t1 1))
                  (buffer-append-string out "  %t")
                  (buffer-append-string out (int-to-string t2))
                  (buffer-append-string out " = icmp eq i32 %t")
                  (buffer-append-string out (int-to-string t1))
                  (buffer-append-string out ", 0\n")
                  (let t3 Int32 (+ t2 1))
                  (buffer-append-string out "  %t")
                  (buffer-append-string out (int-to-string t3))
                  (buffer-append-string out " = select i1 %t")
                  (buffer-append-string out (int-to-string t2))
                  (buffer-append-string out ", ")
                  (buffer-append-string out fty-llvm)
                  (buffer-append-string out " null, ")
                  (buffer-append-string out fty-llvm)
                  (buffer-append-string out " %t")
                  (buffer-append-string out (int-to-string loadt))
                  (buffer-append-string out "\n")
                  (store Int32 temp (+ t3 1))
                  (return t3)
                )
                (return loadt)
              )
            )
            (do 0)
          ) ;; if-stmt

          (if-stmt (string-eq head-val "set-field")
            (do
              ;; New form only: (set-field base-ptr field-name value)
              (let base-node Int32 (second-child a node))
              (let fname-node Int32 (third-child a node))
              (let val-node Int32 (fourth-child a node))
              (let fname String (arena-value a fname-node))
              (compile-expr a base-node env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types)
              (let ptr-reg Int32 (- (load Int32 temp) 1))
              (let struct-name String "")
              (if-stmt (== (arena-kind a base-node) (node-kind-atom))
                (do
                  (let base-name String (arena-value a base-node))
                  (let ty-node Int32 (env-find-type env-names env-types base-name))
                  (if-stmt (!= ty-node (- 0 1))
                    (do
                      (if-stmt (== (arena-kind a ty-node) (node-kind-list))
                        (do
                          (let h Int32 (arena-first-child a ty-node))
                          (if-stmt (string-eq (arena-value a h) "ptr")
                            (do
                              (let inner Int32 (arena-next-sibling a h))
                              (set struct-name (get-struct-name-from-type-node a inner))
                            )
                            (do 0)
                          )
                        )
                        (do 0)
                      )
                    )
                    (do 0)
                  )
                )
                (do 0)
              )
              (let fi Int32 (struct-field-index struct-names struct-fields struct-name fname))
              (if-stmt (< fi 0) (set fi 0) (do 0))
              (let fty String (struct-field-type struct-names struct-fields struct-name fi))
              (if-stmt (== (string-length fty) 0) (set fty "Int32") (do 0))
              (let pfield Int32 (load Int32 temp))
              (buffer-append-string out "  ")
              (emit-temp out pfield)
              (buffer-append-string out " = getelementptr inbounds %")
              (buffer-append-string out (sanitize-name struct-name))
              (buffer-append-string out ", %")
              (buffer-append-string out (sanitize-name struct-name))
              (buffer-append-string out "* ")
              (emit-temp out ptr-reg)
              (buffer-append-string out ", i32 0, i32 ")
              (buffer-append-string out (int-to-string fi))
              (buffer-append-string out "\n")
              (store Int32 temp (+ pfield 1))
              (compile-expr a val-node env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types)
              (let val-reg Int32 (- (load Int32 temp) 1))
              (buffer-append-string out "  store ")
              (buffer-append-string out (map-simple-type-name fty))
              (buffer-append-string out " ")
              (emit-temp out val-reg)
              (buffer-append-string out ", ")
              (buffer-append-string out (map-simple-type-name fty))
              (buffer-append-string out "* ")
              (emit-temp out pfield)
              (buffer-append-string out "\n")
              (return val-reg)
            )
            (do 0)
          ) ;; if-stmt

          (if-stmt (string-eq head-val "make")
            (do
              (let ty-node Int32 (second-child a node))
              (let struct-name String (get-struct-name-from-type-node a ty-node))
              (let base Int32 (load Int32 temp))
              (buffer-append-string out "  ")
              (emit-temp out base)
              (buffer-append-string out " = alloca %")
              (buffer-append-string out (sanitize-name struct-name))
              (buffer-append-string out "\n")
              (store Int32 temp (+ base 1))
              (let result Int32 base)
              (let field Int32 (third-child a node))
              (let fidx Int32 0)
              (while (!= field (- 0 1))
                (do
                  (compile-expr a field env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types)
                  (let val-reg Int32 (- (load Int32 temp) 1))
                  (let ptr Int32 (compile-get-field-node a ty-node result (int-to-string fidx) struct-names struct-fields out temp))
                  (let fty String (struct-field-type struct-names struct-fields struct-name fidx))
                  (if-stmt (== (string-length fty) 0)
                    (set fty "Int32")
                    (set fty fty)
                  )
                  (buffer-append-string out "  store ")
                  (buffer-append-string out (map-simple-type-name fty))
                  (buffer-append-string out " ")
                  (emit-temp out val-reg)
                  (buffer-append-string out ", ")
                  (buffer-append-string out (map-simple-type-name fty))
                  (buffer-append-string out "* ")
                  (emit-temp out ptr)
                  (buffer-append-string out "\n")
                  (set fidx (+ fidx 1))
                  (set field (arena-next-sibling a field))
                ) ;; do
              ) ;; while
              (return result)
            )
            (do 0)
          ) ;; if-stmt
          (if-stmt (== (compile-binary-ops head-val) 1)
            (return (compile-binary-op-expr a node head-val env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types))
            (do
              (if-stmt (string-eq head-val "ccall")
                (return (compile-ccall node a env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types))
                (do
                  (if-stmt (string-eq head-val "block")
                    (do
                      (let child Int32 (arena-next-sibling a head))
                      (let last-reg Int32 0)
                      (while (!= child (- 0 1))
                        (do
                          (if-stmt (== (arena-kind a child) (node-kind-list))
                            (do
                              (let ch Int32 (arena-first-child a child))
                              (if-stmt (!= ch (- 0 1))
                                (do
                                  (let chv String (arena-value a ch))
                                  (if-stmt (string-eq chv "let")
                                    (do
                                      (let let-name-node Int32 (second-child a child))
                                      (let let-type-node Int32 (third-child a child))
                                      (let let-init-node Int32 (fourth-child a child))
                                      (let let-name String (arena-value a let-name-node))
                                      (let let-safe String (sanitize-name let-name))
                                      (compile-expr a let-init-node env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types)
                                      (let init-reg Int32 (- (load Int32 temp) 1))
                                      (env-add env-names env-safe env-types let-name let-safe let-type-node)
                                      (buffer-append-string out "  %")
                                      (buffer-append-string out let-safe)
                                      (buffer-append-string out " = alloca ")
                                      (emit-type-node out a let-type-node struct-names)
                                      (buffer-append-string out "\n")
                                      (buffer-append-string out "  store ")
                                      (emit-type-node out a let-type-node struct-names)
                                      (buffer-append-string out " ")
                                      (emit-temp out init-reg)
                                      (buffer-append-string out ", ")
                                      (emit-pointer-type-node out a let-type-node struct-names)
                                      (buffer-append-string out " %")
                                      (buffer-append-string out let-safe)
                                      (buffer-append-string out "\n")
                                      (let let-body-node Int32 (fifth-child a child))
                                      (if-stmt (!= let-body-node (- 0 1))
                                        (set last-reg (compile-expr a let-body-node env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types))
                                        (set last-reg init-reg)
                                      )
                                    )
                                    (if-stmt (string-eq chv "do")
                                      (do
                                        (let do-child Int32 (arena-next-sibling a ch))
                                        (while (!= do-child (- 0 1))
                                          (do
                                            (set last-reg (compile-expr a do-child env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types))
                                            (set do-child (arena-next-sibling a do-child))
                                          )
                                        )
                                      )
                                      (if-stmt (string-eq chv "set")
                                        (do
                                          (let set-name-node Int32 (second-child a child))
                                          (let set-expr-node Int32 (third-child a child))
                                          (let set-name String (arena-value a set-name-node))
                                          (let set-safe String (env-find-safe env-names env-safe set-name))
                                          (let set-ty-node Int32 (env-find-type env-names env-types set-name))
                                          (compile-expr a set-expr-node env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types)
                                          (let val-reg Int32 (- (load Int32 temp) 1))
                                          (buffer-append-string out "  store ")
                                          (emit-type-node out a set-ty-node struct-names)
                                          (buffer-append-string out " ")
                                          (emit-temp out val-reg)
                                          (buffer-append-string out ", ")
                                          (emit-pointer-type-node out a set-ty-node struct-names)
                                          (buffer-append-string out " %")
                                          (buffer-append-string out set-safe)
                                          (buffer-append-string out "\n")
                                          (set last-reg val-reg)
                                        )
                                        (if-stmt (string-eq chv "if-stmt")
                                          (do
                                            (let if-cond Int32 (second-child a child))
                                            (let if-then Int32 (third-child a child))
                                            (let if-else Int32 (fourth-child a child))
                                            (compile-expr a if-cond env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types)
                                            (let cond-t Int32 (- (load Int32 temp) 1))
                                            (let cond-i1 Int32 (load Int32 temp))
                                            (buffer-append-string out "  ")
                                            (emit-temp out cond-i1)
                                            (buffer-append-string out " = icmp ne i32 ")
                                            (emit-temp out cond-t)
                                            (buffer-append-string out ", 0\n")
                                            (store Int32 temp (+ cond-i1 1))
                                            (let l-then Int32 (load Int32 temp))
                                            (store Int32 temp (+ l-then 1))
                                            (let l-else Int32 (load Int32 temp))
                                            (store Int32 temp (+ l-else 1))
                                            (let l-end Int32 (load Int32 temp))
                                            (store Int32 temp (+ l-end 1))
                                            (buffer-append-string out "  br i1 ")
                                            (emit-temp out cond-i1)
                                            (buffer-append-string out ", label %L")
                                            (buffer-append-string out (int-to-string l-then))
                                            (buffer-append-string out ", label %L")
                                            (buffer-append-string out (int-to-string l-else))
                                            (buffer-append-string out "\n")
                                            (buffer-append-string out "L")
                                            (buffer-append-string out (int-to-string l-then))
                                            (buffer-append-string out ":\n")
                                            (let then-node Int32 if-then)
                                            (if-stmt (== (arena-kind a if-then) (node-kind-list)) (do (let th Int32 (arena-first-child a if-then)) (if-stmt (!= th (- 0 1)) (do (let tv String (arena-value a th)) (if-stmt (string-eq tv "return") (set then-node (second-child a if-then)) (do 0))) (do 0))) (do 0))
                                            (set last-reg (compile-expr a then-node env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types))
                                            (buffer-append-string out "  br label %L")
                                            (buffer-append-string out (int-to-string l-end))
                                            (buffer-append-string out "\n")
                                            (buffer-append-string out "L")
                                            (buffer-append-string out (int-to-string l-else))
                                            (buffer-append-string out ":\n")
                                            (if-stmt (!= if-else (- 0 1))
                                              (do (let else-node Int32 if-else) (if-stmt (== (arena-kind a if-else) (node-kind-list)) (do (let el Int32 (arena-first-child a if-else)) (if-stmt (!= el (- 0 1)) (do (let ev String (arena-value a el)) (if-stmt (string-eq ev "return") (set else-node (second-child a if-else)) (do 0))) (do 0))) (do 0)) (set last-reg (compile-expr a else-node env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types)))
                                              (do 0)
                                            )
                                            (buffer-append-string out "  br label %L")
                                            (buffer-append-string out (int-to-string l-end))
                                            (buffer-append-string out "\n")
                                            (buffer-append-string out "L")
                                            (buffer-append-string out (int-to-string l-end))
                                            (buffer-append-string out ":\n")
                                          )
                                          (if-stmt (string-eq chv "while")
                                            (do
                                              (let while-cond Int32 (second-child a child))
                                              (let while-body Int32 (third-child a child))
                                              (let l-cond Int32 (load Int32 temp))
                                              (store Int32 temp (+ l-cond 1))
                                              (let l-body Int32 (load Int32 temp))
                                              (store Int32 temp (+ l-body 1))
                                              (let l-end Int32 (load Int32 temp))
                                              (store Int32 temp (+ l-end 1))
                                              (buffer-append-string out "  br label %L")
                                              (buffer-append-string out (int-to-string l-cond))
                                              (buffer-append-string out "\n")
                                              (buffer-append-string out "L")
                                              (buffer-append-string out (int-to-string l-cond))
                                              (buffer-append-string out ":\n")
                                              (compile-expr a while-cond env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types)
                                              (let cond-t Int32 (- (load Int32 temp) 1))
                                              (let cond-i1 Int32 (load Int32 temp))
                                              (buffer-append-string out "  ")
                                              (emit-temp out cond-i1)
                                              (buffer-append-string out " = icmp ne i32 ")
                                              (emit-temp out cond-t)
                                              (buffer-append-string out ", 0\n")
                                              (store Int32 temp (+ cond-i1 1))
                                              (buffer-append-string out "  br i1 ")
                                              (emit-temp out cond-i1)
                                              (buffer-append-string out ", label %L")
                                              (buffer-append-string out (int-to-string l-body))
                                              (buffer-append-string out ", label %L")
                                              (buffer-append-string out (int-to-string l-end))
                                              (buffer-append-string out "\n")
                                              (buffer-append-string out "L")
                                              (buffer-append-string out (int-to-string l-body))
                                              (buffer-append-string out ":\n")
                                              (set last-reg (compile-expr a while-body env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types))
                                              (buffer-append-string out "  br label %L")
                                              (buffer-append-string out (int-to-string l-cond))
                                              (buffer-append-string out "\n")
                                              (buffer-append-string out "L")
                                              (buffer-append-string out (int-to-string l-end))
                                              (buffer-append-string out ":\n")
                                            )
                                            (set last-reg (compile-expr a child env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types))
                                          )
                                        )
                                      )
                                    )
                                  )
                                )
                                (set last-reg (compile-expr a child env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types))
                              )
                            )
                            (set last-reg (compile-expr a child env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types))
                          )
                          (set child (arena-next-sibling a child))
                        )
                      )
                      (return last-reg)
                    )
                    (do 0)
                  )
                  (return (compile-function-call-expr a node head-val env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types))
                ) ;; do
              ) ;; if-stmt
            ) ;; do
          ) ;; if-stmt
        ) ;; do
      ) ;; if-stmt
    ) ;; body
    (tests
      (test compile-expr-min
        (tags unit)
        (body (let ok Int32 1) (expect-eq ok 1))
      )
    )
  ) ;; fn compile-expr
