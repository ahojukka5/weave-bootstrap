;;; @weave-allow-long-file: compile-expr is a large recursive dispatcher handling all expression forms (atoms, control flow, memory ops, binary ops, function calls). Splitting would require complex mutual recursion between files or force artificial extraction that harms readability. The function naturally grows with language features.

  (fn compile-expr
    (doc "Dispatch expression kinds and update temp counter; returns last temp.")
    (params
      (a (ptr Arena))
      (node Int32)
      (env-names ArrayString)
      (env-safe ArrayString)
      (env-types ArrayInt32)
      (declared ArrayString)
      (struct-names ArrayString)
      (struct-fields ArrayString)
      (decls Buffer)
      (str-counter (ptr Int32))
      (out Buffer)
      (temp (ptr Int32))
      (fn-sig-names ArrayString)
      (fn-sig-ret-types ArrayInt32)
    ) ;; params
    (returns Int32)
    (body
      (if-stmt (== (arena-kind a node) (node-kind-atom))
        (do
          (let v String
            (arena-value a node)
            (do
              (if-stmt (== (is-string-literal v) 1)
                (do
                  (let raw String (string-literal-value v))
                  (let idx Int32 (load Int32 str-counter))
                  (store Int32 str-counter (+ idx 1))
                  
                  (let byte-count Int32 0)
                  (let escaped String (escape-llvm-string raw (addr byte-count)))
                  (let total-len Int32 (+ byte-count 1)) ;; +1 for null terminator

                  (let gname Buffer (buffer-new))
                  (buffer-append-string gname "@.str")
                  (buffer-append-string gname (int-to-string idx))

                  (let gbuf Buffer (buffer-new))
                  (buffer-append-string gbuf (buffer-to-string gname))
                  (buffer-append-string gbuf " = private unnamed_addr constant [")
                  (buffer-append-string gbuf (int-to-string total-len))
                  (buffer-append-string gbuf " x i8] c\"")
                  (buffer-append-string gbuf escaped)
                  (buffer-append-string gbuf "\\00\"\n")

                  (if-stmt (== (array-str-contains declared (buffer-to-string gname)) 0)
                    (do
                      (array-str-append declared (buffer-to-string gname))
                      (buffer-append-string decls (buffer-to-string gbuf))
                    )
                    (do 0)
                  ) ;; if-stmt

                  (let t Int32 (load Int32 temp))
                  (buffer-append-string out "  ")
                  (emit-temp out t)
                  (buffer-append-string out " = getelementptr inbounds [")
                  (buffer-append-string out (int-to-string total-len))
                  (buffer-append-string out " x i8], [")
                  (buffer-append-string out (int-to-string total-len))
                  (buffer-append-string out " x i8]* ")
                  (buffer-append-string out (buffer-to-string gname))
                  (buffer-append-string out ", i32 0, i32 0\n")
                  (store Int32 temp (+ t 1))
                  (return t)
                )
                (do 0)
              ) ;; if-stmt

              (if-stmt (== (is-number-string v) 1)
                (do
                  (let t Int32 (compile-int-lit out v (load Int32 temp)))
                  (store Int32 temp (+ t 1))
                  (return t)
                )
                (do
                  (let ty-node Int32 (env-find-type env-names env-types v))
                  (let t Int32 (compile-var a out (env-find-safe env-names env-safe v) ty-node (load Int32 temp)))
                  (store Int32 temp (+ t 1))
                  (return t)
                ) ;; do
              ) ;; if-stmt
            ) ;; do
          ) ;; let v
        ) ;; do
        (do
          (let head Int32 (arena-first-child a node))
          (let head-val String (arena-value a head))
          (if-stmt (string-eq head-val "doc")
            (return (load Int32 temp))
            (do 0)
          ) ;; if-stmt

          (if-stmt (string-eq head-val "do")
            (do
              (let do-child Int32 (arena-next-sibling a head))
              (let do-last-reg Int32 0)
              (while (!= do-child (- 0 1))
                (do
                  (set do-last-reg (compile-expr a do-child env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types))
                  (set do-child (arena-next-sibling a do-child))
                )
              )
              (return do-last-reg)
            )
            (do 0)
          ) ;; if-stmt

          (if-stmt (string-eq head-val "let")
            (do
              (let let-name-node Int32 (second-child a node))
              (let let-type-node Int32 (third-child a node))
              (let let-init-node Int32 (fourth-child a node))
              (let let-name String (arena-value a let-name-node))
              (let let-safe String (sanitize-name let-name))
              (let init-reg Int32 (compile-expr a let-init-node env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types))
              (env-add env-names env-safe env-types let-name let-safe let-type-node)
              (let actual-safe String (env-find-safe env-names env-safe let-name))
              (buffer-append-string out "  %")
              (buffer-append-string out actual-safe)
              (buffer-append-string out " = alloca ")
              (emit-type-node out a let-type-node)
              (buffer-append-string out "\n")
              (buffer-append-string out "  store ")
              (emit-type-node out a let-type-node)
              (buffer-append-string out " ")
              (emit-temp out init-reg)
              (buffer-append-string out ", ")
              (emit-pointer-type-node out a let-type-node)
              (buffer-append-string out " %")
              (buffer-append-string out actual-safe)
              (buffer-append-string out "\n")
              (let let-body-node Int32 (fifth-child a node))
              (if-stmt (!= let-body-node (- 0 1))
                (return (compile-expr a let-body-node env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types))
                (return init-reg)
              )
            )
            (do 0)
          ) ;; if-stmt

          (if-stmt (string-eq head-val "set")
            (do
              (let set-name-node Int32 (second-child a node))
              (let set-expr-node Int32 (third-child a node))
              (let set-name String (arena-value a set-name-node))
              (let set-safe String (env-find-safe env-names env-safe set-name))
              (let set-ty-node Int32 (env-find-type env-names env-types set-name))
              (compile-expr a set-expr-node env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types)
              (let val-reg Int32 (- (load Int32 temp) 1))
              (buffer-append-string out "  store ")
              (emit-type-node out a set-ty-node)
              (buffer-append-string out " ")
              (emit-temp out val-reg)
              (buffer-append-string out ", ")
              (emit-pointer-type-node out a set-ty-node)
              (buffer-append-string out " %")
              (buffer-append-string out set-safe)
              (buffer-append-string out "\n")
              (return val-reg)
            )
            (do 0)
          ) ;; if-stmt

          (if-stmt (string-eq head-val "return")
            (do
              (let ret-node Int32 (second-child a node))
              (return (compile-expr a ret-node env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types))
            )
            (do 0)
          ) ;; if-stmt

          (if-stmt (string-eq head-val "if-stmt")
            (do
              (let if-cond Int32 (second-child a node))
              (let if-then Int32 (third-child a node))
              (let if-else Int32 (fourth-child a node))
              (let cond-reg Int32 (compile-expr a if-cond env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types))
              (let cond-i1 Int32 (load Int32 temp))
              (buffer-append-string out "  ")
              (emit-temp out cond-i1)
              (buffer-append-string out " = icmp ne i32 ")
              (emit-temp out cond-reg)
              (buffer-append-string out ", 0\n")
              (store Int32 temp (+ cond-i1 1))
              (let l-then Int32 (load Int32 temp))
              (store Int32 temp (+ l-then 1))
              (let l-else Int32 (load Int32 temp))
              (store Int32 temp (+ l-else 1))
              (let l-end Int32 (load Int32 temp))
              (store Int32 temp (+ l-end 1))
              (buffer-append-string out "  br i1 ")
              (emit-temp out cond-i1)
              (buffer-append-string out ", label %L")
              (buffer-append-string out (int-to-string l-then))
              (buffer-append-string out ", label %L")
              (buffer-append-string out (int-to-string l-else))
              (buffer-append-string out "\n")
              (buffer-append-string out "L")
              (buffer-append-string out (int-to-string l-then))
              (buffer-append-string out ":\n")
              (let then-node Int32 if-then)
              (if-stmt (== (arena-kind a if-then) (node-kind-list)) (do (let th Int32 (arena-first-child a if-then)) (if-stmt (!= th (- 0 1)) (do (let tv String (arena-value a th)) (if-stmt (string-eq tv "return") (set then-node (second-child a if-then)) (do 0))) (do 0))) (do 0))
              (let then-reg Int32 (compile-expr a then-node env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types))
              (buffer-append-string out "  br label %L")
              (buffer-append-string out (int-to-string l-end))
              (buffer-append-string out "\n")
              (buffer-append-string out "L")
              (buffer-append-string out (int-to-string l-else))
              (buffer-append-string out ":\n")
              (let else-reg Int32 0)
              (if-stmt (!= if-else (- 0 1))
                (do (let else-node Int32 if-else) (if-stmt (== (arena-kind a if-else) (node-kind-list)) (do (let el Int32 (arena-first-child a if-else)) (if-stmt (!= el (- 0 1)) (do (let ev String (arena-value a el)) (if-stmt (string-eq ev "return") (set else-node (second-child a if-else)) (do 0))) (do 0))) (do 0)) (set else-reg (compile-expr a else-node env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types)))
                (do
                  (let default-t Int32 (load Int32 temp))
                  (buffer-append-string out "  ")
                  (emit-temp out default-t)
                  (buffer-append-string out " = ")
                  (if-stmt (is-pointer-expr a if-then env-names env-types)
                    (buffer-append-string out "bitcast i8* null to i8*")
                    (buffer-append-string out "add i32 0, 0")
                  )
                  (buffer-append-string out "\n")
                  (set else-reg default-t)
                  (store Int32 temp (+ default-t 1))
                )
              )
              (buffer-append-string out "  br label %L")
              (buffer-append-string out (int-to-string l-end))
              (buffer-append-string out "\n")
              (buffer-append-string out "L")
              (buffer-append-string out (int-to-string l-end))
              (buffer-append-string out ":\n")
              (let phi Int32 (load Int32 temp))
              (buffer-append-string out "  ")
              (emit-temp out phi)
              (buffer-append-string out " = phi ")
              (if-stmt (is-pointer-expr a if-then env-names env-types)
                (buffer-append-string out "i8*")
                (buffer-append-string out "i32")
              )
              (buffer-append-string out " [ ")
              (emit-temp out then-reg)
              (buffer-append-string out ", %L")
              (buffer-append-string out (int-to-string l-then))
              (buffer-append-string out " ], [ ")
              (emit-temp out else-reg)
              (buffer-append-string out ", %L")
              (buffer-append-string out (int-to-string l-else))
              (buffer-append-string out " ]\n")
              (store Int32 temp (+ phi 1))
              (return phi)
            )
            (do 0)
          ) ;; if-stmt

          (if-stmt (string-eq head-val "while")
            (do
              (let while-cond Int32 (second-child a node))
              (let while-body Int32 (third-child a node))
              (let l-cond Int32 (load Int32 temp))
              (store Int32 temp (+ l-cond 1))
              (let l-body Int32 (load Int32 temp))
              (store Int32 temp (+ l-body 1))
              (let l-end Int32 (load Int32 temp))
              (store Int32 temp (+ l-end 1))
              (buffer-append-string out "  br label %L")
              (buffer-append-string out (int-to-string l-cond))
              (buffer-append-string out "\n")
              (buffer-append-string out "L")
              (buffer-append-string out (int-to-string l-cond))
              (buffer-append-string out ":\n")
              (compile-expr a while-cond env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types)
              (let cond-t Int32 (- (load Int32 temp) 1))
              (let cond-i1 Int32 (load Int32 temp))
              (buffer-append-string out "  ")
              (emit-temp out cond-i1)
              (buffer-append-string out " = icmp ne i32 ")
              (emit-temp out cond-t)
              (buffer-append-string out ", 0\n")
              (store Int32 temp (+ cond-i1 1))
              (buffer-append-string out "  br i1 ")
              (emit-temp out cond-i1)
              (buffer-append-string out ", label %L")
              (buffer-append-string out (int-to-string l-body))
              (buffer-append-string out ", label %L")
              (buffer-append-string out (int-to-string l-end))
              (buffer-append-string out "\n")
              (buffer-append-string out "L")
              (buffer-append-string out (int-to-string l-body))
              (buffer-append-string out ":\n")
              (compile-expr a while-body env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types)
              (buffer-append-string out "  br label %L")
              (buffer-append-string out (int-to-string l-cond))
              (buffer-append-string out "\n")
              (buffer-append-string out "L")
              (buffer-append-string out (int-to-string l-end))
              (buffer-append-string out ":\n")
              (return 0)
            )
            (do 0)
          ) ;; if-stmt

          (if-stmt (string-eq head-val "addr")
            (return (compile-addr node a env-names env-safe env-types out temp))
            (do 0)
          ) ;; if-stmt
          (if-stmt (string-eq head-val "load")
            (do
              (let ty-node Int32 (second-child a node))
              (let ptr-node Int32 (third-child a node))
              (compile-expr a ptr-node env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types)
              (let ptr-reg Int32 (- (load Int32 temp) 1))
              (let reg Int32 (compile-load-node a ty-node ptr-reg out temp))
              (return reg)
            )
            (do 0)
          ) ;; if-stmt

          (if-stmt (string-eq head-val "store")
            (do
              (let ty-node Int32 (second-child a node))
              (let n3 Int32 (third-child a node))
              (let n4 Int32 (fourth-child a node))
              (let ptr-node Int32 n3)
              (let val-node Int32 n4)
              (if-stmt (== (is-pointer-expr a n3 env-names env-types) 1)
                (do
                  (set ptr-node n3)
                  (set val-node n4)
                )
                (do
                  (set ptr-node n4)
                  (set val-node n3)
                )
              )
              (compile-expr a val-node env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types)
              (let val-reg Int32 (- (load Int32 temp) 1))
              (compile-expr a ptr-node env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types)
              (let ptr-reg Int32 (- (load Int32 temp) 1))
              (compile-store-node a ty-node val-reg ptr-reg out)
              (return val-reg)
            )
            (do 0)
          ) ;; if-stmt

          (if-stmt (string-eq head-val "bitcast")
            (do
              (let ty-node Int32 (second-child a node))
              (let src-node Int32 (third-child a node))
              (compile-expr a src-node env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types)
              (let src-reg Int32 (- (load Int32 temp) 1))
              (let reg Int32 (compile-bitcast-node a ty-node src-reg out temp))
              (return reg)
            )
            (do 0)
          ) ;; if-stmt

          (if-stmt (string-eq head-val "get-field")
            (do
              (let argc Int32 (child-count a node))
              (if-stmt (== argc 3)
                (do
                  (let elem-ty-node Int32 (second-child a node))
                  (let idx-node Int32 (third-child a node))
                  (let ptr-node Int32 (fourth-child a node))
                  (let idx_str String (arena-value a idx-node))
                  (compile-expr a ptr-node env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types)
                  (let ptr-reg Int32 (- (load Int32 temp) 1))
                  (let field-ptr Int32 (compile-get-field-node a elem-ty-node idx_str ptr-reg struct-names struct-fields out temp))
                  (return field-ptr)
                )
                (do
                  (let base-node Int32 (second-child a node))
                  (let fname-node Int32 (third-child a node))
                  (let fname String (arena-value a fname-node))
                  (compile-expr a base-node env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types)
                  (let ptr-reg Int32 (- (load Int32 temp) 1))
                  (let struct-name String "")
                  (if-stmt (== (arena-kind a base-node) (node-kind-atom))
                    (do
                      (let base-name String (arena-value a base-node))
                      (let ty-node Int32 (env-find-type env-names env-types base-name))
                      (if-stmt (!= ty-node (- 0 1))
                        (do
                          (if-stmt (== (arena-kind a ty-node) (node-kind-list))
                            (do
                              (let h Int32 (arena-first-child a ty-node))
                              (if-stmt (string-eq (arena-value a h) "ptr")
                                (do
                                  (let inner Int32 (arena-next-sibling a h))
                                  (set struct-name (get-struct-name-from-type-node a inner))
                                )
                                (do 0)
                              )
                            )
                            (do 0)
                          )
                        )
                        (do 0)
                      )
                    )
                    (do 0)
                  )
                  (let fi Int32 (struct-field-index struct-names struct-fields struct-name fname))
                  (if-stmt (< fi 0) (set fi 0) (do 0))
                  (let pfield Int32 (load Int32 temp))
                  (buffer-append-string out "  ")
                  (emit-temp out pfield)
                  (buffer-append-string out " = getelementptr inbounds %")
                  (buffer-append-string out (sanitize-name struct-name))
                  (buffer-append-string out ", %")
                  (buffer-append-string out (sanitize-name struct-name))
                  (buffer-append-string out "* ")
                  (emit-temp out ptr-reg)
                  (buffer-append-string out ", i32 0, i32 ")
                  (buffer-append-string out (int-to-string fi))
                  (buffer-append-string out "\n")
                  (store Int32 temp (+ pfield 1))
                  (let fty String (struct-field-type struct-names struct-fields struct-name fi))
                  (if-stmt (== (string-length fty) 0) (set fty "Int32") (do 0))
                  (let loadt Int32 (load Int32 temp))
                  (buffer-append-string out "  ")
                  (emit-temp out loadt)
                  (buffer-append-string out " = load ")
                  (buffer-append-string out (map-simple-type-name fty))
                  (buffer-append-string out ", ")
                  (buffer-append-string out (map-simple-type-name fty))
                  (buffer-append-string out "* ")
                  (emit-temp out pfield)
                  (buffer-append-string out "\n")
                  (store Int32 temp (+ loadt 1))
                  (return loadt)
                )
              )
            )
            (do 0)
          ) ;; if-stmt

          (if-stmt (string-eq head-val "set-field")
            (do
              (let argc Int32 (child-count a node))
              (if-stmt (== argc 4)
                (do
                  (let elem-ty-node Int32 (second-child a node))
                  (let idx-node Int32 (third-child a node))
                  (let ptr-node Int32 (fourth-child a node))
                  (let val-node Int32 (arena-next-sibling a ptr-node))
                  (let struct-name String (get-struct-name-from-type-node a elem-ty-node))
                  (let idx_str String (arena-value a idx-node))
                  (compile-expr a ptr-node env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types)
                  (let ptr-reg Int32 (- (load Int32 temp) 1))
                  (compile-expr a val-node env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types)
                  (let val-reg Int32 (- (load Int32 temp) 1))
                  (let field-ty String (struct-field-type struct-names struct-fields struct-name (string-to-int idx_str)))
                  (if-stmt (== (string-length field-ty) 0)
                    (set field-ty "Int32")
                    (do 0)
                  )
                  (let field-ptr Int32 (compile-get-field-node a elem-ty-node idx_str ptr-reg struct-names struct-fields out temp))
                  (buffer-append-string out "  store ")
                  (buffer-append-string out (map-simple-type-name field-ty))
                  (buffer-append-string out " ")
                  (emit-temp out val-reg)
                  (buffer-append-string out ", ")
                  (buffer-append-string out (map-simple-type-name field-ty))
                  (buffer-append-string out "* ")
                  (emit-temp out field-ptr)
                  (buffer-append-string out "\n")
                  (return val-reg)
                )
                (do
                  (let base-node Int32 (second-child a node))
                  (let fname-node Int32 (third-child a node))
                  (let val-node Int32 (fourth-child a node))
                  (let fname String (arena-value a fname-node))
                  (compile-expr a base-node env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types)
                  (let ptr-reg Int32 (- (load Int32 temp) 1))
                  (let struct-name String "")
                  (if-stmt (== (arena-kind a base-node) (node-kind-atom))
                    (do
                      (let base-name String (arena-value a base-node))
                      (let ty-node Int32 (env-find-type env-names env-types base-name))
                      (if-stmt (!= ty-node (- 0 1))
                        (do
                          (if-stmt (== (arena-kind a ty-node) (node-kind-list))
                            (do
                              (let h Int32 (arena-first-child a ty-node))
                              (if-stmt (string-eq (arena-value a h) "ptr")
                                (do
                                  (let inner Int32 (arena-next-sibling a h))
                                  (set struct-name (get-struct-name-from-type-node a inner))
                                )
                                (do 0)
                              )
                            )
                            (do 0)
                          )
                        )
                        (do 0)
                      )
                    )
                    (do 0)
                  )
                  (let fi Int32 (struct-field-index struct-names struct-fields struct-name fname))
                  (if-stmt (< fi 0) (set fi 0) (do 0))
                  (let fty String (struct-field-type struct-names struct-fields struct-name fi))
                  (if-stmt (== (string-length fty) 0) (set fty "Int32") (do 0))
                  (let pfield Int32 (load Int32 temp))
                  (buffer-append-string out "  ")
                  (emit-temp out pfield)
                  (buffer-append-string out " = getelementptr inbounds %")
                  (buffer-append-string out (sanitize-name struct-name))
                  (buffer-append-string out ", %")
                  (buffer-append-string out (sanitize-name struct-name))
                  (buffer-append-string out "* ")
                  (emit-temp out ptr-reg)
                  (buffer-append-string out ", i32 0, i32 ")
                  (buffer-append-string out (int-to-string fi))
                  (buffer-append-string out "\n")
                  (store Int32 temp (+ pfield 1))
                  (compile-expr a val-node env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types)
                  (let val-reg Int32 (- (load Int32 temp) 1))
                  (buffer-append-string out "  store ")
                  (buffer-append-string out (map-simple-type-name fty))
                  (buffer-append-string out " ")
                  (emit-temp out val-reg)
                  (buffer-append-string out ", ")
                  (buffer-append-string out (map-simple-type-name fty))
                  (buffer-append-string out "* ")
                  (emit-temp out pfield)
                  (buffer-append-string out "\n")
                  (return val-reg)
                )
              )
            )
            (do 0)
          ) ;; if-stmt

          (if-stmt (string-eq head-val "ptr-add")
            (do
              (let ty-node Int32 (second-child a node))
              (let ptr-node Int32 (third-child a node))
              (let idx-node Int32 (fourth-child a node))
              (compile-expr a ptr-node env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types)
              (let ptr-reg Int32 (- (load Int32 temp) 1))
              (compile-expr a idx-node env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types)
              (let idx-reg Int32 (- (load Int32 temp) 1))
              (let reg Int32 (compile-ptr-add-node a ty-node ptr-reg idx-reg out temp))
              (return reg)
            )
            (do 0)
          ) ;; if-stmt

          (if-stmt (string-eq head-val "make")
            (do
              (let ty-node Int32 (second-child a node))
              (let struct-name String (get-struct-name-from-type-node a ty-node))
              (let base Int32 (load Int32 temp))
              (buffer-append-string out "  ")
              (emit-temp out base)
              (buffer-append-string out " = alloca %")
              (buffer-append-string out (sanitize-name struct-name))
              (buffer-append-string out "\n")
              (store Int32 temp (+ base 1))
              (let result Int32 base)
              (let field Int32 (third-child a node))
              (let fidx Int32 0)
              (while (!= field (- 0 1))
                (do
                  (compile-expr a field env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types)
                  (let val-reg Int32 (- (load Int32 temp) 1))
                  (let ptr Int32 (compile-get-field-node a ty-node (int-to-string fidx) result struct-names struct-fields out temp))
                  (let fty String (struct-field-type struct-names struct-fields struct-name fidx))
                  (if-stmt (== (string-length fty) 0)
                    (set fty "Int32")
                    (set fty fty)
                  )
                  (buffer-append-string out "  store ")
                  (buffer-append-string out (map-simple-type-name fty))
                  (buffer-append-string out " ")
                  (emit-temp out val-reg)
                  (buffer-append-string out ", ")
                  (buffer-append-string out (map-simple-type-name fty))
                  (buffer-append-string out "* ")
                  (emit-temp out ptr)
                  (buffer-append-string out "\n")
                  (set fidx (+ fidx 1))
                  (set field (arena-next-sibling a field))
                ) ;; do
              ) ;; while
              (return result)
            )
            (do 0)
          ) ;; if-stmt
          (if-stmt
            (||
              (string-eq head-val "+")
              (||
                (string-eq head-val "-")
                (||
                  (string-eq head-val "*")
                  (||
                    (string-eq head-val "/")
                    (||
                      (string-eq head-val "==")
                      (||
                        (string-eq head-val "!=")
                        (||
                          (string-eq head-val "<")
                          (||
                            (string-eq head-val ">")
                            (||
                              (string-eq head-val "<=")
                              (||
                                (string-eq head-val ">=")
                                (||
                                  (string-eq head-val "&&")
                                  (string-eq head-val "||")
                                ) ;; ||
                              ) ;; ||
                            ) ;; ||
                          ) ;; ||
                        ) ;; ||
                      ) ;; ||
                    ) ;; ||
                  ) ;; ||
                ) ;; ||
              ) ;; ||
            ) ;; ||
            (do
              (let lhs Int32 (second-child a node))
              (let rhs Int32 (third-child a node))
              (compile-expr a lhs env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types)
              (let lhs-t Int32 (- (load Int32 temp) 1))
              (compile-expr a rhs env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types)
              (let rhs-t Int32 (- (load Int32 temp) 1))
              (if-stmt
                (||
                  (string-eq head-val "==")
                  (||
                    (string-eq head-val "!=")
                    (||
                      (string-eq head-val "<")
                      (||
                        (string-eq head-val ">")
                        (||
                          (string-eq head-val "<=")
                          (||
                            (string-eq head-val ">=")
                            (||
                              (string-eq head-val "&&")
                              (string-eq head-val "||")
                            ) ;; ||
                          ) ;; ||
                        ) ;; ||
                      ) ;; ||
                    ) ;; ||
                  ) ;; ||
                ) ;; ||
                (do
                  (if-stmt
                    (||
                      (string-eq head-val "&&")
                      (string-eq head-val "||")
                    ) ;; ||
                    (do
                      (let reg Int32 (compile-logical head-val lhs-t rhs-t out temp))
                      (return reg)
                    ) ;; do
                    (do
                      (let pred String "eq")
                      (if-stmt (string-eq head-val "!=") (set pred "ne") (do 0))
                      (if-stmt (string-eq head-val "<") (set pred "slt") (do 0))
                      (if-stmt (string-eq head-val ">") (set pred "sgt") (do 0))
                      (if-stmt (string-eq head-val "<=") (set pred "sle") (do 0))
                      (if-stmt (string-eq head-val ">=") (set pred "sge") (do 0))
                      (if-stmt (&& (|| (string-eq head-val "==") (string-eq head-val "!=")) (|| (== (is-pointer-expr a lhs env-names env-types) 1) (== (is-pointer-expr a rhs env-names env-types) 1)))
                        (do
                          (let tcmp Int32 (load Int32 temp))
                          (let t Int32 (+ tcmp 1))
                          (buffer-append-string out "  ")
                          (emit-temp out tcmp)
                          (buffer-append-string out " = icmp ")
                          (buffer-append-string out pred)
                          (buffer-append-string out " i8* ")
                          (if-stmt (== (is-pointer-expr a lhs env-names env-types) 1)
                            (do (emit-temp out lhs-t))
                            (do (buffer-append-string out "null"))
                          )
                          (buffer-append-string out ", ")
                          (if-stmt (== (is-pointer-expr a rhs env-names env-types) 1)
                            (do (emit-temp out rhs-t))
                            (do (buffer-append-string out "null"))
                          )
                          (buffer-append-string out "\n")
                          (buffer-append-string out "  ")
                          (emit-temp out t)
                          (buffer-append-string out " = zext i1 ")
                          (emit-temp out tcmp)
                          (buffer-append-string out " to i32\n")
                          (store Int32 temp (+ t 1))
                          (return t)
                        )
                        (do
                          (let reg Int32 (compile-icmp pred lhs-t rhs-t out temp))
                          (return reg)
                        )
                      )
                    ) ;; do
                  ) ;; if-stmt
                )
                (do
                  (let reg Int32 (compile-binary-arith head-val lhs-t rhs-t out temp))
                  (return reg)
                ) ;; do
              ) ;; if-stmt
            ) ;; do
            (do
              (if-stmt (string-eq head-val "ccall")
                (return (compile-ccall node a env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types))
                (do
                  (if-stmt (string-eq head-val "block")
                    (do
                      (let child Int32 (arena-next-sibling a head))
                      (let last-reg Int32 0)
                      (while (!= child (- 0 1))
                        (do
                          (if-stmt (== (arena-kind a child) (node-kind-list))
                            (do
                              (let ch Int32 (arena-first-child a child))
                              (if-stmt (!= ch (- 0 1))
                                (do
                                  (let chv String (arena-value a ch))
                                  (if-stmt (string-eq chv "let")
                                    (do
                                      (let let-name-node Int32 (second-child a child))
                                      (let let-type-node Int32 (third-child a child))
                                      (let let-init-node Int32 (fourth-child a child))
                                      (let let-name String (arena-value a let-name-node))
                                      (let let-safe String (sanitize-name let-name))
                                      (compile-expr a let-init-node env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types)
                                      (let init-reg Int32 (- (load Int32 temp) 1))
                                      (env-add env-names env-safe env-types let-name let-safe let-type-node)
                                      (buffer-append-string out "  %")
                                      (buffer-append-string out let-safe)
                                      (buffer-append-string out " = alloca ")
                                      (emit-type-node out a let-type-node)
                                      (buffer-append-string out "\n")
                                      (buffer-append-string out "  store ")
                                      (emit-type-node out a let-type-node)
                                      (buffer-append-string out " ")
                                      (emit-temp out init-reg)
                                      (buffer-append-string out ", ")
                                      (emit-pointer-type-node out a let-type-node)
                                      (buffer-append-string out " %")
                                      (buffer-append-string out let-safe)
                                      (buffer-append-string out "\n")
                                      (let let-body-node Int32 (fifth-child a child))
                                      (if-stmt (!= let-body-node (- 0 1))
                                        (set last-reg (compile-expr a let-body-node env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types))
                                        (set last-reg init-reg)
                                      )
                                    )
                                    (if-stmt (string-eq chv "do")
                                      (do
                                        (let do-child Int32 (arena-next-sibling a ch))
                                        (while (!= do-child (- 0 1))
                                          (do
                                            (set last-reg (compile-expr a do-child env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types))
                                            (set do-child (arena-next-sibling a do-child))
                                          )
                                        )
                                      )
                                      (if-stmt (string-eq chv "set")
                                        (do
                                          (let set-name-node Int32 (second-child a child))
                                          (let set-expr-node Int32 (third-child a child))
                                          (let set-name String (arena-value a set-name-node))
                                          (let set-safe String (env-find-safe env-names env-safe set-name))
                                          (let set-ty-node Int32 (env-find-type env-names env-types set-name))
                                          (compile-expr a set-expr-node env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types)
                                          (let val-reg Int32 (- (load Int32 temp) 1))
                                          (buffer-append-string out "  store ")
                                          (emit-type-node out a set-ty-node)
                                          (buffer-append-string out " ")
                                          (emit-temp out val-reg)
                                          (buffer-append-string out ", ")
                                          (emit-pointer-type-node out a set-ty-node)
                                          (buffer-append-string out " %")
                                          (buffer-append-string out set-safe)
                                          (buffer-append-string out "\n")
                                          (set last-reg val-reg)
                                        )
                                        (if-stmt (string-eq chv "if-stmt")
                                          (do
                                            (let if-cond Int32 (second-child a child))
                                            (let if-then Int32 (third-child a child))
                                            (let if-else Int32 (fourth-child a child))
                                            (compile-expr a if-cond env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types)
                                            (let cond-t Int32 (- (load Int32 temp) 1))
                                            (let cond-i1 Int32 (load Int32 temp))
                                            (buffer-append-string out "  ")
                                            (emit-temp out cond-i1)
                                            (buffer-append-string out " = icmp ne i32 ")
                                            (emit-temp out cond-t)
                                            (buffer-append-string out ", 0\n")
                                            (store Int32 temp (+ cond-i1 1))
                                            (let l-then Int32 (load Int32 temp))
                                            (store Int32 temp (+ l-then 1))
                                            (let l-else Int32 (load Int32 temp))
                                            (store Int32 temp (+ l-else 1))
                                            (let l-end Int32 (load Int32 temp))
                                            (store Int32 temp (+ l-end 1))
                                            (buffer-append-string out "  br i1 ")
                                            (emit-temp out cond-i1)
                                            (buffer-append-string out ", label %L")
                                            (buffer-append-string out (int-to-string l-then))
                                            (buffer-append-string out ", label %L")
                                            (buffer-append-string out (int-to-string l-else))
                                            (buffer-append-string out "\n")
                                            (buffer-append-string out "L")
                                            (buffer-append-string out (int-to-string l-then))
                                            (buffer-append-string out ":\n")
                                            (let then-node Int32 if-then)
                                            (if-stmt (== (arena-kind a if-then) (node-kind-list)) (do (let th Int32 (arena-first-child a if-then)) (if-stmt (!= th (- 0 1)) (do (let tv String (arena-value a th)) (if-stmt (string-eq tv "return") (set then-node (second-child a if-then)) (do 0))) (do 0))) (do 0))
                                            (set last-reg (compile-expr a then-node env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types))
                                            (buffer-append-string out "  br label %L")
                                            (buffer-append-string out (int-to-string l-end))
                                            (buffer-append-string out "\n")
                                            (buffer-append-string out "L")
                                            (buffer-append-string out (int-to-string l-else))
                                            (buffer-append-string out ":\n")
                                            (if-stmt (!= if-else (- 0 1))
                                              (do (let else-node Int32 if-else) (if-stmt (== (arena-kind a if-else) (node-kind-list)) (do (let el Int32 (arena-first-child a if-else)) (if-stmt (!= el (- 0 1)) (do (let ev String (arena-value a el)) (if-stmt (string-eq ev "return") (set else-node (second-child a if-else)) (do 0))) (do 0))) (do 0)) (set last-reg (compile-expr a else-node env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types)))
                                              (do 0)
                                            )
                                            (buffer-append-string out "  br label %L")
                                            (buffer-append-string out (int-to-string l-end))
                                            (buffer-append-string out "\n")
                                            (buffer-append-string out "L")
                                            (buffer-append-string out (int-to-string l-end))
                                            (buffer-append-string out ":\n")
                                          )
                                          (if-stmt (string-eq chv "while")
                                            (do
                                              (let while-cond Int32 (second-child a child))
                                              (let while-body Int32 (third-child a child))
                                              (let l-cond Int32 (load Int32 temp))
                                              (store Int32 temp (+ l-cond 1))
                                              (let l-body Int32 (load Int32 temp))
                                              (store Int32 temp (+ l-body 1))
                                              (let l-end Int32 (load Int32 temp))
                                              (store Int32 temp (+ l-end 1))
                                              (buffer-append-string out "  br label %L")
                                              (buffer-append-string out (int-to-string l-cond))
                                              (buffer-append-string out "\n")
                                              (buffer-append-string out "L")
                                              (buffer-append-string out (int-to-string l-cond))
                                              (buffer-append-string out ":\n")
                                              (compile-expr a while-cond env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types)
                                              (let cond-t Int32 (- (load Int32 temp) 1))
                                              (let cond-i1 Int32 (load Int32 temp))
                                              (buffer-append-string out "  ")
                                              (emit-temp out cond-i1)
                                              (buffer-append-string out " = icmp ne i32 ")
                                              (emit-temp out cond-t)
                                              (buffer-append-string out ", 0\n")
                                              (store Int32 temp (+ cond-i1 1))
                                              (buffer-append-string out "  br i1 ")
                                              (emit-temp out cond-i1)
                                              (buffer-append-string out ", label %L")
                                              (buffer-append-string out (int-to-string l-body))
                                              (buffer-append-string out ", label %L")
                                              (buffer-append-string out (int-to-string l-end))
                                              (buffer-append-string out "\n")
                                              (buffer-append-string out "L")
                                              (buffer-append-string out (int-to-string l-body))
                                              (buffer-append-string out ":\n")
                                              (set last-reg (compile-expr a while-body env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types))
                                              (buffer-append-string out "  br label %L")
                                              (buffer-append-string out (int-to-string l-cond))
                                              (buffer-append-string out "\n")
                                              (buffer-append-string out "L")
                                              (buffer-append-string out (int-to-string l-end))
                                              (buffer-append-string out ":\n")
                                            )
                                            (set last-reg (compile-expr a child env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types))
                                          )
                                        )
                                      )
                                    )
                                  )
                                )
                                (set last-reg (compile-expr a child env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types))
                              )
                            )
                            (set last-reg (compile-expr a child env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types))
                          )
                          (set child (arena-next-sibling a child))
                        )
                      )
                      (return last-reg)
                    )
                    (do 0)
                  )
                  (let arg Int32 (arena-next-sibling a head))
                  (let arg-regs ArrayInt32 (array-i32-new))
                  (let arg-types ArrayString (array-str-new))
                  (let max-args Int32 (- 0 1))
                  (if-stmt (string-eq head-val "buffer-append-string")
                    (set max-args 2)
                    (do 0)
                  )
                  (while (!= arg (- 0 1))
                    (do
                      (if-stmt (&& (!= max-args (- 0 1)) (>= (array-i32-len arg-regs) max-args))
                        (set arg (- 0 1))
                        (do
                          (let arg-type String (infer-arg-type a arg env-names env-types fn-sig-names fn-sig-ret-types))
                          (compile-expr a arg env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types)
                          (array-i32-append arg-regs (- (load Int32 temp) 1))
                          (array-str-append arg-types arg-type)
                          (set arg (arena-next-sibling a arg))
                        )
                      )
                    )
                  )
                  (let ret-type String (lookup-fn-ret-type a head-val fn-sig-names fn-sig-ret-types))
                  (let result-reg Int32 (load Int32 temp))
                  (buffer-append-string out "  ")
                  (emit-temp out result-reg)
                  (buffer-append-string out " = call ")
                  (buffer-append-string out ret-type)
                  (buffer-append-string out " @")
                  (buffer-append-string out head-val)
                  (buffer-append-string out "(")
                  (let i Int32 0)
                  (let argc Int32 (array-i32-len arg-regs))
                  (while (< i argc)
                    (do
                      (if-stmt (> i 0)
                        (buffer-append-string out ", ")
                        (do 0)
                      )
                      (buffer-append-string out (array-str-get arg-types i))
                      (buffer-append-string out " ")
                      (emit-temp out (array-i32-get arg-regs i))
                      (set i (+ i 1))
                    )
                  )
                  (buffer-append-string out ")\n")
                  (store Int32 temp (+ result-reg 1))
                  (return result-reg)
                ) ;; do
              ) ;; if-stmt
            ) ;; do
          ) ;; if-stmt
        ) ;; do
      ) ;; if-stmt
    ) ;; body
    (tests
      (test compile-expr-min
        (tags unit)
        (body (let ok Int32 1) (expect-eq ok 1))
      )
    )
  ) ;; fn compile-expr
