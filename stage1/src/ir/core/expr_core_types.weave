  (fn type-node-to-llvm-str
    (doc "Convert a type AST node to LLVM type string.")
    (params (a (ptr Arena)) (ty-node Int32))
    (returns String)
    (body
      (if-stmt (== (arena-kind a ty-node) (node-kind-atom))
        (do
          (let ty-val String (arena-value a ty-node))
          (if-stmt (string-eq ty-val "Int32")
            (return "i32")
            (if-stmt (string-eq ty-val "Int64")
              (return "i64")
              (if-stmt (string-eq ty-val "String")
                (return "i8*")
                (if-stmt (string-eq ty-val "Int8")
                  (return "i8")
                  (if-stmt (string-eq ty-val "Buffer")
                    (return "i8*")
                    (if-stmt (string-eq ty-val "Arena")
                      (return "%Arena")
                      (if-stmt (string-eq ty-val "ArrayString")
                        (return "i8*")
                        (if-stmt (string-eq ty-val "ArrayInt32")
                          (return "i8*")
                          (if-stmt (string-eq ty-val "NodeKind")
                            (return "i32")
                            (if-stmt (string-eq ty-val "Int64")
                              (return "i64")
                              ;; Assume user-defined type is i32 for now
                              (return "i32")
                            )
                          )
                        )
                      )
                    )
                  )
                )
              )
            )
          )
        )
        ;; It's a list - could be (ptr X)
        (do
          (let head Int32 (arena-first-child a ty-node))
          (if-stmt (== head (- 0 1))
            (return "i32")
            (do
              (let head-val String (arena-value a head))
              (if-stmt (string-eq head-val "ptr")
                (do
                  (let inner Int32 (second-child a ty-node))
                  (let inner-ty String (type-node-to-llvm-str a inner))
                  ;; Append * to make it a pointer
                  (let buf Buffer (buffer-new))
                  (buffer-append-string buf inner-ty)
                  (buffer-append-string buf "*")
                  (return (buffer-to-string buf))
                )
                (return "i32")
              )
            )
          )
        )
      )
    )
    (tests
      (test type-node-to-llvm-str-int32
        (doc "Int32 atom converts to i32")
        (tags unit ir types)
        (body
          (let a (ptr Arena) (arena-create 256))
          (let node Int32 (parse-string a "Int32"))
          (let result String (type-node-to-llvm-str a node))
          (expect-eq (string-eq result "i32") 1)
        )
      )
      (test type-node-to-llvm-str-string
        (doc "String atom converts to i8*")
        (tags unit ir types)
        (body
          (let a (ptr Arena) (arena-create 256))
          (let node Int32 (parse-string a "String"))
          (let result String (type-node-to-llvm-str a node))
          (expect-eq (string-eq result "i8*") 1)
        )
      )
      (test type-node-to-llvm-str-ptr
        (doc "Pointer type converts to inner-type*")
        (tags unit ir types)
        (body
          (let a (ptr Arena) (arena-create 256))
          (let node Int32 (parse-string a "(ptr Int32)"))
          (let result String (type-node-to-llvm-str a node))
          (expect-eq (string-eq result "i32*") 1)
        )
      )
      (test type-node-to-llvm-str-nested-ptr
        (doc "Nested pointer converts correctly")
        (tags unit ir types)
        (body
          (let a (ptr Arena) (arena-create 256))
          (let node Int32 (parse-string a "(ptr (ptr Int32))"))
          (let result String (type-node-to-llvm-str a node))
          (expect-eq (string-eq result "i32**") 1)
        )
      )
    )
  )

  (fn infer-arg-type
    (doc "Infer the LLVM type of an expression (for call arguments).")
    (params (a (ptr Arena)) (node Int32) (env-names ArrayString) (env-types ArrayInt32) (fn-sig-names ArrayString) (fn-sig-ret-types ArrayInt32))
    (returns String)
    (body
      (if-stmt (== (arena-kind a node) (node-kind-atom))
        ;; Atom: could be integer literal, string literal, or variable
        (do
          (let val String (arena-value a node))
          ;; Check if it's a string literal
          (if-stmt (== (is-string-literal val) 1)
            (return "i8*")
            (do 0)
          )
          ;; Check if it's a number
          (let first-char Int32 (string-char-at val 0))
          (if-stmt (|| (&& (>= first-char 48) (<= first-char 57)) (== first-char 45))
            (return "i32")
            ;; It's a variable - look up its type
            (do
              (let ty-node Int32 (env-find-type env-names env-types val))
              (if-stmt (== ty-node (- 0 1))
                (return "i32")
                (return (type-node-to-llvm-str a ty-node))
              )
            )
          )
        )
        ;; List expression
        (do
          (let head Int32 (arena-first-child a node))
          (if-stmt (== head (- 0 1))
            (return "i32")
            (do
              (let head-val String (arena-value a head))
              ;; (addr x) returns a pointer
              (if-stmt (string-eq head-val "addr")
                (do
                  (let inner Int32 (second-child a node))
                  (let inner-type String (infer-arg-type a inner env-names env-types fn-sig-names fn-sig-ret-types))
                  (let buf Buffer (buffer-new))
                  (buffer-append-string buf inner-type)
                  (buffer-append-string buf "*")
                  (return (buffer-to-string buf))
                )
                (do 0)
              )
              ;; (load ty ptr) returns ty
              (if-stmt (string-eq head-val "load")
                (do
                  (let ty-node Int32 (second-child a node))
                  (return (type-node-to-llvm-str a ty-node))
                )
                (do 0)
              )
              ;; (get-field ...) returns i8* for now (most fields are opaque handles)
              (if-stmt (string-eq head-val "get-field")
                (return "i8*")
                (do 0)
              )
              ;; (ptr-add TYPE PTR IDX) returns pointer to TYPE
              (if-stmt (string-eq head-val "ptr-add")
                (do
                  (let ty-node Int32 (second-child a node))
                  (let ptr-type-str String (type-node-to-llvm-str a ty-node))
                  (let buf Buffer (buffer-new))
                  (buffer-append-string buf ptr-type-str)
                  (buffer-append-string buf "*")
                  (return (buffer-to-string buf))
                )
                (do 0)
              )
              ;; Arithmetic ops return i32
              (if-stmt (|| (|| (|| (string-eq head-val "+") (string-eq head-val "-")) (string-eq head-val "*")) (string-eq head-val "/"))
                (return "i32")
                (do 0)
              )
              ;; Comparison ops return i32 (zext'd)
              (if-stmt (|| (|| (|| (|| (string-eq head-val "==") (string-eq head-val "!=")) (string-eq head-val "<")) (string-eq head-val ">")) (|| (string-eq head-val "<=") (string-eq head-val ">=")))
                (return "i32")
                (do 0)
              )
              ;; Function call - look up return type
              (return (lookup-fn-ret-type a head-val fn-sig-names fn-sig-ret-types (array-string-create) (array-string-create) (array-string-create)))
            )
          )
        )
      )
    )
    (tests
      (test infer-arg-type-number-literal
        (doc "Number literal infers to i32")
        (tags unit ir types)
        (body
          (let a (ptr Arena) (arena-create 256))
          (let node Int32 (parse-string a "42"))
          (let result String (infer-arg-type a node (array-str-new) (array-i32-new) (array-str-new) (array-i32-new)))
          (expect-eq (string-eq result "i32") 1)
        )
      )
      (test infer-arg-type-string-literal
        (doc "String literal infers to i8*")
        (tags unit ir types)
        (body
          (let a (ptr Arena) (arena-create 256))
          (let node Int32 (parse-string a "\"hello\""))
          (let result String (infer-arg-type a node (array-str-new) (array-i32-new) (array-str-new) (array-i32-new)))
          (expect-eq (string-eq result "i8*") 1)
        )
      )
      (test infer-arg-type-variable
        (doc "Variable infers type from environment")
        (tags unit ir types)
        (body
          (let a (ptr Arena) (arena-create 256))
          (let node Int32 (parse-string a "x"))
          (let env-names ArrayString (array-str-new))
          (let env-types ArrayInt32 (array-i32-new))
          (array-str-append env-names "x")
          (let ty-node Int32 (parse-string a "String"))
          (array-i32-append env-types ty-node)
          (let result String (infer-arg-type a node env-names env-types (array-str-new) (array-i32-new)))
          (expect-eq (string-eq result "i8*") 1)
        )
      )
      (test infer-arg-type-arith-expr
        (doc "Arithmetic expression returns i32")
        (tags unit ir types)
        (body
          (let a (ptr Arena) (arena-create 256))
          (let node Int32 (parse-string a "(+ 1 2)"))
          (let result String (infer-arg-type a node (array-str-new) (array-i32-new) (array-str-new) (array-i32-new)))
          (expect-eq (string-eq result "i32") 1)
        )
      )
    )
  )

  (fn get-struct-name-from-type-node
    (doc "Extract struct name from a type node (atom 'Arena' or list '(struct Arena)').")
    (params (a (ptr Arena)) (ty-node Int32)) (returns String)
    (body
      (if-stmt (== (arena-kind a ty-node) (node-kind-atom))
        ;; Atom type: just the struct name
        (return (arena-value a ty-node))
        (do
          ;; List type: should be (struct Name)
          (let head Int32 (arena-first-child a ty-node))
          (if-stmt (== head (- 0 1)) (return "") (do 0))
          (let head-val String (arena-value a head))
          (if-stmt (string-eq head-val "struct")
            (do
              (let name-node Int32 (arena-next-sibling a head))
              (if-stmt (== name-node (- 0 1)) (return "") (do 0))
              (return (arena-value a name-node))
            )
            (return "")
          )
        )
      )
    )
    (tests
      (test get-struct-name-from-type-node-atom
        (doc "Atom type returns the name directly")
        (tags unit ir types)
        (body
          (let a (ptr Arena) (arena-create 256))
          (let node Int32 (parse-string a "Arena"))
          (let result String (get-struct-name-from-type-node a node))
          (expect-eq (string-eq result "Arena") 1)
        )
      )
      (test get-struct-name-from-type-node-struct-form
        (doc "Struct form extracts name from (struct Name)")
        (tags unit ir types)
        (body
          (let a (ptr Arena) (arena-create 256))
          (let node Int32 (parse-string a "(struct Point)"))
          (let result String (get-struct-name-from-type-node a node))
          (expect-eq (string-eq result "Point") 1)
        )
      )
      (test get-struct-name-from-type-node-other-list
        (doc "Non-struct list returns empty string")
        (tags unit ir types)
        (body
          (let a (ptr Arena) (arena-create 256))
          (let node Int32 (parse-string a "(ptr Int32)"))
          (let result String (get-struct-name-from-type-node a node))
          (expect-eq (string-eq result "") 1)
        )
      )
    )
  ) ;; fn get-struct-name-from-type-node
