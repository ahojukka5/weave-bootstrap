;; Control flow expression compilation (do, let, if-stmt, while)
;; Note: These functions call compile-expr recursively, so they must be in the same module

(fn compile-do-expr
    (doc "Compile a do expression: (do expr1 expr2 ... exprN) - evaluates all, returns last.")
    (params
      (a (ptr Arena))
      (node Int32)
      (env-names ArrayString)
      (env-safe ArrayString)
      (env-types ArrayInt32)
      (declared ArrayString)
      (struct-names ArrayString)
      (struct-fields ArrayString)
      (decls Buffer)
      (str-counter (ptr Int32))
      (out Buffer)
      (temp (ptr Int32))
      (fn-sig-names ArrayString)
      (fn-sig-ret-types ArrayInt32)
    )
    (returns Int32)
    (body
      (let head Int32 (arena-first-child a node))
      (let do-child Int32 (arena-next-sibling a head))
      (let do-last-reg Int32 0)
      (while (!= do-child (- 0 1))
        (do
          (set do-last-reg (compile-expr a do-child env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types))
          (set do-child (arena-next-sibling a do-child))
        )
      )
      (return do-last-reg)
    )
    (tests
      (test compile-do-expr-basic
        (doc "Test that compile-do-expr exists")
        (tags unit)
        (body
          (expect-true 1)
        )
      )
    )
)

(fn compile-let-expr
    (doc "Compile a let expression: (let name type init [body]) - binds variable, optionally evaluates body.")
    (params
      (a (ptr Arena))
      (node Int32)
      (env-names ArrayString)
      (env-safe ArrayString)
      (env-types ArrayInt32)
      (declared ArrayString)
      (struct-names ArrayString)
      (struct-fields ArrayString)
      (decls Buffer)
      (str-counter (ptr Int32))
      (out Buffer)
      (temp (ptr Int32))
      (fn-sig-names ArrayString)
      (fn-sig-ret-types ArrayInt32)
    )
    (returns Int32)
    (body
      (let let-name-node Int32 (second-child a node))
      (let let-type-node Int32 (third-child a node))
      (let let-init-node Int32 (fourth-child a node))
      (let let-name String (arena-value a let-name-node))
      (let let-safe String (sanitize-name let-name))
      (let init-reg Int32 (compile-expr a let-init-node env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types))
      (env-add env-names env-safe env-types let-name let-safe let-type-node)
      (let actual-safe String (env-find-safe env-names env-safe let-name))
      (buffer-append-string out "  %")
      (buffer-append-string out actual-safe)
      (buffer-append-string out " = alloca ")
      (emit-type-node out a let-type-node struct-names)
      (buffer-append-string out "\n")
      (buffer-append-string out "  store ")
      (emit-type-node out a let-type-node struct-names)
      (buffer-append-string out " ")
      (emit-temp out init-reg)
      (buffer-append-string out ", ")
      (emit-pointer-type-node out a let-type-node struct-names)
      (buffer-append-string out " %")
      (buffer-append-string out actual-safe)
      (buffer-append-string out "\n")
      (let let-body-node Int32 (fifth-child a node))
      (if-stmt (!= let-body-node (- 0 1))
        (return (compile-expr a let-body-node env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types))
        (return init-reg)
      )
    )
    (tests
      (test compile-let-expr-basic
        (doc "Test that compile-let-expr exists")
        (tags unit)
        (body
          (expect-true 1)
        )
      )
    )
)

(fn compile-set-expr
    (doc "Compile a set expression: (set name expr) - updates variable value.")
    (params
      (a (ptr Arena))
      (node Int32)
      (env-names ArrayString)
      (env-safe ArrayString)
      (env-types ArrayInt32)
      (declared ArrayString)
      (struct-names ArrayString)
      (struct-fields ArrayString)
      (decls Buffer)
      (str-counter (ptr Int32))
      (out Buffer)
      (temp (ptr Int32))
      (fn-sig-names ArrayString)
      (fn-sig-ret-types ArrayInt32)
    )
    (returns Int32)
    (body
      (let set-name-node Int32 (second-child a node))
      (let set-expr-node Int32 (third-child a node))
      (let set-name String (arena-value a set-name-node))
      (let set-safe String (env-find-safe env-names env-safe set-name))
      (let set-ty-node Int32 (env-find-type env-names env-types set-name))
      (compile-expr a set-expr-node env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types)
      (let val-reg Int32 (- (load Int32 temp) 1))
      (buffer-append-string out "  store ")
      (emit-type-node out a set-ty-node struct-names)
      (buffer-append-string out " ")
      (emit-temp out val-reg)
      (buffer-append-string out ", ")
      (emit-pointer-type-node out a set-ty-node struct-names)
      (buffer-append-string out " %")
      (buffer-append-string out set-safe)
      (buffer-append-string out "\n")
      (return val-reg)
    )
    (tests
      (test compile-set-expr-basic
        (doc "Test that compile-set-expr exists")
        (tags unit)
        (body
          (expect-true 1)
        )
      )
    )
)

(fn compile-return-expr
    (doc "Compile a return expression: (return expr) - returns value from function.")
    (params
      (a (ptr Arena))
      (node Int32)
      (env-names ArrayString)
      (env-safe ArrayString)
      (env-types ArrayInt32)
      (declared ArrayString)
      (struct-names ArrayString)
      (struct-fields ArrayString)
      (decls Buffer)
      (str-counter (ptr Int32))
      (out Buffer)
      (temp (ptr Int32))
      (fn-sig-names ArrayString)
      (fn-sig-ret-types ArrayInt32)
    )
    (returns Int32)
    (body
      (let ret-node Int32 (second-child a node))
      (return (compile-expr a ret-node env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types))
    )
    (tests
      (test compile-return-expr-basic
        (doc "Test that compile-return-expr exists")
        (tags unit)
        (body
          (expect-true 1)
        )
      )
    )
)

(fn compile-if-expr
    (doc "Compile an if-stmt expression: (if-stmt cond then else) - conditional with phi node.")
    (params
      (a (ptr Arena))
      (node Int32)
      (env-names ArrayString)
      (env-safe ArrayString)
      (env-types ArrayInt32)
      (declared ArrayString)
      (struct-names ArrayString)
      (struct-fields ArrayString)
      (decls Buffer)
      (str-counter (ptr Int32))
      (out Buffer)
      (temp (ptr Int32))
      (fn-sig-names ArrayString)
      (fn-sig-ret-types ArrayInt32)
    )
    (returns Int32)
    (body
      (let if-cond Int32 (second-child a node))
      (let if-then Int32 (third-child a node))
      (let if-else Int32 (fourth-child a node))
      (let cond-reg Int32 (compile-expr a if-cond env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types))
      (let cond-i1 Int32 (load Int32 temp))
      (buffer-append-string out "  ")
      (emit-temp out cond-i1)
      (buffer-append-string out " = icmp ne i32 ")
      (emit-temp out cond-reg)
      (buffer-append-string out ", 0\n")
      (store Int32 temp (+ cond-i1 1))
      (let l-then Int32 (load Int32 temp))
      (store Int32 temp (+ l-then 1))
      (let l-else Int32 (load Int32 temp))
      (store Int32 temp (+ l-else 1))
      (let l-then-join Int32 (load Int32 temp))
      (store Int32 temp (+ l-then-join 1))
      (let l-else-join Int32 (load Int32 temp))
      (store Int32 temp (+ l-else-join 1))
      (let l-end Int32 (load Int32 temp))
      (store Int32 temp (+ l-end 1))
      (buffer-append-string out "  br i1 ")
      (emit-temp out cond-i1)
      (buffer-append-string out ", label %L")
      (buffer-append-string out (int-to-string l-then))
      (buffer-append-string out ", label %L")
      (buffer-append-string out (int-to-string l-else))
      (buffer-append-string out "\n")
      (buffer-append-string out "L")
      (buffer-append-string out (int-to-string l-then))
      (buffer-append-string out ":\n")
      (let then-node Int32 if-then)
      (if-stmt (== (arena-kind a if-then) (node-kind-list)) (do (let th Int32 (arena-first-child a if-then)) (if-stmt (!= th (- 0 1)) (do (let tv String (arena-value a th)) (if-stmt (string-eq tv "return") (set then-node (second-child a if-then)) (do 0))) (do 0))) (do 0))
      (let then-reg Int32 (compile-expr a then-node env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types))
      (buffer-append-string out "  br label %L")
      (buffer-append-string out (int-to-string l-then-join))
      (buffer-append-string out "\n")
      (buffer-append-string out "L")
      (buffer-append-string out (int-to-string l-then-join))
      (buffer-append-string out ":\n")
      (buffer-append-string out "  br label %L")
      (buffer-append-string out (int-to-string l-end))
      (buffer-append-string out "\n")
      (buffer-append-string out "L")
      (buffer-append-string out (int-to-string l-else))
      (buffer-append-string out ":\n")
      (let else-reg Int32 0)
      (if-stmt (!= if-else (- 0 1))
        (do (let else-node Int32 if-else) (if-stmt (== (arena-kind a if-else) (node-kind-list)) (do (let el Int32 (arena-first-child a if-else)) (if-stmt (!= el (- 0 1)) (do (let ev String (arena-value a el)) (if-stmt (string-eq ev "return") (set else-node (second-child a if-else)) (do 0))) (do 0))) (do 0)) (set else-reg (compile-expr a else-node env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types)))
        (do
          (let default-t Int32 (load Int32 temp))
          (buffer-append-string out "  ")
          (emit-temp out default-t)
          (buffer-append-string out " = ")
          (if-stmt (is-pointer-expr a if-then env-names env-types)
            (buffer-append-string out "bitcast i8* null to i8*")
            (buffer-append-string out "add i32 0, 0")
          )
          (buffer-append-string out "\n")
          (set else-reg default-t)
          (store Int32 temp (+ default-t 1))
        )
      )
      (buffer-append-string out "  br label %L")
      (buffer-append-string out (int-to-string l-else-join))
      (buffer-append-string out "\n")
      (buffer-append-string out "L")
      (buffer-append-string out (int-to-string l-else-join))
      (buffer-append-string out ":\n")
      (buffer-append-string out "  br label %L")
      (buffer-append-string out (int-to-string l-end))
      (buffer-append-string out "\n")
      (buffer-append-string out "L")
      (buffer-append-string out (int-to-string l-end))
      (buffer-append-string out ":\n")
      (let phi Int32 (load Int32 temp))
      (buffer-append-string out "  ")
      (emit-temp out phi)
      (buffer-append-string out " = phi ")
      (if-stmt (is-pointer-expr a if-then env-names env-types)
        (buffer-append-string out "i8*")
        (buffer-append-string out "i32")
      )
      (buffer-append-string out " [ ")
      (emit-temp out then-reg)
      (buffer-append-string out ", %L")
      (buffer-append-string out (int-to-string l-then-join))
      (buffer-append-string out " ], [ ")
      (emit-temp out else-reg)
      (buffer-append-string out ", %L")
      (buffer-append-string out (int-to-string l-else-join))
      (buffer-append-string out " ]\n")
      (store Int32 temp (+ phi 1))
      (return phi)
    )
    (tests
      (test compile-if-expr-basic
        (doc "Test that compile-if-expr exists")
        (tags unit)
        (body
          (expect-true 1)
        )
      )
    )
)

(fn compile-while-expr
    (doc "Compile a while expression: (while cond body) - loop with labels.")
    (params
      (a (ptr Arena))
      (node Int32)
      (env-names ArrayString)
      (env-safe ArrayString)
      (env-types ArrayInt32)
      (declared ArrayString)
      (struct-names ArrayString)
      (struct-fields ArrayString)
      (decls Buffer)
      (str-counter (ptr Int32))
      (out Buffer)
      (temp (ptr Int32))
      (fn-sig-names ArrayString)
      (fn-sig-ret-types ArrayInt32)
    )
    (returns Int32)
    (body
      (let while-cond Int32 (second-child a node))
      (let while-body Int32 (third-child a node))
      (let l-cond Int32 (load Int32 temp))
      (store Int32 temp (+ l-cond 1))
      (let l-body Int32 (load Int32 temp))
      (store Int32 temp (+ l-body 1))
      (let l-end Int32 (load Int32 temp))
      (store Int32 temp (+ l-end 1))
      (buffer-append-string out "  br label %L")
      (buffer-append-string out (int-to-string l-cond))
      (buffer-append-string out "\n")
      (buffer-append-string out "L")
      (buffer-append-string out (int-to-string l-cond))
      (buffer-append-string out ":\n")
      (compile-expr a while-cond env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types)
      (let cond-t Int32 (- (load Int32 temp) 1))
      (let cond-i1 Int32 (load Int32 temp))
      (buffer-append-string out "  ")
      (emit-temp out cond-i1)
      (buffer-append-string out " = icmp ne i32 ")
      (emit-temp out cond-t)
      (buffer-append-string out ", 0\n")
      (store Int32 temp (+ cond-i1 1))
      (buffer-append-string out "  br i1 ")
      (emit-temp out cond-i1)
      (buffer-append-string out ", label %L")
      (buffer-append-string out (int-to-string l-body))
      (buffer-append-string out ", label %L")
      (buffer-append-string out (int-to-string l-end))
      (buffer-append-string out "\n")
      (buffer-append-string out "L")
      (buffer-append-string out (int-to-string l-body))
      (buffer-append-string out ":\n")
      (compile-expr a while-body env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types)
      (buffer-append-string out "  br label %L")
      (buffer-append-string out (int-to-string l-cond))
      (buffer-append-string out "\n")
      (buffer-append-string out "L")
      (buffer-append-string out (int-to-string l-end))
      (buffer-append-string out ":\n")
      (return 0)
    )
    (tests
      (test compile-while-expr-basic
        (doc "Test that compile-while-expr exists")
        (tags unit)
        (body
          (expect-true 1)
        )
      )
    )
)

