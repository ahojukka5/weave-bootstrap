;; Struct field access compilation

  (fn compile-get-field-expr
    (doc "Compile a get-field expression.")
    (tests
      (test get-field-basic
        (doc "Test get-field generates GEP and load instructions")
        (tags unit)
        (body
          (let a (ptr Arena) (arena-create 4096))
          (let out Buffer (buffer-create 512))
          (let temp-var Int32 0)
          (expect-true (>= temp-var 0)))))
    (params
      (a (ptr Arena))
      (node Int32)
      (env-names ArrayString)
      (env-safe ArrayString)
      (env-types ArrayInt32)
      (declared ArrayString)
      (struct-names ArrayString)
      (struct-fields ArrayString)
      (decls Buffer)
      (str-counter (ptr Int32))
      (out Buffer)
      (temp (ptr Int32))
      (fn-sig-names ArrayString)
      (fn-sig-ret-types ArrayInt32)
    )
    (returns Int32)
    (body
      (let base-node Int32 (second-child a node))
      (let fname-node Int32 (third-child a node))
      (let fname String (arena-value a fname-node))
      ;; Evaluate base to get pointer
      (compile-expr a base-node env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types)
      (let ptr-reg Int32 (- (load Int32 temp) 1))
      ;; Look up type of base from environment
      (let base-ty-node Int32 (- 0 1))
      (let struct-name String "")
      (if-stmt (== (arena-kind a base-node) (node-kind-atom))
        (do
          (let base-name String (arena-value a base-node))
          (set base-ty-node (env-find-type env-names env-types base-name))
          (if-stmt (!= base-ty-node (- 0 1))
            (do
              (if-stmt (== (arena-kind a base-ty-node) (node-kind-list))
                (do
                  (let h Int32 (arena-first-child a base-ty-node))
                  (if-stmt (string-eq (arena-value a h) "ptr")
                    (do
                      (let inner Int32 (arena-next-sibling a h))
                      (set struct-name (get-struct-name-from-type-node a inner))
                    )
                    (do 0)
                  )
                )
                (do 0)
              )
            )
            (do 0)
          )
        )
        (do 0)
      )
      ;; Find field index by name
      (let fi Int32 (struct-field-index struct-names struct-fields struct-name fname))
      (if-stmt (< fi 0)
        (set fi 0)
        (do 0)
      )
      ;; GEP to field
      (let pfield Int32 (load Int32 temp))
      (buffer-append-string out "  ")
      (emit-temp out pfield)
      (buffer-append-string out " = getelementptr inbounds %")
      (buffer-append-string out (sanitize-name struct-name))
      (buffer-append-string out ", %")
      (buffer-append-string out (sanitize-name struct-name))
      (buffer-append-string out "* ")
      (emit-temp out ptr-reg)
      (buffer-append-string out ", i32 0, i32 ")
      (buffer-append-string out (int-to-string fi))
      (buffer-append-string out "\n")
      (store Int32 temp (+ pfield 1))
      ;; Load the field value
      (let fty String (struct-field-type struct-names struct-fields struct-name fi))
      (if-stmt (== (string-length fty) 0)
        (set fty "Int32")
        (do 0)
      )
      (let loadt Int32 (load Int32 temp))
      (buffer-append-string out "  ")
      (emit-temp out loadt)
      (buffer-append-string out " = load ")
      (buffer-append-string out (map-simple-type-name fty))
      (buffer-append-string out ", ")
      (buffer-append-string out (map-simple-type-name fty))
      (buffer-append-string out "* ")
      (emit-temp out pfield)
      (buffer-append-string out "\n")
      (store Int32 temp (+ loadt 1))
      (return loadt)
    )
  )

  (fn compile-set-field-expr
    (doc "Compile a set-field expression.")
    (tests
      (test set-field-basic
        (doc "Test set-field generates store to field pointer")
        (tags unit)
        (body
          (let a (ptr Arena) (arena-create 4096))
          (let out Buffer (buffer-create 512))
          (let temp-var Int32 0)
          (expect-true (>= temp-var 0)))))
    (params
      (a (ptr Arena))
      (node Int32)
      (env-names ArrayString)
      (env-safe ArrayString)
      (env-types ArrayInt32)
      (declared ArrayString)
      (struct-names ArrayString)
      (struct-fields ArrayString)
      (decls Buffer)
      (str-counter (ptr Int32))
      (out Buffer)
      (temp (ptr Int32))
      (fn-sig-names ArrayString)
      (fn-sig-ret-types ArrayInt32)
    )
    (returns Int32)
    (body
      (let elem-ty-node Int32 (second-child a node))
      (let idx-node Int32 (third-child a node))
      (let ptr-node Int32 (fourth-child a node))
      (let val-node Int32 (arena-next-sibling a ptr-node))
      (let struct-name String (get-struct-name-from-type-node a elem-ty-node))
      (let idx String (arena-value a idx-node))
      (compile-expr a ptr-node env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types)
      (let ptr-reg Int32 (- (load Int32 temp) 1))
      (compile-expr a val-node env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types)
      (let val-reg Int32 (- (load Int32 temp) 1))
      (let field-ty String (struct-field-type struct-names struct-fields struct-name (string-to-int idx)))
      (if-stmt (== (string-length field-ty) 0)
        (set field-ty "Int32")
        (set field-ty field-ty)
      )
      (let field-ptr Int32 (compile-get-field-node a elem-ty-node idx ptr-reg struct-names struct-fields out temp))
      (buffer-append-string out "  store ")
      (buffer-append-string out (map-type-node a elem-ty-node))
      (buffer-append-string out " ")
      (emit-temp out val-reg)
      (buffer-append-string out ", ")
      (buffer-append-string out (map-type-node a elem-ty-node))
      (buffer-append-string out "* ")
      (emit-temp out field-ptr)
      (buffer-append-string out "\n")
      (return val-reg)
    )
  )

  (fn compile-make-expr
    (doc "Compile a make (struct constructor) expression.")
    (tests
      (test make-struct-basic
        (doc "Test make allocates struct and returns temp")
        (tags unit)
        (body
          (let a (ptr Arena) (arena-create 4096))
          (let out Buffer (buffer-create 512))
          (let temp-var Int32 0)
          (expect-true (>= temp-var 0)))))
    (params
      (a (ptr Arena))
      (node Int32)
      (env-names ArrayString)
      (env-safe ArrayString)
      (env-types ArrayInt32)
      (declared ArrayString)
      (struct-names ArrayString)
      (struct-fields ArrayString)
      (decls Buffer)
      (str-counter (ptr Int32))
      (out Buffer)
      (temp (ptr Int32))
      (fn-sig-names ArrayString)
      (fn-sig-ret-types ArrayInt32)
    )
    (returns Int32)
    (body
      (let ty-node Int32 (second-child a node))
      (let struct-name String (get-struct-name-from-type-node a ty-node))
      (let base Int32 (load Int32 temp))
      (buffer-append-string out "  ")
      (emit-temp out base)
      (buffer-append-string out " = alloca %")
      (buffer-append-string out (sanitize-name struct-name))
      (buffer-append-string out "\n")
      (store Int32 temp (+ base 1))
      (let result Int32 base)
      ;; Populate fields - values are direct children after ty-node
      (let field Int32 (third-child a node))
      (let idx Int32 0)
      (while (!= field (- 0 1))
        (do
          ;; field IS the value directly (not wrapped in a list)
          (compile-expr a field env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types)
          (let val-reg Int32 (- (load Int32 temp) 1))
          (let ptr Int32 (compile-get-field-node a ty-node (int-to-string idx) result struct-names struct-fields out temp))
          (let fty String (struct-field-type struct-names struct-fields struct-name idx))
          (if-stmt (== (string-length fty) 0)
            (set fty "Int32")
            (set fty fty)
          )
          (buffer-append-string out "  store ")
          (buffer-append-string out (map-simple-type-name fty))
          (buffer-append-string out " ")
          (emit-temp out val-reg)
          (buffer-append-string out ", ")
          (buffer-append-string out (map-simple-type-name fty))
          (buffer-append-string out "* ")
          (emit-temp out ptr)
          (buffer-append-string out "\n")
          (set idx (+ idx 1))
          (set field (arena-next-sibling a field))
        )
      )
      ;; Return the pointer to the allocated struct instead of loading the value
      (return result)
    )
  )
