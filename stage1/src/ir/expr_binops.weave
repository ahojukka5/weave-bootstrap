;; Binary operations compilation

  (fn compile-binary-ops
    (doc "Check if head-val is a binary operator.")
    (tests
      (test arith-plus
        (doc "Test that + is recognized as binary operator")
        (tags unit)
        (body (expect-eq (compile-binary-ops "+") 1)))
      (test arith-mul
        (doc "Test that * is recognized as binary operator")
        (tags unit)
        (body (expect-eq (compile-binary-ops "*") 1)))
      (test cmp-eq
        (doc "Test that == is recognized as binary operator")
        (tags unit)
        (body (expect-eq (compile-binary-ops "==") 1)))
      (test logical-and
        (doc "Test that && is recognized as binary operator")
        (tags unit)
        (body (expect-eq (compile-binary-ops "&&") 1)))
      (test non-binop
        (doc "Test that non-operators return 0")
        (tags unit)
        (body (expect-eq (compile-binary-ops "foo") 0))))
    (params (head-val String))
    (returns Int32)
    (body
      (if-stmt
        (||
          (string-eq head-val "+")
          (||
            (string-eq head-val "-")
            (||
              (string-eq head-val "*")
              (||
                (string-eq head-val "/")
                (||
                  (string-eq head-val "==")
                  (||
                    (string-eq head-val "!=")
                    (||
                      (string-eq head-val "<")
                      (||
                        (string-eq head-val ">")
                        (||
                          (string-eq head-val "<=")
                          (||
                            (string-eq head-val ">=")
                            (||
                              (string-eq head-val "&&")
                              (string-eq head-val "||")
                            )
                          )
                        )
                      )
                    )
                  )
                )
              )
            )
          )
        )
        (return 1)
        (return 0)
      )
    )
  )

  (fn is-comparison-op
    (doc "Check if head-val is a comparison or logical operator.")
    (tests
      (test cmp-eq-check
        (doc "Test that == is a comparison operator")
        (tags unit)
        (body (expect-eq (is-comparison-op "==") 1)))
      (test cmp-ne-check
        (doc "Test that != is a comparison operator")
        (tags unit)
        (body (expect-eq (is-comparison-op "!=") 1)))
      (test logical-or-check
        (doc "Test that || is a comparison operator")
        (tags unit)
        (body (expect-eq (is-comparison-op "||") 1)))
      (test arith-not-cmp
        (doc "Test that + is not a comparison operator")
        (tags unit)
        (body (expect-eq (is-comparison-op "+") 0)))
      (test non-op-not-cmp
        (doc "Test that non-operators return 0")
        (tags unit)
        (body (expect-eq (is-comparison-op "foo") 0))))
    (params (head-val String))
    (returns Int32)
    (body
      (if-stmt
        (||
          (string-eq head-val "==")
          (||
            (string-eq head-val "!=")
            (||
              (string-eq head-val "<")
              (||
                (string-eq head-val ">")
                (||
                  (string-eq head-val "<=")
                  (||
                    (string-eq head-val ">=")
                    (||
                      (string-eq head-val "&&")
                      (string-eq head-val "||")
                    )
                  )
                )
              )
            )
          )
        )
        (return 1)
        (return 0)
      )
    )
  )

  (fn compile-binary-expr
    (doc "Compile a binary expression.")
    (tests
      (test binexpr-arith
        (doc "Test arithmetic binary expression generates temp")
        (tags unit)
        (body
          (let a (ptr Arena) (arena-create 4096))
          (let node Int32 (parse-string a "(+ 1 2)"))
          (let out Buffer (buffer-create 256))
          (let temp-var Int32 0)
          (let result Int32 (compile-binary-expr a node "+" (array-string-create) (array-string-create) (array-int32-create) (array-string-create) (array-string-create) (array-string-create) (buffer-create 0) (addr-of Int32 temp-var) out (addr-of Int32 temp-var) (array-string-create) (array-int32-create)))
          (expect-true (> result 0))))
      (test binexpr-cmp
        (doc "Test comparison binary expression generates temp")
        (tags unit)
        (body
          (let a (ptr Arena) (arena-create 4096))
          (let node Int32 (parse-string a "(== 1 2)"))
          (let out Buffer (buffer-create 256))
          (let temp-var Int32 0)
          (let result Int32 (compile-binary-expr a node "==" (array-string-create) (array-string-create) (array-int32-create) (array-string-create) (array-string-create) (array-string-create) (buffer-create 0) (addr-of Int32 temp-var) out (addr-of Int32 temp-var) (array-string-create) (array-int32-create)))
          (expect-true (> result 0)))))
    (params
      (a (ptr Arena))
      (node Int32)
      (head-val String)
      (env-names ArrayString)
      (env-safe ArrayString)
      (env-types ArrayInt32)
      (declared ArrayString)
      (struct-names ArrayString)
      (struct-fields ArrayString)
      (decls Buffer)
      (str-counter (ptr Int32))
      (out Buffer)
      (temp (ptr Int32))
      (fn-sig-names ArrayString)
      (fn-sig-ret-types ArrayInt32)
    )
    (returns Int32)
    (body
      (let lhs Int32 (second-child a node))
      (let rhs Int32 (third-child a node))
      (compile-expr a lhs env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types)
      (let lhs-t Int32 (- (load Int32 temp) 1))
      (compile-expr a rhs env-names env-safe env-types declared struct-names struct-fields decls str-counter out temp fn-sig-names fn-sig-ret-types)
      (let rhs-t Int32 (- (load Int32 temp) 1))
      (if-stmt (== (is-comparison-op head-val) 1)
        (do
          (if-stmt
            (||
              (string-eq head-val "&&")
              (string-eq head-val "||")
            )
            (do
              (let reg Int32 (compile-logical head-val lhs-t rhs-t out temp))
              (return reg)
            )
            (do
              (let pred String "eq")
              (if-stmt (string-eq head-val "!=") (set pred "ne") (do 0))
              (if-stmt (string-eq head-val "<") (set pred "slt") (do 0))
              (if-stmt (string-eq head-val ">") (set pred "sgt") (do 0))
              (if-stmt (string-eq head-val "<=") (set pred "sle") (do 0))
              (if-stmt (string-eq head-val ">=") (set pred "sge") (do 0))
              ;; Pointer-aware equality: if either side is a pointer and op is ==/!=, compare as i8* with null literal support
              (if-stmt (&& (|| (string-eq head-val "==") (string-eq head-val "!=")) (|| (== (is-pointer-expr a lhs env-names env-types) 1) (== (is-pointer-expr a rhs env-names env-types) 1)))
                (do
                  (let tcmp Int32 (load Int32 temp))
                  (let t Int32 (+ tcmp 1))
                  (buffer-append-string out "  ")
                  (emit-temp out tcmp)
                  (buffer-append-string out " = icmp ")
                  (buffer-append-string out pred)
                  (buffer-append-string out " i8* ")
                  (if-stmt (== (is-pointer-expr a lhs env-names env-types) 1)
                    (do (emit-temp out lhs-t))
                    (do (buffer-append-string out "null"))
                  )
                  (buffer-append-string out ", ")
                  (if-stmt (== (is-pointer-expr a rhs env-names env-types) 1)
                    (do (emit-temp out rhs-t))
                    (do (buffer-append-string out "null"))
                  )
                  (buffer-append-string out "\n")
                  (buffer-append-string out "  ")
                  (emit-temp out t)
                  (buffer-append-string out " = zext i1 ")
                  (emit-temp out tcmp)
                  (buffer-append-string out " to i32\n")
                  (store Int32 temp (+ t 1))
                  (return t)
                )
                (do
                  (let reg Int32 (compile-icmp pred lhs-t rhs-t out temp))
                  (return reg)
                )
              )
            )
          )
        )
        (do
          (let reg Int32 (compile-binary-arith head-val lhs-t rhs-t out temp))
          (return reg)
        )
      )
    )
  )
