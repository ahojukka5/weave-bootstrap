(fn is-list-with-head
  (doc "Return 1 if node is a list whose first atom equals head.")
  (params
    (a (ptr Arena))
    (node Int32)
    (head String)
  ) ;; params
  (returns Int32)
  (body
    (if-stmt (== (arena-kind a node) (node-kind-list))
      (let first Int32
        (arena-first-child a node)
        (if-stmt (== first (- 0 1))
          (return 0)
          (if-stmt (== (arena-kind a first) (node-kind-atom))
            (return (string-eq (arena-value a first) head))
            (return 0)
          ) ;; if-stmt
        ) ;; if-stmt
      ) ;; let first
      (return 0)
    ) ;; if-stmt
  ) ;; body
  (tests
    (test is-list-with-head-true
      (doc "should return 1 for matching list")
      (tags unit util-lists)
      (body
        (let a Arena (arena-new))
        (let list Int32 (arena-add-node (addr a) (node-kind-list) ""))
        (let head Int32 (arena-add-node (addr a) (node-kind-atom) "test"))
        (arena-set-first-child (addr a) list head)
        (let result Int32 (is-list-with-head (addr a) list "test"))
        (expect-eq result 1)
      )
    )
    (test is-list-with-head-false
      (doc "should return 0 for non-matching list")
      (tags unit util-lists)
      (body
        (let a Arena (arena-new))
        (let list Int32 (arena-add-node (addr a) (node-kind-list) ""))
        (let head Int32 (arena-add-node (addr a) (node-kind-atom) "test"))
        (arena-set-first-child (addr a) list head)
        (let result Int32 (is-list-with-head (addr a) list "other"))
        (expect-eq result 0)
      )
    )
  )
) ;; fn is-list-with-head

(fn count-children
  (doc "Return the number of children of a list node.")
  (params
    (a (ptr Arena))
    (list-node Int32)
  ) ;; params
  (returns Int32)
  (body (do
    (let count Int32 0)
    (let child Int32 (arena-first-child a list-node))
    (while (!= child (- 0 1))
      (do
        (set count (+ count 1))
        (set child (arena-next-sibling a child))
      )
    )
    (return count)
  )) ;; body
  (tests
    (test count-children-empty
      (doc "empty list should have 0 children")
      (tags unit util-lists)
      (body
        (let a Arena (arena-new))
        (let list Int32 (arena-add-node (addr a) (node-kind-list) ""))
        (let count Int32 (count-children (addr a) list))
        (expect-eq count 0)
      )
    )
    (test count-children-two
      (doc "list with two children should return 2")
      (tags unit util-lists)
      (body
        (let a Arena (arena-new))
        (let list Int32 (arena-add-node (addr a) (node-kind-list) ""))
        (let c1 Int32 (arena-add-node (addr a) (node-kind-atom) "a"))
        (let c2 Int32 (arena-add-node (addr a) (node-kind-atom) "b"))
        (arena-set-first-child (addr a) list c1)
        (arena-set-next-sibling (addr a) c1 c2)
        (let count Int32 (count-children (addr a) list))
        (expect-eq count 2)
      )
    )
  )
) ;; fn count-children

(fn second-child
  (doc "Return the second child of a list node (or -1).")
  (params
    (a (ptr Arena))
    (list-node Int32)
  ) ;; params
  (returns Int32)
  (body (do
    (let first Int32
      (arena-first-child a list-node)
      (if-stmt (== first (- 0 1))
        (return (- 0 1))
        (return (arena-next-sibling a first))
      ) ;; if-stmt
    ) ;; let first
  )) ;; body
  (tests
    (test second-child-exists
      (doc "should return second child when it exists")
      (tags unit util-lists)
      (body
        (let a Arena (arena-new))
        (let list Int32 (arena-add-node (addr a) (node-kind-list) ""))
        (let c1 Int32 (arena-add-node (addr a) (node-kind-atom) "a"))
        (let c2 Int32 (arena-add-node (addr a) (node-kind-atom) "b"))
        (arena-set-first-child (addr a) list c1)
        (arena-set-next-sibling (addr a) c1 c2)
        (let result Int32 (second-child (addr a) list))
        (expect-eq result c2)
      )
    )
  )
) ;; fn second-child

(fn third-child
  (doc "Return the third child of a list node (or -1).")
  (params
    (a (ptr Arena))
    (list-node Int32)
  ) ;; params
  (returns Int32)
  (body (do
    (let second Int32
      (second-child a list-node)
      (if-stmt (== second (- 0 1))
        (return (- 0 1))
        (return (arena-next-sibling a second))
      ) ;; if-stmt
    ) ;; let second
  )) ;; body
  (tests
    (test third-child-none
      (doc "should return -1 when only two children")
      (tags unit util-lists)
      (body
        (let a Arena (arena-new))
        (let list Int32 (arena-add-node (addr a) (node-kind-list) ""))
        (let c1 Int32 (arena-add-node (addr a) (node-kind-atom) "a"))
        (let c2 Int32 (arena-add-node (addr a) (node-kind-atom) "b"))
        (arena-set-first-child (addr a) list c1)
        (arena-set-next-sibling (addr a) c1 c2)
        (let result Int32 (third-child (addr a) list))
        (expect-eq result (- 0 1))
      )
    )
  )
) ;; fn third-child

(fn fourth-child
  (doc "Return the fourth child of a list node (or -1).")
  (params
    (a (ptr Arena))
    (list-node Int32)
  ) ;; params
  (returns Int32)
  (body (do
    (let third Int32
      (third-child a list-node)
      (if-stmt (== third (- 0 1))
        (return (- 0 1))
        (return (arena-next-sibling a third))
      ) ;; if-stmt
    ) ;; let third
  )) ;; body
  (tests
    (test fourth-child-none
      (doc "should return -1 when only two children")
      (tags unit util-lists)
      (body
        (let a Arena (arena-new))
        (let list Int32 (arena-add-node (addr a) (node-kind-list) ""))
        (let c1 Int32 (arena-add-node (addr a) (node-kind-atom) "a"))
        (arena-set-first-child (addr a) list c1)
        (let result Int32 (fourth-child (addr a) list))
        (expect-eq result (- 0 1))
      )
    )
  )
) ;; fn fourth-child

(fn fifth-child
  (doc "Return the fifth child of a list node (or -1).")
  (params
    (a (ptr Arena))
    (list-node Int32)
  ) ;; params
  (returns Int32)
  (body (do
    (let fourth Int32
      (fourth-child a list-node)
      (if-stmt (== fourth (- 0 1))
        (return (- 0 1))
        (return (arena-next-sibling a fourth))
      ) ;; if-stmt
    ) ;; let fourth
  )) ;; body
  (tests
    (test fifth-child-none
      (doc "should return -1 when only one child")
      (tags unit util-lists)
      (body
        (let a Arena (arena-new))
        (let list Int32 (arena-add-node (addr a) (node-kind-list) ""))
        (let c1 Int32 (arena-add-node (addr a) (node-kind-atom) "a"))
        (arena-set-first-child (addr a) list c1)
        (let result Int32 (fifth-child (addr a) list))
        (expect-eq result (- 0 1))
      )
    )
  )
) ;; fn fifth-child

(fn find-first-child-list
  (doc "Return the first child list whose head matches.")
  (params
    (a (ptr Arena))
    (list-node Int32)
    (head String)
  ) ;; params
  (returns Int32)
  (body
    (let child Int32
      (arena-first-child a list-node)
      (do
        (while (!= child (- 0 1))
          (do
            (if-stmt (is-list-with-head a child head)
              (return child)
              (set child (arena-next-sibling a child))
            ) ;; if-stmt
          ) ;; do
        ) ;; while
        (return (- 0 1))
      ) ;; do
    ) ;; let child
  ) ;; body
  (tests
    (test find-first-child-list-found
      (doc "should find matching child list")
      (tags unit util-lists)
      (body
        (let a Arena (arena-new))
        (let parent Int32 (arena-add-node (addr a) (node-kind-list) ""))
        (let child-list Int32 (arena-add-node (addr a) (node-kind-list) ""))
        (let child-head Int32 (arena-add-node (addr a) (node-kind-atom) "target"))
        (arena-set-first-child (addr a) parent child-list)
        (arena-set-first-child (addr a) child-list child-head)
        (let result Int32 (find-first-child-list (addr a) parent "target"))
        (expect-eq result child-list)
      )
    )
    (test find-first-child-list-not-found
      (doc "should return -1 when not found")
      (tags unit util-lists)
      (body
        (let a Arena (arena-new))
        (let parent Int32 (arena-add-node (addr a) (node-kind-list) ""))
        (let result Int32 (find-first-child-list (addr a) parent "notfound"))
        (expect-eq result (- 0 1))
      )
    )
  )
) ;; fn find-first-child-list
