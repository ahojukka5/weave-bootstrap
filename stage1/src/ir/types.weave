(module
  (name "stage1-ir-types")
  (doc "Type mapping and struct layout emission helpers used by IR generation.")

  (include "../string.weave")
  (include "../buffers.weave")
  (include "../arrays.weave")
  (include "./util.weave")

  (fn map-type-node
    (doc "Lower a type AST node into an LLVM spelling.")
    (params (a (ptr Arena)) (node Int32) (struct-names ArrayString)) (returns String)
    (body (do
      (if-stmt (== (arena-kind a node) (node-kind-atom))
        (do
          ;; Atom type: Int32, String, etc.
          (let name String (arena-value a node))
          (if-stmt (string-eq name "Int32") (return "i32") (do 0))
          (if-stmt (string-eq name "Int8") (return "i8") (do 0))
          (if-stmt (string-eq name "Int64") (return "i64") (do 0))
          (if-stmt (string-eq name "String") (return "i8*") (do 0))
          (if-stmt (string-eq name "Void") (return "void") (do 0))
          ;; Common aliases
          (if-stmt (string-eq name "ExitCode") (return "i32") (do 0))
          (if-stmt (string-eq name "Buffer") (return "i8*") (do 0))
          (if-stmt (string-eq name "ArrayString") (return "i8*") (do 0))
          (if-stmt (string-eq name "ArrayInt32") (return "i8*") (do 0))
          (if-stmt (string-eq name "NodeKind") (return "i32") (do 0))
          ;; Check for non-type identifiers that should not be treated as types
          (if-stmt (|| (|| (|| (string-eq name "program") (string-eq name "fn")) (string-eq name "entry")) (string-eq name "module"))
            (return "i32") ;; Fallback to i32 for non-type identifiers
            (do 0)
          )
          ;; Unknown atom - check if it's a declared struct type
          (if-stmt (== (array-str-contains struct-names name) 1)
            (do
              ;; Valid struct type - prefix with %
              (let b Buffer (buffer-new))
              (buffer-append-string b "%")
              (buffer-append-string b (sanitize-name name))
              (return (buffer-to-string b))
            )
            (do
              ;; Not a struct type - fallback to i32 (safer than generating invalid type)
              (return "i32")
            )
          )
        )
        (do
          ;; List type: (ptr T) or (struct Name)
          (let head Int32 (arena-first-child a node))
          (if-stmt (== head (- 0 1)) (return "void") (do 0))
          (let head-val String (arena-value a head))
          (if-stmt (string-eq head-val "ptr")
            (do
              ;; (ptr InnerType) -> mapped(InnerType)*
              (let inner Int32 (arena-next-sibling a head))
              (if-stmt (== inner (- 0 1)) (return "i8*") (do 0))
              (let mapped String (map-type-node a inner struct-names))
              (let b Buffer (buffer-new))
              (buffer-append-string b mapped)
              (buffer-append-string b "*")
              (return (buffer-to-string b))
            )
            (do 0)
          )
          (if-stmt (string-eq head-val "struct")
            (do
              ;; (struct Name) -> %Name
              (let name-node Int32 (arena-next-sibling a head))
              (if-stmt (== name-node (- 0 1)) (return "%unknown") (do 0))
              (let struct-name String (arena-value a name-node))
              (let b Buffer (buffer-new))
              (buffer-append-string b "%")
              (buffer-append-string b (sanitize-name struct-name))
              (return (buffer-to-string b))
            )
            (do 0)
          )
          ;; Unknown list form - default to i32 (should not happen for valid type nodes)
          (return "i32")
        )
      )
    )) ;; body
    (tests
      (test map-type-node-builtin-int32
        (doc "Int32 atom maps to i32")
        (tags unit ir types)
        (body
          (let a (ptr Arena) (arena-create 256))
          (let node Int32 (parse-string a "Int32"))
          (let result String (map-type-node a node (array-str-new)))
          (expect-eq (string-eq result "i32") 1)
        )
      )
      (test map-type-node-builtin-string
        (doc "String atom maps to i8*")
        (tags unit ir types)
        (body
          (let a (ptr Arena) (arena-create 256))
          (let node Int32 (parse-string a "String"))
          (let result String (map-type-node a node (array-str-new)))
          (expect-eq (string-eq result "i8*") 1)
        )
      )
      (test map-type-node-builtin-void
        (doc "Void atom maps to void")
        (tags unit ir types)
        (body
          (let a (ptr Arena) (arena-create 256))
          (let node Int32 (parse-string a "Void"))
          (let result String (map-type-node a node (array-str-new)))
          (expect-eq (string-eq result "void") 1)
        )
      )
      (test map-type-node-custom-type
        (doc "Declared struct type treated as struct with % prefix")
        (tags unit ir types)
        (body
          (let a (ptr Arena) (arena-create 256))
          (let node Int32 (parse-string a "MyStruct"))
          (let struct-names ArrayString (array-str-new))
          (array-str-append struct-names "MyStruct")
          (let result String (map-type-node a node struct-names))
          (expect-eq (string-eq result "%MyStruct") 1)
        )
      )
      (test map-type-node-unknown-type
        (doc "Unknown type not in struct-names falls back to i32")
        (tags unit ir types)
        (body
          (let a (ptr Arena) (arena-create 256))
          (let node Int32 (parse-string a "UnknownType"))
          (let struct-names ArrayString (array-str-new))
          (let result String (map-type-node a node struct-names))
          (expect-eq (string-eq result "i32") 1)
        )
      )
      (test map-type-node-program-identifier
        (doc "Non-type identifier 'program' falls back to i32")
        (tags unit ir types)
        (body
          (let a (ptr Arena) (arena-create 256))
          (let node Int32 (parse-string a "program"))
          (let struct-names ArrayString (array-str-new))
          (let result String (map-type-node a node struct-names))
          (expect-eq (string-eq result "i32") 1)
        )
      )
      (test map-type-node-ptr-int32
        (doc "Pointer to Int32 maps to i32*")
        (tags unit ir types)
        (body
          (let a (ptr Arena) (arena-create 256))
          (let node Int32 (parse-string a "(ptr Int32)"))
          (let result String (map-type-node a node (array-str-new)))
          (expect-eq (string-eq result "i32*") 1)
        )
      )
      (test map-type-node-ptr-ptr-int32
        (doc "Nested pointer maps to i32**")
        (tags unit ir types)
        (body
          (let a (ptr Arena) (arena-create 256))
          (let node Int32 (parse-string a "(ptr (ptr Int32))"))
          (let result String (map-type-node a node (array-str-new)))
          (expect-eq (string-eq result "i32**") 1)
        )
      )
      (test map-type-node-struct-form
        (doc "Struct form maps to %Name")
        (tags unit ir types)
        (body
          (let a (ptr Arena) (arena-create 256))
          (let node Int32 (parse-string a "(struct Arena)"))
          (let result String (map-type-node a node (array-str-new)))
          (expect-eq (string-eq result "%Arena") 1)
        )
      )
      (test map-type-node-ptr-struct
        (doc "Pointer to struct maps to %Struct*")
        (tags unit ir types)
        (body
          (let a (ptr Arena) (arena-create 256))
          (let node Int32 (parse-string a "(ptr (struct Node))"))
          (let result String (map-type-node a node (array-str-new)))
          (expect-eq (string-eq result "%Node*") 1)
        )
      )
    )
  ) ;; fn map-type-node

  (fn emit-type-node
    (doc "Append the mapped type from an AST node to the buffer.")
    (params (out Buffer) (a (ptr Arena)) (node Int32) (struct-names ArrayString)) (returns Int32)
    (body (do
      (buffer-append-string out (map-type-node a node struct-names))
      (return 0)
    )) ;; body
    (tests
      (test emit-type-node-basic
        (doc "Emits mapped type to buffer")
        (tags unit ir types)
        (body
          (let a (ptr Arena) (arena-create 256))
          (let node Int32 (parse-string a "Int32"))
          (let buf Buffer (buffer-new))
          (emit-type-node buf a node (array-str-new))
          (let result String (buffer-to-string buf))
          (expect-eq (string-eq result "i32") 1)
        )
      )
      (test emit-type-node-pointer
        (doc "Emits pointer type to buffer")
        (tags unit ir types)
        (body
          (let a (ptr Arena) (arena-create 256))
          (let node Int32 (parse-string a "(ptr String)"))
          (let buf Buffer (buffer-new))
          (emit-type-node buf a node (array-str-new))
          (let result String (buffer-to-string buf))
          (expect-eq (string-eq result "i8**") 1)
        )
      )
    )
  ) ;; fn emit-type-node

  (fn emit-pointer-type-node
    (doc "Append mapped pointer type from AST node (adds a trailing *).")
    (params (out Buffer) (a (ptr Arena)) (node Int32) (struct-names ArrayString)) (returns Int32)
    (body (do
      (emit-type-node out a node struct-names)
      (buffer-append-string out "*")
      (return 0)
    )) ;; body
    (tests
      (test emit-pointer-type-node-basic
        (doc "Adds * to type emission")
        (tags unit ir types)
        (body
          (let a (ptr Arena) (arena-create 256))
          (let node Int32 (parse-string a "Int32"))
          (let buf Buffer (buffer-new))
          (emit-pointer-type-node buf a node (array-str-new))
          (let result String (buffer-to-string buf))
          (expect-eq (string-eq result "i32*") 1)
        )
      )
      (test emit-pointer-type-node-already-pointer
        (doc "Adds * to existing pointer type")
        (tags unit ir types)
        (body
          (let a (ptr Arena) (arena-create 256))
          (let node Int32 (parse-string a "(ptr Int32)"))
          (let buf Buffer (buffer-new))
          (emit-pointer-type-node buf a node (array-str-new))
          (let result String (buffer-to-string buf))
          (expect-eq (string-eq result "i32**") 1)
        )
      )
    )
  ) ;; fn emit-pointer-type-node

  (fn map-simple-type-name
    (doc "Map simple atom type names to LLVM (for struct field emission only).")
    (params (name String)) (returns String)
    (body (do
      (if-stmt (string-eq name "Int32") (return "i32") (do 0))
      (if-stmt (string-eq name "Int8") (return "i8") (do 0))
      (if-stmt (string-eq name "Int64") (return "i64") (do 0))
      (if-stmt (string-eq name "String") (return "i8*") (do 0))
      (if-stmt (string-eq name "Void") (return "void") (do 0))
      (if-stmt (string-eq name "Buffer") (return "i8*") (do 0))
      (if-stmt (string-eq name "ArrayString") (return "i8*") (do 0))
      (if-stmt (string-eq name "ArrayInt32") (return "i8*") (do 0))
      (if-stmt (string-eq name "Arena") (return "i8*") (do 0))
      (if-stmt (string-eq name "NodeKind") (return "i32") (do 0))
      ;; Check for non-type identifiers that should not be treated as types
      (if-stmt (|| (|| (|| (string-eq name "program") (string-eq name "fn")) (string-eq name "entry")) (string-eq name "module"))
        (return "i32") ;; Fallback to i32 for non-type identifiers
        (do 0)
      )
      ;; User-defined struct type - return as %Name
      (let b Buffer (buffer-new))
      (buffer-append-string b "%")
      (buffer-append-string b (sanitize-name name))
      (return (buffer-to-string b))
    )) ;; body
    (tests
      (test map-simple-type-name-int32
        (doc "Int32 maps to i32")
        (tags unit ir types)
        (body
          (let result String (map-simple-type-name "Int32"))
          (expect-eq (string-eq result "i32") 1)
        )
      )
      (test map-simple-type-name-string
        (doc "String maps to i8*")
        (tags unit ir types)
        (body
          (let result String (map-simple-type-name "String"))
          (expect-eq (string-eq result "i8*") 1)
        )
      )
      (test map-simple-type-name-custom
        (doc "Unknown type gets % prefix")
        (tags unit ir types)
        (body
          (let result String (map-simple-type-name "CustomType"))
          (expect-eq (string-eq result "%CustomType") 1)
        )
      )
    )
  ) ;; fn map-simple-type-name

  (fn emit-struct-defs
    (doc "Emit `%Name = type { ... }` for collected struct declarations.")
    (params (out Buffer) (names ArrayString) (fields ArrayString)) (returns Int32)
    (body (do
      (let i Int32 0)
      (while (< i (array-str-len names))
        (do
          (let n String (array-str-get names i))
          (let fl String (array-str-get fields i))
          (buffer-append-string out "%")
          (buffer-append-string out (sanitize-name n))
          (buffer-append-string out " = type { ")
          (let j Int32 0)
          (let start Int32 0)
          (let len Int32 (string-length fl))
          (let first Int32 1)
          (while (<= j len)
            (do
              (if-stmt (|| (== j len) (== (string-char-at fl j) 44))
                (do
                  (if-stmt (> j start)
                    (do
                      (let entry String (string-slice fl start (- j start)))
                      ;; entry is "fieldname:Type", extract the Type part after colon
                      (let entry-len Int32 (string-length entry))
                      (let colon-pos Int32 (- 0 1))
                      (let ci Int32 0)
                      (while (< ci entry-len)
                        (do
                          (if-stmt (== (string-char-at entry ci) 58) ;; ':'
                            (do
                              (set colon-pos ci)
                              (set ci entry-len) ;; break
                            )
                            (set ci (+ ci 1))
                          )
                        )
                      )
                      (let ty String entry)
                      (if-stmt (>= colon-pos 0)
                        (set ty (string-slice entry (+ colon-pos 1) (- entry-len (+ colon-pos 1))))
                        (do 0)
                      )
                      (if-stmt (== first 0) (buffer-append-string out ", ") (do 0))
                      (buffer-append-string out (map-simple-type-name ty))
                      (set first 0)
                    )
                    (do 0)
                  ) ;; if-stmt
                  (set start (+ j 1))
                )
                (do 0)
              ) ;; if-stmt
              (set j (+ j 1))
            ) ;; while
          ) ;; while
          (buffer-append-string out " }\n")
          (set i (+ i 1))
        ) ;; do
      ) ;; while
      (return 0)
    )) ;; body
    (tests
      (test emit-struct-defs-single
        (doc "Emits single struct definition")
        (tags unit ir types)
        (body
          (let buf Buffer (buffer-new))
          (let names ArrayString (array-str-new))
          (let fields ArrayString (array-str-new))
          (array-str-append names "Point")
          (array-str-append fields "x:Int32,y:Int32")
          (emit-struct-defs buf names fields)
          (let result String (buffer-to-string buf))
          (expect-eq (string-starts-with result "%Point = type { ") 1)
        )
      )
      (test emit-struct-defs-empty
        (doc "Empty arrays produce no output")
        (tags unit ir types)
        (body
          (let buf Buffer (buffer-new))
          (let names ArrayString (array-str-new))
          (let fields ArrayString (array-str-new))
          (emit-struct-defs buf names fields)
          (let result String (buffer-to-string buf))
          (expect-eq (string-eq result "") 1)
        )
      )
    )
  ) ;; fn emit-struct-defs
) ;; module
