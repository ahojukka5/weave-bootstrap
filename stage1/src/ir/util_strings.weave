(fn sanitize-name
  (doc "Replace '-' with '_' and default empty to v0.")
  (params
    (name String)
  ) ;; params
  (returns String)
  (body (do
    (if-stmt (== (string-length name) 0)
      (return "v0")
      (do 0)
    ) ;; if-stmt
    ;; Replace '-' with '_'; keep the rest as-is for now.
    (let b Buffer (buffer-new))
    (let i Int32 0)
    (while (< i (string-length name))
      (do
        (let ch Int32 (string-char-at name i))
        (if-stmt (== ch 45) ;; '-'
          (buffer-append-byte b 95) ;; '_'
          (buffer-append-byte b ch)
        ) ;; if-stmt
        (set i (+ i 1))
      ) ;; do
    ) ;; while
    (return (buffer-to-string b))
  )) ;; body
  (tests
    (test sanitize-name-empty
      (doc "empty string should become v0")
      (tags unit util-strings)
      (body
        (let result String (sanitize-name ""))
        (let eq Int32 (string-eq result "v0"))
        (expect-eq eq 1)
      )
    )
    (test sanitize-name-hyphen
      (doc "hyphens should become underscores")
      (tags unit util-strings)
      (body
        (let result String (sanitize-name "foo-bar"))
        (let eq Int32 (string-eq result "foo_bar"))
        (expect-eq eq 1)
      )
    )
    (test sanitize-name-no-change
      (doc "names without hyphens stay unchanged")
      (tags unit util-strings)
      (body
        (let result String (sanitize-name "foobar"))
        (let eq Int32 (string-eq result "foobar"))
        (expect-eq eq 1)
      )
    )
  )
) ;; fn sanitize-name

(fn array-str-contains
  (doc "Return 1 if value exists in items.")
  (params
    (items ArrayString)
    (value String)
  ) ;; params
  (returns Int32)
  (body (do
    (let i Int32 0)
    (while (< i (array-str-len items))
      (do
        (if-stmt (string-eq (array-str-get items i) value)
          (return 1)
          (set i (+ i 1))
        ) ;; if-stmt
      ) ;; do
    ) ;; while
    (return 0)
  )) ;; body
  (tests
    (test array-str-contains-found
      (doc "should find existing element")
      (tags unit util-strings)
      (body
        (let arr ArrayString (array-str-new))
        (array-str-append arr "foo")
        (array-str-append arr "bar")
        (let result Int32 (array-str-contains arr "bar"))
        (expect-eq result 1)
      )
    )
    (test array-str-contains-not-found
      (doc "should return 0 for non-existing element")
      (tags unit util-strings)
      (body
        (let arr ArrayString (array-str-new))
        (array-str-append arr "foo")
        (let result Int32 (array-str-contains arr "bar"))
        (expect-eq result 0)
      )
    )
  )
) ;; fn array-str-contains

(fn string-starts-with
  (doc "Return 1 if s starts with prefix.")
  (params
    (s String)
    (prefix String)
  ) ;; params
  (returns Int32)
  (body (do
    (let len Int32 (string-length s))
    (let plen Int32 (string-length prefix))
    (if-stmt (< len plen)
      (return 0)
      (do
        (return (string-eq (string-slice s 0 plen) prefix))
      ) ;; do
    ) ;; if-stmt
  )) ;; body
  (tests
    (test string-starts-with-true
      (doc "should return 1 when string starts with prefix")
      (tags unit util-strings)
      (body
        (let result Int32 (string-starts-with "hello world" "hello"))
        (expect-eq result 1)
      )
    )
    (test string-starts-with-false
      (doc "should return 0 when string does not start with prefix")
      (tags unit util-strings)
      (body
        (let result Int32 (string-starts-with "hello world" "world"))
        (expect-eq result 0)
      )
    )
    (test string-starts-with-too-short
      (doc "should return 0 when string shorter than prefix")
      (tags unit util-strings)
      (body
        (let result Int32 (string-starts-with "hi" "hello"))
        (expect-eq result 0)
      )
    )
  )
) ;; fn string-starts-with

(fn string-ends-with
  (doc "Return 1 if s ends with suffix.")
  (params
    (s String)
    (suffix String)
  ) ;; params
  (returns Int32)
  (body (do
    (let len Int32 (string-length s))
    (let slen Int32 (string-length suffix))
    (if-stmt (< len slen)
      (return 0)
      (do
        (return (string-eq (string-slice s (- len slen) slen) suffix))
      ) ;; do
    ) ;; if-stmt
  )) ;; body
  (tests
    (test string-ends-with-true
      (doc "should return 1 when string ends with suffix")
      (tags unit util-strings)
      (body
        (let result Int32 (string-ends-with "hello.weave" ".weave"))
        (expect-eq result 1)
      )
    )
    (test string-ends-with-false
      (doc "should return 0 when string does not end with suffix")
      (tags unit util-strings)
      (body
        (let result Int32 (string-ends-with "hello.txt" ".weave"))
        (expect-eq result 0)
      )
    )
  )
) ;; fn string-ends-with

(fn is-string-literal
  (doc "Return 1 if s is encoded as a string literal (strlit: prefix).")
  (params
    (s String)
  ) ;; params
  (returns Int32)
  (body (return (string-starts-with s "strlit:")))
  (tests
    (test is-string-literal-true
      (doc "should return 1 for strlit: prefix")
      (tags unit util-strings)
      (body
        (let result Int32 (is-string-literal "strlit:hello"))
        (expect-eq result 1)
      )
    )
    (test is-string-literal-false
      (doc "should return 0 for non-literal")
      (tags unit util-strings)
      (body
        (let result Int32 (is-string-literal "hello"))
        (expect-eq result 0)
      )
    )
  )
) ;; fn is-string-literal

(fn string-literal-value
  (doc "Strip the strlit: prefix from a literal value.")
  (params
    (s String)
  ) ;; params
  (returns String)
  (body
    (return (string-slice s 7 (- (string-length s) 7)))
  ) ;; body
  (tests
    (test string-literal-value-simple
      (doc "should strip strlit: prefix")
      (tags unit util-strings)
      (body
        (let result String (string-literal-value "strlit:hello"))
        (let eq Int32 (string-eq result "hello"))
        (expect-eq eq 1)
      )
    )
  )
) ;; fn string-literal-value

(fn is-number-string
  (doc "Return 1 if s is an optional sign followed by digits.")
  (params
    (s String)
  ) ;; params
  (returns Int32)
  (body (do
    (let len Int32 (string-length s))
    (if-stmt (== len 0)
      (return 0)
      (do 0)
    )
    (let i Int32 0)
    ;; Optional leading sign
    (let first Int32 (string-char-at s 0))
    (if-stmt (|| (== first 45) (== first 43))
      (set i 1)
      (do 0)
    )
    (if-stmt (>= i len)
      (return 0)
      (do 0)
    )
    (let ok Int32 1)
    (while (< i len)
      (do
        (let ch Int32 (string-char-at s i))
        (if-stmt (&& (>= ch 48) (<= ch 57))
          (do 0)
          (set ok 0)
        )
        (set i (+ i 1))
      )
    )
    (return ok)
  )) ;; body
  (tests
    (test is-number-string-positive
      (doc "positive number should return 1")
      (tags unit util-strings)
      (body
        (let result Int32 (is-number-string "123"))
        (expect-eq result 1)
      )
    )
    (test is-number-string-negative
      (doc "negative number should return 1")
      (tags unit util-strings)
      (body
        (let result Int32 (is-number-string "-42"))
        (expect-eq result 1)
      )
    )
    (test is-number-string-not-number
      (doc "non-number should return 0")
      (tags unit util-strings)
      (body
        (let result Int32 (is-number-string "abc"))
        (expect-eq result 0)
      )
    )
    (test is-number-string-empty
      (doc "empty string should return 0")
      (tags unit util-strings)
      (body
        (let result Int32 (is-number-string ""))
        (expect-eq result 0)
      )
    )
  )
) ;; fn is-number-string

(fn escape-llvm-string
  (doc "Escape a string for LLVM IR string literals. Returns escaped string and byte count.")
  (params
    (s String)
    (out-len (ptr Int32))
  ) ;; params
  (returns String)
  (body
    (let buf Buffer (buffer-new))
    (let len Int32 (string-length s))
    (let byte-count Int32 0)
    (let i Int32 0)
    (while (< i len)
      (do
        (let ch Int32 (string-char-at s i))
        (if-stmt (== ch 92) ;; backslash
          (do
            (buffer-append-string buf "\\5C")
            (set byte-count (+ byte-count 1))
          )
          (if-stmt (== ch 34) ;; double quote
            (do
              (buffer-append-string buf "\\22")
              (set byte-count (+ byte-count 1))
            )
            (if-stmt (== ch 10) ;; newline
              (do
                (buffer-append-string buf "\\0A")
                (set byte-count (+ byte-count 1))
              )
              (if-stmt (== ch 13) ;; carriage return
                (do
                  (buffer-append-string buf "\\0D")
                  (set byte-count (+ byte-count 1))
                )
                (if-stmt (|| (< ch 32) (> ch 126)) ;; non-printable
                  (do
                    ;; Convert to hex escape
                    (let hex-chars String "0123456789ABCDEF")
                    (let hi Int32 (/ ch 16))
                    (let lo Int32 (- ch (* hi 16)))
                    (buffer-append-string buf "\\")
                    (buffer-append-byte buf (string-char-at hex-chars hi))
                    (buffer-append-byte buf (string-char-at hex-chars lo))
                    (set byte-count (+ byte-count 1))
                  )
                  (do
                    ;; Regular printable character
                    (buffer-append-byte buf ch)
                    (set byte-count (+ byte-count 1))
                  )
                )
              )
            )
          )
        )
        (set i (+ i 1))
      )
    )
    (store Int32 out-len byte-count)
    (return (buffer-to-string buf))
  ) ;; body
  (tests
    (test escape-llvm-string-simple
      (doc "simple string should not change much")
      (tags unit util-strings)
      (body
        (let len Int32 0)
        (let result String (escape-llvm-string "abc" (addr len)))
        (expect-eq len 3)
      )
    )
    (test escape-llvm-string-newline
      (doc "newline should be escaped")
      (tags unit util-strings)
      (body
        (let len Int32 0)
        (let result String (escape-llvm-string "a\nb" (addr len)))
        (expect-eq len 3)
      )
    )
  )
) ;; fn escape-llvm-string
