(fn is-list-with-head (doc "Return 1 if node is a list whose first atom equals head.") (params (a (ptr Arena)) (node Int32) (head String)) (returns Int32)
  (body (do
    (let result Int32 0)
    (if-stmt (== (arena-kind a node) (node-kind-list))
      (do
        (let first Int32 (arena-first-child a node))
        (if-stmt (== first (- 0 1))
          (set result 0)
          (if-stmt (== (arena-kind a first) (node-kind-atom))
            (set result (string-eq (arena-value a first) head))
            (set result 0)
          )
        )
      )
      (set result 0)
    )
    (return result)
  ))
  (tests
    (test is-list-with-head-cases
      (doc "matches list head atom; non-list and empty list return 0")
      (tags unit ir)
      (body
        (let a (ptr Arena) (arena-new))
        (let list Int32 (arena-add-node a (node-kind-list) ""))
        (let head Int32 (arena-add-node a (node-kind-atom) "foo"))
        (arena-set-first-child a list head)
        (expect-eq (is-list-with-head a list "foo") 1)
        (expect-eq (is-list-with-head a list "bar") 0)
        (let atom Int32 (arena-add-node a (node-kind-atom) "x"))
        (expect-eq (is-list-with-head a atom "x") 0)
        (let empty Int32 (arena-add-node a (node-kind-list) ""))
        (expect-eq (is-list-with-head a empty "foo") 0)
      )
    )
  )
)

(fn count-children (doc "Return the number of children of a list node.") (params (a (ptr Arena)) (list-node Int32)) (returns Int32)
  (body (do (let count Int32 0) (let child Int32 (arena-first-child a list-node))
    (while (!= child (- 0 1)) (do (set count (+ count 1)) (set child (arena-next-sibling a child)))) (return count)))
  (tests
    (test count-children-basic
      (doc "counts all children including head")
      (tags unit ir)
      (body
        (let a (ptr Arena) (arena-new))
        (let list Int32 (arena-add-node a (node-kind-list) ""))
        (let h Int32 (arena-add-node a (node-kind-atom) "a"))
        (let c1 Int32 (arena-add-node a (node-kind-atom) "b"))
        (let c2 Int32 (arena-add-node a (node-kind-atom) "c"))
        (arena-set-first-child a list h)
        (arena-set-next-sibling a h c1)
        (arena-set-next-sibling a c1 c2)
        (expect-eq (count-children a list) 3)
      )
    )
  )
)

(fn second-child (doc "Return the second child of a list node (or -1).") (params (a (ptr Arena)) (list-node Int32)) (returns Int32)
  (body (do (let first Int32 (arena-first-child a list-node)
    (if-stmt (== first (- 0 1)) (return (- 0 1)) (return (arena-next-sibling a first)))
  )))
  (tests
    (test second-child-cases
      (doc "returns -1 when missing, otherwise the next sibling")
      (tags unit ir)
      (body
        (let a (ptr Arena) (arena-new))
        (let list Int32 (arena-add-node a (node-kind-list) ""))
        (let h Int32 (arena-add-node a (node-kind-atom) "a"))
        (arena-set-first-child a list h)
        (expect-eq (second-child a list) (- 0 1))
        (let c1 Int32 (arena-add-node a (node-kind-atom) "b"))
        (arena-set-next-sibling a h c1)
        (expect-eq (second-child a list) c1)
      )
    )
  )
)

(fn third-child (doc "Return the third child of a list node (or -1).") (params (a (ptr Arena)) (list-node Int32)) (returns Int32)
  (body (do (let second Int32 (second-child a list-node)
    (if-stmt (== second (- 0 1)) (return (- 0 1)) (return (arena-next-sibling a second)))
  )))
  (tests
    (test third-child-cases
      (doc "returns -1 when missing, otherwise the third child")
      (tags unit ir)
      (body
        (let a (ptr Arena) (arena-new))
        (let list Int32 (arena-add-node a (node-kind-list) ""))
        (let h Int32 (arena-add-node a (node-kind-atom) "a"))
        (let c1 Int32 (arena-add-node a (node-kind-atom) "b"))
        (let c2 Int32 (arena-add-node a (node-kind-atom) "c"))
        (arena-set-first-child a list h)
        (arena-set-next-sibling a h c1)
        (expect-eq (third-child a list) (- 0 1))
        (arena-set-next-sibling a c1 c2)
        (expect-eq (third-child a list) c2)
      )
    )
  )
)

(fn fourth-child (doc "Return the fourth child of a list node (or -1).") (params (a (ptr Arena)) (list-node Int32)) (returns Int32)
  (body (do (let third Int32 (third-child a list-node)
    (if-stmt (== third (- 0 1)) (return (- 0 1)) (return (arena-next-sibling a third)))
  )))
  (tests
    (test fourth-child-cases
      (doc "returns fourth child when present, else -1")
      (tags unit ir)
      (body
        (let a (ptr Arena) (arena-new))
        (let list Int32 (arena-add-node a (node-kind-list) ""))
        (let h Int32 (arena-add-node a (node-kind-atom) "a"))
        (let c1 Int32 (arena-add-node a (node-kind-atom) "b"))
        (let c2 Int32 (arena-add-node a (node-kind-atom) "c"))
        (let c3 Int32 (arena-add-node a (node-kind-atom) "d"))
        (arena-set-first-child a list h)
        (arena-set-next-sibling a h c1)
        (arena-set-next-sibling a c1 c2)
        (expect-eq (fourth-child a list) (- 0 1))
        (arena-set-next-sibling a c2 c3)
        (expect-eq (fourth-child a list) c3)
      )
    )
  )
)

(fn fifth-child (doc "Return the fifth child of a list node (or -1).") (params (a (ptr Arena)) (list-node Int32)) (returns Int32)
  (body (do (let fourth Int32 (fourth-child a list-node)
    (if-stmt (== fourth (- 0 1)) (return (- 0 1)) (return (arena-next-sibling a fourth)))
  )))
  (tests
    (test fifth-child-cases
      (doc "returns fifth child when present, else -1")
      (tags unit ir)
      (body
        (let a (ptr Arena) (arena-new))
        (let list Int32 (arena-add-node a (node-kind-list) ""))
        (let h Int32 (arena-add-node a (node-kind-atom) "a"))
        (let c1 Int32 (arena-add-node a (node-kind-atom) "b"))
        (let c2 Int32 (arena-add-node a (node-kind-atom) "c"))
        (let c3 Int32 (arena-add-node a (node-kind-atom) "d"))
        (let c4 Int32 (arena-add-node a (node-kind-atom) "e"))
        (arena-set-first-child a list h)
        (arena-set-next-sibling a h c1)
        (arena-set-next-sibling a c1 c2)
        (arena-set-next-sibling a c2 c3)
        (expect-eq (fifth-child a list) (- 0 1))
        (arena-set-next-sibling a c3 c4)
        (expect-eq (fifth-child a list) c4)
      )
    )
  )
)

(fn find-first-child-list (doc "Return the first child list whose head matches.") (params (a (ptr Arena)) (list-node Int32) (head String)) (returns Int32)
  (body (let child Int32 (arena-first-child a list-node) (do
    (while (!= child (- 0 1)) (do (if-stmt (is-list-with-head a child head) (return child) (set child (arena-next-sibling a child)))))
    (return (- 0 1))
  )))
  (tests
    (test find-first-child-list-basic
      (doc "returns first matching child list or -1 if none")
      (tags unit ir)
      (body
        (let a (ptr Arena) (arena-new))
        (let parent Int32 (arena-add-node a (node-kind-list) ""))
        (let atom Int32 (arena-add-node a (node-kind-atom) "x"))
        (let list1 Int32 (arena-add-node a (node-kind-list) ""))
        (let h1 Int32 (arena-add-node a (node-kind-atom) "a"))
        (let list2 Int32 (arena-add-node a (node-kind-list) ""))
        (let h2 Int32 (arena-add-node a (node-kind-atom) "b"))
        (arena-set-first-child a parent atom)
        (arena-set-next-sibling a atom list1)
        (arena-set-first-child a list1 h1)
        (arena-set-next-sibling a list1 list2)
        (arena-set-first-child a list2 h2)
        (expect-eq (find-first-child-list a parent "b") list2)
        (expect-eq (find-first-child-list a parent "c") (- 0 1))
      )
    )
  )
)
