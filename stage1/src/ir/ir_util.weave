;; Utility functions for IR generation

  (fn dedupe-lines
    (doc "Remove duplicate lines from a buffer, preserving first occurrences.")
    (params (buf Buffer))
    (returns Buffer)
    (body
      (let src String (buffer-to-string buf))
      (let out Buffer (buffer-new))
      (let seen ArrayString (array-str-new))
      (let start Int32 0)
      (let i Int32 0)
      (let len Int32 (string-length src))
      (while (<= i len)
        (do
          (if-stmt (|| (== i len) (== (string-char-at src i) 10))
            (do
              (let line String (string-slice src start (- i start)))
              (if-stmt (&& (> (string-length line) 0) (== (array-str-contains seen line) 0))
                (do
                  (array-str-append seen line)
                  (buffer-append-string out line)
                  (buffer-append-string out "\n")
                )
                (do 0)
              )
              (set start (+ i 1))
            )
            (do 0)
          )
          (set i (+ i 1))
        )
      )
      (return out)
    )
    (tests
      (test dedupe-none
        (doc "Test buffer with no duplicates")
        (tags unit)
        (body
          (let buf Buffer (buffer-create 64))
          (buffer-append-string buf "line1\n")
          (buffer-append-string buf "line2\n")
          (let result Buffer (dedupe-lines buf))
          (expect-true (> (string-length (buffer-to-string result)) 0))))
      (test dedupe-duplicates
        (doc "Test buffer with duplicate lines")
        (tags unit)
        (body
          (let buf Buffer (buffer-create 64))
          (buffer-append-string buf "same\n")
          (buffer-append-string buf "same\n")
          (let result Buffer (dedupe-lines buf))
          (let result-str String (buffer-to-string result))
          (expect-true (> (string-length result-str) 0)))))
  )

  (fn collect-fn-sigs-from-module
    (doc "Recursively collect fn signatures from a module node. If namespace-prefix is non-empty, functions are stored as 'namespace::function'.")
    (params
      (a (ptr Arena))
      (module-node Int32)
      (fn-sig-names ArrayString)
      (fn-sig-ret-types ArrayInt32)
      (namespace-prefix String)
    )
    (returns Int32)
    (body (do
      ;; Start with the provided prefix - we'll update it when we find namespace blocks
      (let current-prefix String namespace-prefix)
      (let child Int32 (arena-first-child a module-node))
      (while (!= child (- 0 1))
        (do
          ;; Check if this is a namespace block - if so, recurse into it
          ;; Namespace blocks have structure: (namespace "name" (decl1) (decl2) ...)
          (if-stmt (is-list-with-head a child "namespace")
            (do
              (let ns-name-node Int32 (second-child a child))
              (if-stmt (== ns-name-node (- 0 1))
                (do 0) ;; No namespace name, skip
                (do
                  (let ns-name String (arena-value a ns-name-node))
                  (let ns-prefix String current-prefix)
                  (if-stmt (!= (string-length current-prefix) 0)
                    (set ns-prefix (string-concat current-prefix (string-concat "::" ns-name)))
                    (set ns-prefix ns-name)
                  )
                  ;; Recurse into namespace block with updated prefix
                  (let ns-child Int32 (arena-next-sibling a ns-name-node))
                  (while (!= ns-child (- 0 1))
                    (do
                      (if-stmt (is-list-with-head a ns-child "fn")
                        (do
                          (let name-node Int32 (second-child a ns-child))
                          (let fn-name String (arena-value a name-node))
                          (let sib Int32 (arena-next-sibling a name-node))
                          (if-stmt (is-list-with-head a sib "doc")
                            (set sib (arena-next-sibling a sib)) (do 0))
                          (if-stmt (is-list-with-head a sib "params")
                            (set sib (arena-next-sibling a sib)) (do 0))
                          (if-stmt (is-list-with-head a sib "returns")
                            (do
                              (let ret-type Int32 (second-child a sib))
                              (let qualified-name String fn-name)
                              (if-stmt (!= (string-length ns-prefix) 0)
                                (set qualified-name (string-concat ns-prefix (string-concat "::" fn-name)))
                                (do 0)
                              )
                              ;; Register both qualified and unqualified names for lookup
                              (if-stmt (!= (string-length ns-prefix) 0)
                                (do
                                  (array-str-append fn-sig-names qualified-name)
                                  (array-i32-append fn-sig-ret-types ret-type)
                                )
                                (do 0)
                              )
                              ;; Also register unqualified name for direct access (always)
                              (array-str-append fn-sig-names fn-name)
                              (array-i32-append fn-sig-ret-types ret-type)
                            )
                            (do 0)
                          )
                        )
                        (do 0)
                      )
                      ;; Also handle nested namespaces and includes
                      (if-stmt (is-list-with-head a ns-child "namespace")
                        (do
                          (collect-fn-sigs-from-module a ns-child fn-sig-names fn-sig-ret-types ns-prefix)
                        )
                        (do 0)
                      )
                      ;; Handle includes inside namespace blocks
                      (if-stmt (is-list-with-head a ns-child "include")
                        (do 0) ;; Includes are handled during expansion, skip here
                        (do 0)
                      )
                      (set ns-child (arena-next-sibling a ns-child))
                    )
                  )
                )
              )
            )
            (do 0)
          )
          (if-stmt (is-list-with-head a child "fn")
            (do
              (let name-node Int32 (second-child a child))
              (let fn-name String (arena-value a name-node))
              (let sib Int32 (arena-next-sibling a name-node))
              (if-stmt (is-list-with-head a sib "doc")
                (set sib (arena-next-sibling a sib)) (do 0))
              (if-stmt (is-list-with-head a sib "params")
                (set sib (arena-next-sibling a sib)) (do 0))
              (if-stmt (is-list-with-head a sib "returns")
                (do
                  (let ret-type Int32 (second-child a sib))
                  (let qualified-name String fn-name)
                  (if-stmt (!= (string-length current-prefix) 0)
                    (set qualified-name (string-concat current-prefix (string-concat "::" fn-name)))
                    (do 0)
                  )
                  (array-str-append fn-sig-names qualified-name)
                  (array-i32-append fn-sig-ret-types ret-type)
                )
                (do 0)
              )
            )
            (do 0)
          )
          (if-stmt (is-list-with-head a child "entry")
            (do
              (array-str-append fn-sig-names "main")
              (array-i32-append fn-sig-ret-types (- 0 1))
            )
            (do 0)
          )
          ;; Recursively scan nested modules
          (if-stmt (is-list-with-head a child "module")
            (do
              (collect-fn-sigs-from-module a child fn-sig-names
                fn-sig-ret-types current-prefix)
            )
            (do 0)
          )
          (set child (arena-next-sibling a child))
        )
      )
      (return 0)
    ))
    (tests
      (test collect-from-module-empty
        (doc "Test collecting from empty module")
        (tags unit)
        (body
          (let a (ptr Arena) (arena-create 4096))
          (let root Int32 (parser::parse-string a "(module (name \"test\"))"))
          (let names ArrayString (array-string-create))
          (let types ArrayInt32 (array-int32-create))
          (collect-fn-sigs-from-module a root names types "")
          (expect-eq (array-str-len names) 0)
        )
      )
      (test collect-from-module-with-namespace-block
        (doc "Test collecting function from module with namespace block")
        (tags unit)
        (body
          (let a (ptr Arena) (arena-create 4096))
          (let root Int32 (parser::parse-string a "(module (name \"test\") (namespace \"io\" (fn test-fn (params ()) (returns String) (body \"hello\"))))"))
          (let names ArrayString (array-string-create))
          (let types ArrayInt32 (array-int32-create))
          (collect-fn-sigs-from-module a root names types "")
          ;; Should find both qualified and unqualified names
          (expect-eq (array-str-len names) 2)
          (expect-true (|| (string-eq (array-str-get names 0) "io::test-fn") (string-eq (array-str-get names 0) "test-fn")))
          (expect-true (|| (string-eq (array-str-get names 1) "io::test-fn") (string-eq (array-str-get names 1) "test-fn")))
        )
      )
      (test collect-from-module-namespace-detection
        (doc "Test that namespace blocks are detected in modules")
        (tags unit)
        (body
          (let a (ptr Arena) (arena-create 4096))
          (let root Int32 (parser::parse-string a "(module (name \"test\") (namespace \"io\" (fn fn1 (params ()) (returns Int32) (body 0)) (fn fn2 (params ()) (returns String) (body \"\"))))"))
          (let names ArrayString (array-string-create))
          (let types ArrayInt32 (array-int32-create))
          (collect-fn-sigs-from-module a root names types "")
          ;; Should find 4 entries (2 functions * 2 names each: qualified + unqualified)
          (expect-eq (array-str-len names) 4)
          ;; Check that both functions are found
          (let found-fn1 Int32 0)
          (let found-fn2 Int32 0)
          (let i Int32 0)
          (while (< i (array-str-len names))
            (do
              (let name String (array-str-get names i))
              (if-stmt (|| (string-eq name "fn1") (string-eq name "io::fn1"))
                (set found-fn1 1)
                (do 0)
              )
              (if-stmt (|| (string-eq name "fn2") (string-eq name "io::fn2"))
                (set found-fn2 1)
                (do 0)
              )
              (set i (+ i 1))
            )
          )
          (expect-eq found-fn1 1)
          (expect-eq found-fn2 1)
        )
      )
      (test collect-from-module-nested-namespace
        (doc "Test collecting from nested namespace blocks")
        (tags unit)
        (body
          (let a (ptr Arena) (arena-create 4096))
          (let root Int32 (parser::parse-string a "(module (name \"test\") (namespace \"io\" (namespace \"control\" (fn nested-fn (params ()) (returns Int32) (body 0)))))"))
          (let names ArrayString (array-string-create))
          (let types ArrayInt32 (array-int32-create))
          (collect-fn-sigs-from-module a root names types "")
          ;; Should find nested function with nested namespace prefix
          (expect-eq (array-str-len names) 2)
          (let found Int32 0)
          (let i Int32 0)
          (while (< i (array-str-len names))
            (do
              (let name String (array-str-get names i))
              (if-stmt (|| (string-eq name "nested-fn") (string-eq name "io::control::nested-fn"))
                (set found 1)
                (do 0)
              )
              (set i (+ i 1))
            )
          )
          (expect-eq found 1)
        )
      )
      (test collect-from-module-namespace-with-includes
        (doc "Test that namespace blocks work even when includes are present")
        (tags unit)
        (body
          (let a (ptr Arena) (arena-create 4096))
          (let root Int32 (parser::parse-string a "(module (name \"test\") (include \"foo.weave\") (namespace \"io\" (fn test-fn (params ()) (returns Int32) (body 0))))"))
          (let names ArrayString (array-string-create))
          (let types ArrayInt32 (array-int32-create))
          (collect-fn-sigs-from-module a root names types "")
          ;; Should find the function in the namespace block
          (expect-eq (array-str-len names) 2)
          (let found Int32 0)
          (let i Int32 0)
          (while (< i (array-str-len names))
            (do
              (let name String (array-str-get names i))
              (if-stmt (|| (string-eq name "test-fn") (string-eq name "io::test-fn"))
                (set found 1)
                (do 0)
              )
              (set i (+ i 1))
            )
          )
          (expect-eq found 1)
        )
      )
      (test collect-from-module-namespace-structure-verification
        (doc "Test that we can detect namespace blocks and their children correctly")
        (tags unit)
        (body
          (let a (ptr Arena) (arena-create 4096))
          (let root Int32 (parser::parse-string a "(module (name \"test\") (namespace \"io\" (fn test-fn (params ()) (returns String) (body \"hello\"))))"))
          ;; Verify namespace block is detected
          (let child Int32 (arena-first-child a root))
          (let found-ns Int32 0)
          (while (!= child (- 0 1))
            (do
              (if-stmt (is-list-with-head a child "namespace")
                (set found-ns 1)
                (do 0)
              )
              (set child (arena-next-sibling a child))
            )
          )
          (expect-eq found-ns 1)
          ;; Now verify collection works
          (let names ArrayString (array-string-create))
          (let types ArrayInt32 (array-int32-create))
          (collect-fn-sigs-from-module a root names types "")
          (expect-eq (array-str-len names) 2)
        )
      )
      (test collect-from-module-namespace-child-traversal
        (doc "Test that we correctly traverse children of namespace blocks")
        (tags unit)
        (body
          (let a (ptr Arena) (arena-create 4096))
          (let root Int32 (parser::parse-string a "(module (name \"test\") (namespace \"io\" (fn fn1 (params ()) (returns Int32) (body 0)) (fn fn2 (params ()) (returns String) (body \"\"))))"))
          ;; Find namespace block
          (let child Int32 (arena-first-child a root))
          (let ns-block Int32 (- 0 1))
          (while (!= child (- 0 1))
            (do
              (if-stmt (is-list-with-head a child "namespace")
                (set ns-block child)
                (do 0)
              )
              (set child (arena-next-sibling a child))
            )
          )
          (expect-true (!= ns-block (- 0 1)))
          ;; Get namespace name (second child)
          (let ns-name-node Int32 (second-child a ns-block))
          (expect-true (!= ns-name-node (- 0 1)))
          (expect-true (string-eq (arena-value a ns-name-node) "io"))
          ;; Get first child after namespace name (should be fn1)
          (let ns-child Int32 (arena-next-sibling a ns-name-node))
          (expect-true (!= ns-child (- 0 1)))
          (expect-true (is-list-with-head a ns-child "fn"))
          ;; Now test collection
          (let names ArrayString (array-string-create))
          (let types ArrayInt32 (array-int32-create))
          (collect-fn-sigs-from-module a root names types "")
          (expect-eq (array-str-len names) 4)
        )
      )
      (test collect-from-module-manual-namespace-construction
        (doc "Test collection with manually constructed AST to verify logic")
        (tags unit)
        (body
          (let a (ptr Arena) (arena-create 4096))
          ;; Manually build: (module (namespace "io" (fn test-fn (params ()) (returns String) (body "hello"))))
          (let module-node Int32 (arena-add-node a (node-kind-list) ""))
          (let module-head Int32 (arena-add-node a (node-kind-atom) "module"))
          (arena-set-first-child a module-node module-head)
          
          (let ns-block Int32 (arena-add-node a (node-kind-list) ""))
          (let ns-head Int32 (arena-add-node a (node-kind-atom) "namespace"))
          (let ns-name Int32 (arena-add-node a (node-kind-atom) "io"))
          (arena-set-first-child a ns-block ns-head)
          (arena-set-next-sibling a ns-head ns-name)
          
          (let fn-block Int32 (arena-add-node a (node-kind-list) ""))
          (let fn-head Int32 (arena-add-node a (node-kind-atom) "fn"))
          (let fn-name Int32 (arena-add-node a (node-kind-atom) "test-fn"))
          (let params-block Int32 (arena-add-node a (node-kind-list) ""))
          (let params-head Int32 (arena-add-node a (node-kind-atom) "params"))
          (let params-empty Int32 (arena-add-node a (node-kind-list) ""))
          (let returns-block Int32 (arena-add-node a (node-kind-list) ""))
          (let returns-head Int32 (arena-add-node a (node-kind-atom) "returns"))
          (let returns-type Int32 (arena-add-node a (node-kind-atom) "String"))
          
          (arena-set-first-child a fn-block fn-head)
          (arena-set-next-sibling a fn-head fn-name)
          (arena-set-next-sibling a fn-name params-block)
          (arena-set-first-child a params-block params-head)
          (arena-set-next-sibling a params-head params-empty)
          (arena-set-next-sibling a params-block returns-block)
          (arena-set-first-child a returns-block returns-head)
          (arena-set-next-sibling a returns-head returns-type)
          
          (arena-set-next-sibling a ns-name fn-block)
          (arena-set-next-sibling a module-head ns-block)
          
          ;; Test collection
          (let names ArrayString (array-string-create))
          (let types ArrayInt32 (array-int32-create))
          (collect-fn-sigs-from-module a module-node names types "")
          (expect-eq (array-str-len names) 2)
          (let found Int32 0)
          (let i Int32 0)
          (while (< i (array-str-len names))
            (do
              (let name String (array-str-get names i))
              (if-stmt (|| (string-eq name "test-fn") (string-eq name "io::test-fn"))
                (set found 1)
                (do 0)
              )
              (set i (+ i 1))
            )
          )
          (expect-eq found 1)
        )
      )
      (test collect-from-module-verify-namespace-detection-logic
        (doc "Test the exact logic used in collection to verify it works")
        (tags unit)
        (body
          (let a (ptr Arena) (arena-create 4096))
          (let root Int32 (parser::parse-string a "(module (name \"test\") (namespace \"io\" (fn test-fn (params ()) (returns String) (body \"hello\"))))"))
          ;; Simulate the exact collection logic
          (let child Int32 (arena-first-child a root))
          (let found-namespace Int32 0)
          (let found-function Int32 0)
          (while (!= child (- 0 1))
            (do
              ;; This is the exact check from collect-fn-sigs-from-module
              (if-stmt (is-list-with-head a child "namespace")
                (do
                  (set found-namespace 1)
                  (let ns-name-node Int32 (second-child a child))
                  (if-stmt (!= ns-name-node (- 0 1))
                    (do
                      (let ns-name String (arena-value a ns-name-node))
                      ;; Get first child after namespace name
                      (let ns-child Int32 (arena-next-sibling a ns-name-node))
                      (while (!= ns-child (- 0 1))
                        (do
                          (if-stmt (is-list-with-head a ns-child "fn")
                            (set found-function 1)
                            (do 0)
                          )
                          (set ns-child (arena-next-sibling a ns-child))
                        )
                      )
                    )
                    (do 0)
                  )
                )
                (do 0)
              )
              (set child (arena-next-sibling a child))
            )
          )
          (expect-eq found-namespace 1)
          (expect-eq found-function 1)
        )
      )
    )
  )

  (fn collect-fn-sigs
    (doc "Collect function signatures: names -> return type nodes.")
    (params
      (a (ptr Arena))
      (root Int32)
      (fn-sig-names ArrayString)
      (fn-sig-ret-types ArrayInt32)
    )
    (returns Int32)
    (body (do
      (let child Int32 (arena-first-child a root))
      (while (!= child (- 0 1))
        (do
          ;; Top-level fn
          (if-stmt (is-list-with-head a child "fn")
            (do
              (let name-node Int32 (second-child a child))
              (let fn-name String (arena-value a name-node))
              (let sib Int32 (arena-next-sibling a name-node))
              (if-stmt (is-list-with-head a sib "doc")
                (set sib (arena-next-sibling a sib)) (do 0))
              (if-stmt (is-list-with-head a sib "params")
                (set sib (arena-next-sibling a sib)) (do 0))
              (if-stmt (is-list-with-head a sib "returns")
                (do
                  (let ret-type Int32 (second-child a sib))
                  (array-str-append fn-sig-names fn-name)
                  (array-i32-append fn-sig-ret-types ret-type)
                )
                (do 0)
              )
            )
            (do 0)
          )
          ;; Top-level entry
          (if-stmt (is-list-with-head a child "entry")
            (do
              (array-str-append fn-sig-names "main")
              (array-i32-append fn-sig-ret-types (- 0 1))
            )
            (do 0)
          )
          ;; Module: recursively scan for fn/entry/module
          (if-stmt (is-list-with-head a child "module")
            (do
              (collect-fn-sigs-from-module a child fn-sig-names
                fn-sig-ret-types "")
            )
            (do 0)
          )
          (set child (arena-next-sibling a child))
        )
      )
      (return 0)
    ))
    (tests
      (test collect-sigs-empty
        (doc "Test collecting from empty program")
        (tags unit)
        (body
          (let a (ptr Arena) (arena-create 4096))
          (let root Int32 (parser::parse-string a "()"))
          (let names ArrayString (array-string-create))
          (let types ArrayInt32 (array-int32-create))
          (let result Int32 (collect-fn-sigs a root names types))
          (expect-eq result 0))))
  )

  (fn lookup-fn-ret-type
    (doc "Look up function return type. Supports qualified names and ADL. Returns i32 if not found.")
    (params
      (a (ptr Arena))
      (fn-name String)
      (fn-sig-names ArrayString)
      (fn-sig-ret-types ArrayInt32)
      (arg-types ArrayString)
      (type-to-namespace ArrayString)
      (type-names ArrayString)
    )
    (returns String)
    (body (do
      ;; CRITICAL: Return "" for ptr-add to trigger GEP compilation
      ;; Use string-eq which works for other special forms
      (if-stmt (string-eq fn-name "ptr-add")
        (return "")
        (do 0)
      )
      (let i Int32 0)
      (let len Int32 (array-str-len fn-sig-names))
      (while (< i len)
        (do
          (if-stmt (string-eq (array-str-get fn-sig-names i) fn-name)
            (do
              (let ret-node Int32 (array-i32-get fn-sig-ret-types i))
              (if-stmt (== ret-node (- 0 1))
                (return "i32")
                (return (type-node-to-llvm-str a ret-node))
              )
            )
            (do 0)
          )
          (set i (+ i 1))
        )
      )
      ;; ADL: If direct lookup failed and we have argument types, try ADL
      (if-stmt (&& (> (array-str-len arg-types) 0) (> (array-str-len type-names) 0))
        (do
          (let j Int32 0)
          (while (< j (array-str-len arg-types))
            (do
              (let arg-type String (array-str-get arg-types j))
              ;; Find namespace for this type
              (let k Int32 0)
              (while (< k (array-str-len type-names))
                (do
                  (if-stmt (string-eq (array-str-get type-names k) arg-type)
                    (do
                      (let type-ns String (array-str-get type-to-namespace k))
                      (if-stmt (!= (string-length type-ns) 0)
                        (do
                          ;; Try looking up function in type's namespace
                          (let adl-name String (string-concat type-ns (string-concat "::" fn-name)))
                          (let m Int32 0)
                          (while (< m (array-str-len fn-sig-names))
                            (do
                              (if-stmt (string-eq (array-str-get fn-sig-names m) adl-name)
                                (do
                                  (let ret-node Int32 (array-i32-get fn-sig-ret-types m))
                                  (if-stmt (== ret-node (- 0 1))
                                    (return "i32")
                                    (return (type-node-to-llvm-str a ret-node))
                                  )
                                )
                                (do 0)
                              )
                              (set m (+ m 1))
                            )
                          )
                        )
                        (do 0)
                      )
                    )
                    (do 0)
                  )
                  (set k (+ k 1))
                )
              )
              (set j (+ j 1))
            )
          )
        )
        (do 0)
      )
      ;; Fallback for known runtime helpers, else default to i32
      (if-stmt (string-eq fn-name "string-concat") (return "i8*") (do 0))
      (if-stmt (string-eq fn-name "int-to-string") (return "i8*") (do 0))
      (if-stmt (string-eq fn-name "string-length") (return "i32") (do 0))
      (if-stmt (string-eq fn-name "string-eq") (return "i32") (do 0))
      (if-stmt (string-eq fn-name "buffer-to-string") (return "i8*") (do 0))
      (if-stmt (string-eq fn-name "c-malloc") (return "i8*") (do 0))
      (if-stmt (string-eq fn-name "c-strlen") (return "i32") (do 0))
      (if-stmt (string-eq fn-name "c-atoi") (return "i32") (do 0))
      (if-stmt (string-eq fn-name "c-strcpy") (return "i8*") (do 0))
      (if-stmt (string-eq fn-name "c-memcpy") (return "i8*") (do 0))
      (if-stmt (string-eq fn-name "c-strcat") (return "i8*") (do 0))
      (return "i32")
    ))
    (tests
      (test lookup-not-found
        (doc "Test lookup of non-existent function returns i32")
        (tags unit)
        (body
          (let a (ptr Arena) (arena-create 4096))
          (let result String (lookup-fn-ret-type a "unknown" (array-string-create) (array-int32-create) (array-string-create) (array-string-create) (array-string-create)))
          (expect-true (string-eq result "i32"))))
      (test lookup-default-i32
        (doc "Test lookup with -1 node returns i32")
        (tags unit)
        (body
          (let a (ptr Arena) (arena-create 4096))
          (let names ArrayString (array-string-create))
          (let types ArrayInt32 (array-int32-create))
          (array-str-append names "test_fn")
          (array-i32-append types (- 0 1))
          (let result String (lookup-fn-ret-type a "test_fn" names types (array-string-create) (array-string-create) (array-string-create)))
          (expect-true (string-eq result "i32")))))
  )

  (fn extract-namespace-node
    (doc "Extract namespace node from a module node. Returns -1 if not found.")
    (params
      (a (ptr Arena))
      (module-node Int32)
    )
    (returns Int32)
    (body (do
      (let child Int32 (arena-first-child a module-node))
      (while (!= child (- 0 1))
        (do
          (if-stmt (is-list-with-head a child "namespace")
            (return child)
            (do 0)
          )
          (set child (arena-next-sibling a child))
        )
      )
      (return (- 0 1))
    ))
    (tests
      (test extract-namespace-found
        (doc "Test extracting namespace from module")
        (tags unit)
        (body
          (let a (ptr Arena) (arena-create 4096))
          (let root Int32 (parser::parse-string a "(module (name \"test\") (namespace \"foo\"))"))
          (let ns-node Int32 (extract-namespace-node a root))
          (expect-true (!= ns-node (- 0 1)))
        )
      )
      (test extract-namespace-not-found
        (doc "Test extracting namespace when not present")
        (tags unit)
        (body
          (let a (ptr Arena) (arena-create 4096))
          (let root Int32 (parser::parse-string a "(module (name \"test\"))"))
          (let ns-node Int32 (extract-namespace-node a root))
          (expect-eq ns-node (- 0 1))
        )
      )
    )
  )

  (fn flatten-namespace-path
    (doc "Flatten nested namespace node to path string like 'io::control::advanced'. Returns empty string if no namespace.")
    (params
      (a (ptr Arena))
      (namespace-node Int32)
    )
    (returns String)
    (body (do
      (if-stmt (== namespace-node (- 0 1))
        (return "")
        (do 0)
      )
      (let path Buffer (buffer-new))
      (let current Int32 namespace-node)
      (let first Int32 1)
      (while (!= current (- 0 1))
        (do
          ;; Get the namespace name (second child should be the string atom)
          (let name-node Int32 (second-child a current))
          (if-stmt (!= name-node (- 0 1))
            (do
              (let name-val String (arena-value a name-node))
              (if-stmt (== first 0)
                (buffer-append-string path "::")
                (do 0)
              )
              (buffer-append-string path name-val)
              (set first 0)
              ;; Check if there's a nested namespace (third child, which is next sibling of name-node)
              (let nested-ns Int32 (arena-next-sibling a name-node))
              (if-stmt (&& (!= nested-ns (- 0 1)) (== (arena-kind a nested-ns) (node-kind-list)))
                (do
                  ;; Verify it's a namespace node
                  (let nested-head Int32 (arena-first-child a nested-ns))
                  (if-stmt (&& (!= nested-head (- 0 1)) (string-eq (arena-value a nested-head) "namespace"))
                    (set current nested-ns)
                    (set current (- 0 1))
                  )
                )
                (set current (- 0 1))
              )
            )
            (set current (- 0 1))
          )
        )
      )
      (return (buffer-to-string path))
    ))
    (tests
      (test flatten-namespace-simple
        (doc "Test flattening simple namespace")
        (tags unit)
        (body
          (let a (ptr Arena) (arena-create 4096))
          (let root Int32 (parser::parse-string a "(module (namespace \"foo\"))"))
          (let ns-node Int32 (extract-namespace-node a root))
          (let path String (flatten-namespace-path a ns-node))
          (expect-true (string-eq path "foo"))
        )
      )
      (test flatten-namespace-nested
        (doc "Test flattening nested namespace")
        (tags unit)
        (body
          (let a (ptr Arena) (arena-create 4096))
          (let root Int32 (parser::parse-string a "(module (namespace \"io\" (namespace \"control\" (namespace \"advanced\"))))"))
          (let ns-node Int32 (extract-namespace-node a root))
          (let path String (flatten-namespace-path a ns-node))
          (expect-true (string-eq path "io::control::advanced"))
        )
      )
    )
  )

  (fn get-module-namespace-path
    (doc "Get namespace path from a module node. Returns empty string if no namespace.")
    (params
      (a (ptr Arena))
      (module-node Int32)
    )
    (returns String)
    (body (do
      (let ns-node Int32 (extract-namespace-node a module-node))
      (return (flatten-namespace-path a ns-node))
    ))
    (tests
      (test get-module-namespace-path-found
        (doc "Test getting namespace path from module")
        (tags unit)
        (body
          (let a (ptr Arena) (arena-create 4096))
          (let root Int32 (parser::parse-string a "(module (name \"test\") (namespace \"arrays\"))"))
          (let path String (get-module-namespace-path a root))
          (expect-true (string-eq path "arrays"))
        )
      )
      (test get-module-namespace-path-not-found
        (doc "Test getting namespace path when not present")
        (tags unit)
        (body
          (let a (ptr Arena) (arena-create 4096))
          (let root Int32 (parser::parse-string a "(module (name \"test\"))"))
          (let path String (get-module-namespace-path a root))
          (expect-true (string-eq path ""))
        )
      )
    )
  )

  (fn split-qualified-name
    (doc "Split qualified name like 'arrays::get' into namespace and function name. Returns 1 if qualified, 0 if not. Stores namespace in out-namespace and function name in out-fn-name.")
    (params
      (qualified-name String)
      (out-namespace (ptr String))
      (out-fn-name (ptr String))
    )
    (returns Int32)
    (body (do
      (let len Int32 (string-length qualified-name))
      (let i Int32 0)
      (while (< i len)
        (do
          (let ch Int32 (string-char-at qualified-name i))
          (if-stmt (&& (== ch 58) (< (+ i 1) len) (== (string-char-at qualified-name (+ i 1)) 58))
            (do
              (let ns String (string-slice qualified-name 0 i))
              (let fn String (string-slice qualified-name (+ i 2) (- len (+ i 2))))
              (store String out-namespace ns)
              (store String out-fn-name fn)
              (return 1)
            )
            (do 0)
          )
          (set i (+ i 1))
        )
      )
      ;; No namespace separator found
      (store String out-namespace "")
      (store String out-fn-name qualified-name)
      (return 0)
    ))
    (tests
      (test split-qualified-name-simple
        (doc "Test splitting simple qualified name")
        (tags unit)
        (body
          (let ns String "")
          (let fn String "")
          (let result Int32 (split-qualified-name "arrays::get" (addr ns) (addr fn)))
          (expect-eq result 1)
          (expect-true (string-eq ns "arrays"))
          (expect-true (string-eq fn "get"))
        )
      )
      (test split-qualified-name-unqualified
        (doc "Test splitting unqualified name")
        (tags unit)
        (body
          (let ns String "")
          (let fn String "")
          (let result Int32 (split-qualified-name "get" (addr ns) (addr fn)))
          (expect-eq result 0)
          (expect-true (string-eq ns ""))
          (expect-true (string-eq fn "get"))
        )
      )
    )
  )
