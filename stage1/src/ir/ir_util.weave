;; Utility functions for IR generation

  (fn dedupe-lines
    (doc "Remove duplicate lines from a buffer, preserving first occurrences.")
    (params (buf Buffer))
    (returns Buffer)
    (body
      (let src String (buffer-to-string buf))
      (let out Buffer (buffer-new))
      (let seen ArrayString (array-str-new))
      (let start Int32 0)
      (let i Int32 0)
      (let len Int32 (string-length src))
      (while (<= i len)
        (do
          (if-stmt (|| (== i len) (== (string-char-at src i) 10))
            (do
              (let line String (string-slice src start (- i start)))
              (if-stmt (&& (> (string-length line) 0) (== (array-str-contains seen line) 0))
                (do
                  (array-str-append seen line)
                  (buffer-append-string out line)
                  (buffer-append-string out "\n")
                )
                (do 0)
              )
              (set start (+ i 1))
            )
            (do 0)
          )
          (set i (+ i 1))
        )
      )
      (return out)
    )
    (tests
      (test dedupe-none
        (doc "Test buffer with no duplicates")
        (tags unit)
        (body
          (let buf Buffer (buffer-create 64))
          (buffer-append-string buf "line1\n")
          (buffer-append-string buf "line2\n")
          (let result Buffer (dedupe-lines buf))
          (expect-true (> (string-length (buffer-to-string result)) 0))))
      (test dedupe-duplicates
        (doc "Test buffer with duplicate lines")
        (tags unit)
        (body
          (let buf Buffer (buffer-create 64))
          (buffer-append-string buf "same\n")
          (buffer-append-string buf "same\n")
          (let result Buffer (dedupe-lines buf))
          (let result-str String (buffer-to-string result))
          (expect-true (> (string-length result-str) 0)))))
  )

  (fn collect-fn-sigs-from-module
    (doc "Recursively collect fn signatures from a module node.")
    (params
      (a (ptr Arena))
      (module-node Int32)
      (fn-sig-names ArrayString)
      (fn-sig-ret-types ArrayInt32)
    )
    (returns Int32)
    (body (do
      (let child Int32 (arena-first-child a module-node))
      (while (!= child (- 0 1))
        (do
          (if-stmt (is-list-with-head a child "fn")
            (do
              (let name-node Int32 (second-child a child))
              (let fn-name String (arena-value a name-node))
              (let sib Int32 (arena-next-sibling a name-node))
              (if-stmt (is-list-with-head a sib "doc")
                (set sib (arena-next-sibling a sib)) (do 0))
              (if-stmt (is-list-with-head a sib "params")
                (set sib (arena-next-sibling a sib)) (do 0))
              (if-stmt (is-list-with-head a sib "returns")
                (do
                  (let ret-type Int32 (second-child a sib))
                  (array-str-append fn-sig-names fn-name)
                  (ccall "puts" (returns Int32)
                    (args (String (string-concat "[collect] fn: " fn-name))))
                  (array-i32-append fn-sig-ret-types ret-type)
                )
                (do 0)
              )
            )
            (do 0)
          )
          (if-stmt (is-list-with-head a child "entry")
            (do
              (array-str-append fn-sig-names "main")
              (array-i32-append fn-sig-ret-types (- 0 1))
            )
            (do 0)
          )
          ;; Recursively scan nested modules
          (if-stmt (is-list-with-head a child "module")
            (do
              (collect-fn-sigs-from-module a child fn-sig-names
                fn-sig-ret-types)
            )
            (do 0)
          )
          (set child (arena-next-sibling a child))
        )
      )
      (return 0)
    ))
    (tests
      (test collect-from-module-empty
        (doc "Test collecting from empty module")
        (tags unit)
        (body
          (let a (ptr Arena) (arena-create 4096))
          (let root Int32 (parse-string a "(module (name \"test\"))"))
          (let names ArrayString (array-string-create))
          (let types ArrayInt32 (array-int32-create))
          (collect-fn-sigs-from-module a root names types)
          (expect-eq (array-str-len names) 0)
        )
      )
    )
  )

  (fn collect-fn-sigs
    (doc "Collect function signatures: names -> return type nodes.")
    (params
      (a (ptr Arena))
      (root Int32)
      (fn-sig-names ArrayString)
      (fn-sig-ret-types ArrayInt32)
    )
    (returns Int32)
    (body (do
      (let child Int32 (arena-first-child a root))
      (while (!= child (- 0 1))
        (do
          ;; Top-level fn
          (if-stmt (is-list-with-head a child "fn")
            (do
              (let name-node Int32 (second-child a child))
              (let fn-name String (arena-value a name-node))
              (let sib Int32 (arena-next-sibling a name-node))
              (if-stmt (is-list-with-head a sib "doc")
                (set sib (arena-next-sibling a sib)) (do 0))
              (if-stmt (is-list-with-head a sib "params")
                (set sib (arena-next-sibling a sib)) (do 0))
              (if-stmt (is-list-with-head a sib "returns")
                (do
                  (let ret-type Int32 (second-child a sib))
                  (array-str-append fn-sig-names fn-name)
                  (ccall "puts" (returns Int32)
                    (args (String (string-concat "[collect] fn: " fn-name))))
                  (array-i32-append fn-sig-ret-types ret-type)
                )
                (do 0)
              )
            )
            (do 0)
          )
          ;; Top-level entry
          (if-stmt (is-list-with-head a child "entry")
            (do
              (array-str-append fn-sig-names "main")
              (array-i32-append fn-sig-ret-types (- 0 1))
            )
            (do 0)
          )
          ;; Module: recursively scan for fn/entry/module
          (if-stmt (is-list-with-head a child "module")
            (do
              (collect-fn-sigs-from-module a child fn-sig-names
                fn-sig-ret-types)
            )
            (do 0)
          )
          (set child (arena-next-sibling a child))
        )
      )
      (return 0)
    ))
    (tests
      (test collect-sigs-empty
        (doc "Test collecting from empty program")
        (tags unit)
        (body
          (let a (ptr Arena) (arena-create 4096))
          (let root Int32 (parse-string a "()"))
          (let names ArrayString (array-string-create))
          (let types ArrayInt32 (array-int32-create))
          (let result Int32 (collect-fn-sigs a root names types))
          (expect-eq result 0))))
  )

  (fn lookup-fn-ret-type
    (doc "Look up function return type. Returns -1 if not found (defaults to i32).")
    (params
      (a (ptr Arena))
      (fn-name String)
      (fn-sig-names ArrayString)
      (fn-sig-ret-types ArrayInt32)
    )
    (returns String)
    (body (do
      (let i Int32 0)
      (let len Int32 (array-str-len fn-sig-names))
      (while (< i len)
        (do
          (if-stmt (string-eq (array-str-get fn-sig-names i) fn-name)
            (do
              (let ret-node Int32 (array-i32-get fn-sig-ret-types i))
              (if-stmt (== ret-node (- 0 1))
                (return "i32")
                (return (type-node-to-llvm-str a ret-node))
              )
            )
            (do 0)
          )
          (set i (+ i 1))
        )
      )
      ;; Not found - fallback for known runtime helpers, else default to i32
      (if-stmt (string-eq fn-name "string-concat") (return "i8*") (do 0))
      (if-stmt (string-eq fn-name "int-to-string") (return "i8*") (do 0))
      (if-stmt (string-eq fn-name "string-length") (return "i32") (do 0))
      (if-stmt (string-eq fn-name "string-eq") (return "i32") (do 0))
      (if-stmt (string-eq fn-name "buffer-to-string") (return "i8*") (do 0))
      (if-stmt (string-eq fn-name "c-malloc") (return "i8*") (do 0))
      (if-stmt (string-eq fn-name "c-strlen") (return "i32") (do 0))
      (if-stmt (string-eq fn-name "c-atoi") (return "i32") (do 0))
      (if-stmt (string-eq fn-name "c-strcpy") (return "i8*") (do 0))
      (if-stmt (string-eq fn-name "c-memcpy") (return "i8*") (do 0))
      (if-stmt (string-eq fn-name "c-strcat") (return "i8*") (do 0))
      (return "i32")
    ))
    (tests
      (test lookup-not-found
        (doc "Test lookup of non-existent function returns i32")
        (tags unit)
        (body
          (let a (ptr Arena) (arena-create 4096))
          (let result String (lookup-fn-ret-type a "unknown" (array-string-create) (array-int32-create)))
          (expect-true (string-eq result "i32"))))
      (test lookup-default-i32
        (doc "Test lookup with -1 node returns i32")
        (tags unit)
        (body
          (let a (ptr Arena) (arena-create 4096))
          (let names ArrayString (array-string-create))
          (let types ArrayInt32 (array-int32-create))
          (array-str-append names "test_fn")
          (array-i32-append types (- 0 1))
          (let result String (lookup-fn-ret-type a "test_fn" names types))
          (expect-true (string-eq result "i32")))))
  )
