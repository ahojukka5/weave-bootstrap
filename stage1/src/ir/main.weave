(module
  (name "stage1-ir-main")
  (doc "Entry point that lowers parsed S-expressions into LLVM IR.")

  (include "../string.weave")
  (include "../buffers.weave")
  (include "../arrays.weave")
  (include "../arena.weave")
  (include "../debug.weave")
  (include "./emit.weave")
  (include "./util.weave")
  (include "./expr.weave")
  (include "./stmt.weave")
  (include "./ir_runtime.weave")
  (include "./ir_util.weave")
  (include "./ir_fns.weave")

  (fn generate-ir
    (doc "Builds decls + all function IR from the parsed arena.")
    (params
      (a (ptr Arena))
      (root Int32)
      (out Buffer)
      (token-count Int32)
    )
    (returns Int32)
    (body
      (do
        (let decls Buffer (buffer-new))
        (let fn-out Buffer (buffer-new))
        (let env-names ArrayString (array-str-new))
        (let env-safe ArrayString (array-str-new))
        (let env-types ArrayInt32 (array-i32-new))
        (let struct-names ArrayString (array-str-new))
        (let struct-fields ArrayString (array-str-new))

        ;; Emit struct type definitions early so named types like %Arena
        ;; are defined before any wrapper stubs or function IR that reference them.
        (collect-structs a root struct-names struct-fields)
        (emit-struct-defs decls struct-names struct-fields)
        
        ;; Debug: report child count and dump heads
        (buffer-append-string fn-out "; debug: root children:\n")
        (let ch Int32 (arena-first-child a root))
        (while (!= ch (- 0 1))
          (do
            (if-stmt (== (arena-kind a ch) (node-kind-list))
              (do
                (let h Int32 (arena-first-child a ch))
                (if-stmt (!= h (- 0 1))
                  (if-stmt (== (arena-kind a h) (node-kind-atom))
                    (do
                      (buffer-append-string fn-out "; head: ")
                      (buffer-append-string fn-out (arena-value a h))
                      (buffer-append-string fn-out "\n")
                    )
                    (do 0)
                  )
                  (do 0)
                )
              )
              (do
                (buffer-append-string fn-out "; atom-child\n")
              )
            )
            (set ch (arena-next-sibling a ch))
          )
        )

        ;; Collect function signatures for call type inference
        (let fn-sig-names ArrayString (array-str-new))
        (let fn-sig-ret-types ArrayInt32 (array-i32-new))
        (collect-fn-sigs a root fn-sig-names fn-sig-ret-types)
        (let declared ArrayString (array-str-new))
        ;; Skip emitting declarations for string helpers; wrappers below cover missing cases
        ;; Provide simple IR definitions for common string helpers when not compiled from modules
        (if-stmt (== (array-str-contains fn-sig-names "string-length") 0)
          (do
            (emit-runtime-decl "strlen" "declare i32 @strlen(i8*)" decls declared)
            (buffer-append-string decls "define i32 @string-length(i8* %s) {\n")
            (buffer-append-string decls "  %len = call i32 @strlen(i8* %s)\n")
            (buffer-append-string decls "  ret i32 %len\n}\n")
          )
          (do 0)
        )
        (if-stmt (== (array-str-contains fn-sig-names "string-concat") 0)
          (do
            (emit-runtime-decl "strlen" "declare i32 @strlen(i8*)" decls declared)
            (emit-runtime-decl "malloc" "declare i8* @malloc(i32)" decls declared)
            (emit-runtime-decl "strcpy" "declare i8* @strcpy(i8*, i8*)" decls declared)
            (emit-runtime-decl "strcat" "declare i8* @strcat(i8*, i8*)" decls declared)
            (buffer-append-string decls "define i8* @string-concat(i8* %a, i8* %b) {\n")
            (buffer-append-string decls "entry:\n")
            (buffer-append-string decls "  %la = call i32 @strlen(i8* %a)\n")
            (buffer-append-string decls "  %lb = call i32 @strlen(i8* %b)\n")
            (buffer-append-string decls "  %sum = add i32 %la, %lb\n")
            (buffer-append-string decls "  %sum1 = add i32 %sum, 1\n")
            (buffer-append-string decls "  %out = call i8* @malloc(i32 %sum1)\n")
            (buffer-append-string decls "  %t0 = call i8* @strcpy(i8* %out, i8* %a)\n")
            (buffer-append-string decls "  %t1 = call i8* @strcat(i8* %out, i8* %b)\n")
            (buffer-append-string decls "  ret i8* %out\n}\n")
          )
          (do 0)
        )
        (if-stmt (== (array-str-contains fn-sig-names "string-eq") 0)
          (do
            (emit-runtime-decl "strcmp" "declare i32 @strcmp(i8*, i8*)" decls declared)
            (buffer-append-string decls "define i32 @string-eq(i8* %a, i8* %b) {\n")
            (buffer-append-string decls "  %cmp = call i32 @strcmp(i8* %a, i8* %b)\n")
            (buffer-append-string decls "  %eq = icmp eq i32 %cmp, 0\n")
            (buffer-append-string decls "  %z = zext i1 %eq to i32\n")
            (buffer-append-string decls "  ret i32 %z\n}\n")
          )
          (do 0)
        )

        ;; Fallback wrappers for libc functions if not compiled from modules
        (if-stmt (== (array-str-contains fn-sig-names "c-strlen") 0)
          (do
            (emit-runtime-decl "strlen" "declare i32 @strlen(i8*)" decls declared)
            (buffer-append-string decls "define i32 @c-strlen(i8* %s) {\n")
            (buffer-append-string decls "  %len = call i32 @strlen(i8* %s)\n")
            (buffer-append-string decls "  ret i32 %len\n}\n")
          )
          (do 0)
        )
        (if-stmt (== (array-str-contains fn-sig-names "c-atoi") 0)
          (do
            (emit-runtime-decl "atoi" "declare i32 @atoi(i8*)" decls declared)
            (buffer-append-string decls "define i32 @c-atoi(i8* %s) {\n")
            (buffer-append-string decls "  %ret = call i32 @atoi(i8* %s)\n")
            (buffer-append-string decls "  ret i32 %ret\n}\n")
          )
          (do 0)
        )
        (if-stmt (== (array-str-contains fn-sig-names "c-strcmp") 0)
          (do
            (emit-runtime-decl "strcmp" "declare i32 @strcmp(i8*, i8*)" decls declared)
            (buffer-append-string decls "define i32 @c-strcmp(i8* %a, i8* %b) {\n")
            (buffer-append-string decls "  %cmp = call i32 @strcmp(i8* %a, i8* %b)\n")
            (buffer-append-string decls "  ret i32 %cmp\n}\n")
          )
          (do 0)
        )
        (if-stmt (== (array-str-contains fn-sig-names "c-malloc") 0)
          (do
            (emit-runtime-decl "malloc" "declare i8* @malloc(i32)" decls declared)
            (buffer-append-string decls "define i8* @c-malloc(i32 %n) {\n")
            (buffer-append-string decls "  %ret = call i8* @malloc(i32 %n)\n")
            (buffer-append-string decls "  ret i8* %ret\n}\n")
          )
          (do 0)
        )
        (if-stmt (== (array-str-contains fn-sig-names "c-strcpy") 0)
          (do
            (emit-runtime-decl "strcpy" "declare i8* @strcpy(i8*, i8*)" decls declared)
            (buffer-append-string decls "define i8* @c-strcpy(i8* %dest, i8* %src) {\n")
            (buffer-append-string decls "  %ret = call i8* @strcpy(i8* %dest, i8* %src)\n")
            (buffer-append-string decls "  ret i8* %ret\n}\n")
          )
          (do 0)
        )
        (if-stmt (== (array-str-contains fn-sig-names "c-strcat") 0)
          (do
            (emit-runtime-decl "strcat" "declare i8* @strcat(i8*, i8*)" decls declared)
            (buffer-append-string decls "define i8* @c-strcat(i8* %dest, i8* %src) {\n")
            (buffer-append-string decls "  %ret = call i8* @strcat(i8* %dest, i8* %src)\n")
            (buffer-append-string decls "  ret i8* %ret\n}\n")
          )
          (do 0)
        )

        ;; If we need to emit any fallback stubs that reference %Arena*, ensure
        ;; the identified struct exists (opaque is fine for prototypes).
        (let need-arena Int32 0)
        (if-stmt (== (array-str-contains fn-sig-names "expand-root") 0)
          (set need-arena 1)
          (do 0)
        )
        (if-stmt (== (array-str-contains fn-sig-names "generate-ir") 0)
          (set need-arena 1)
          (do 0)
        )
        (if-stmt (== (array-str-contains fn-sig-names "lower-program") 0)
          (set need-arena 1)
          (do 0)
        )
        (if-stmt (== (array-str-contains fn-sig-names "typecheck_program") 0)
          (set need-arena 1)
          (do 0)
        )
        (if-stmt (&& (== need-arena 1) (== (array-str-contains struct-names "Arena") 0))
          (buffer-append-string decls "%Arena = type opaque\n")
          (do 0)
        )

        ;; Fallback for include expansion entry when not compiled from modules
        ;; This prevents LLVM IR verification errors on self-host builds when
        ;; include_expand.weave wasn't flattened into the compiler AST.
        ;; Note: This stub does not perform real include expansion; it only
        ;; satisfies IR by providing a symbol. The proper implementation should
        ;; come from include_expand.weave once includes are correctly flattened.
        (if-stmt (== (array-str-contains fn-sig-names "expand-root") 0)
          (do
            (buffer-append-string decls "define i32 @expand-root(i8* %path, %Arena* %out_arena, i32* %out_root) {\n")
            (buffer-append-string decls "  ret i32 0\n}\n")
          )
          (do 0)
        )

        ;; Fallback stub for generate-ir to avoid undefined symbol during IR verify
        (if-stmt (== (array-str-contains fn-sig-names "generate-ir") 0)
          (do
            (buffer-append-string decls "define i32 @generate-ir(%Arena* %a, i32 %root, i8* %out, i32 %tok) {\n")
            (buffer-append-string decls "  ret i32 0\n}\n")
          )
          (do 0)
        )

        ;; Fallback stubs for lowering and typechecking passes
        (if-stmt (== (array-str-contains fn-sig-names "lower-program") 0)
          (do
            (buffer-append-string decls "define i32 @lower-program(%Arena* %a, i32 %root) {\n")
            (buffer-append-string decls "  ret i32 0\n}\n")
          )
          (do 0)
        )
        (if-stmt (== (array-str-contains fn-sig-names "typecheck_program") 0)
          (do
            (buffer-append-string decls "define i32 @typecheck_program(%Arena* %a, i32 %root) {\n")
            (buffer-append-string decls "  ret i32 0\n}\n")
          )
          (do 0)
        )

        ;; Removed identity @return helper to avoid return-as-value misuse.

        ;; Seed runtime decls we rely on
        (emit-runtime-decl "weave_get_cli_string" "declare i8* @weave_get_cli_string(i8*)" decls declared)
        (emit-runtime-decl "weave_read_file" "declare i8* @weave_read_file(i8*)" decls declared)
        (emit-runtime-decl "weave_write_file" "declare i32 @weave_write_file(i8*, i8*)" decls declared)
        ;; Decls for common prelude helpers used in tests are emitted only when wrappers are generated below

        (let str-counter Int32 0)

        ;; Compile all fn and entry definitions
        ;; First collect signatures so we can decide whether to emit built-in wrappers
        (compile-all-fns a root declared struct-names struct-fields decls (addr str-counter) fn-out fn-sig-names fn-sig-ret-types)

        (buffer-append-string out (buffer-to-string decls))
        (buffer-append-string out (buffer-to-string fn-out))
        (return 0)
      )
    )
    (tests
      (test generate-ir-empty
        (doc "should handle empty arena")
        (tags unit ir main)
        (body
          (let a (ptr Arena) (arena-new))
          (let root Int32 (arena-add-node a (node-kind-list) ""))
          (let out Buffer (buffer-new))
          (let result Int32 (generate-ir a root out 0))
          (expect-eq result 0)
        )
      )
    )
  )
)
