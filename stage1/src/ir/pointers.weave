  (fn compile-addr
    (doc "Compute the address of a local (alloca'd) binding.")
    (params (node Int32) (a (ptr Arena)) (env-names ArrayString) (env-safe ArrayString) (env-types ArrayInt32) (out Buffer) (temp (ptr Int32)))
    (returns Int32)
    (body
      (let name-node Int32 (second-child a node))
      (let orig String (arena-value a name-node))
      (let safe String (env-find-safe env-names env-safe orig))
      (let ty-node Int32 (env-find-type env-names env-types orig))
      ;; env-find-type requires types array; here env-expr does not pass it, so default to i32 if missing
      (if-stmt (== ty-node (- 0 1))
        (set ty-node (- 0 1))
        (do 0)
      )
      (let t Int32 (load Int32 temp))
      (buffer-append-string out "  ")
      (emit-temp out t)
      (buffer-append-string out " = bitcast ")
      (if-stmt (== ty-node (- 0 1))
        (buffer-append-string out "i32*")
        (emit-pointer-type-node out a ty-node)
      )
      (buffer-append-string out " %")
      (buffer-append-string out safe)
      (buffer-append-string out " to ")
      (if-stmt (== ty-node (- 0 1))
        (buffer-append-string out "i32*\n")
        (do
          (emit-pointer-type-node out a ty-node)
          (buffer-append-string out "\n")
        )
      )
      (store Int32 temp (+ t 1))
      (return t)
    )
    (tests
      (test compile-addr-basic
        (doc "Generates bitcast for address-of local")
        (tags unit ir pointers)
        (body
          (let a (ptr Arena) (arena-create 256))
          (let node Int32 (parse-string a "(addr x)"))
          (let env-names ArrayString (array-str-new))
          (let env-safe ArrayString (array-str-new))
          (let env-types ArrayInt32 (array-i32-new))
          (array-str-append env-names "x")
          (array-str-append env-safe "x_safe")
          (array-i32-append env-types (- 0 1))
          (let buf Buffer (buffer-new))
          (let temp-var Int32 0)
          (let result Int32 (compile-addr node a env-names env-safe env-types buf (addr-of Int32 temp-var)))
          (expect-eq result 0)
          (expect-eq temp-var 1)
          (let out String (buffer-to-string buf))
          (expect-eq (string-starts-with out "  %t0 = bitcast") 1)
        )
      )
    )
  )

  (fn compile-load-node
    (doc "Load from ptr-reg with the given element type node.")
    (params (a (ptr Arena)) (ty-node Int32) (ptr-reg Int32) (out Buffer) (temp (ptr Int32)))
    (returns Int32)
    (body
      (let t Int32 (load Int32 temp))
      (buffer-append-string out "  ")
      (emit-temp out t)
      (buffer-append-string out " = load ")
      (emit-type-node out a ty-node)
      (buffer-append-string out ", ")
      (emit-pointer-type-node out a ty-node)
      (buffer-append-string out " ")
      (emit-temp out ptr-reg)
      (buffer-append-string out "\n")
      (store Int32 temp (+ t 1))
      (return t)
    )
    (tests
      (test compile-load-node-basic
        (doc "Generates load instruction")
        (tags unit ir pointers)
        (body
          (let a (ptr Arena) (arena-create 256))
          (let ty-node Int32 (parse-string a "Int32"))
          (let buf Buffer (buffer-new))
          (let temp-var Int32 5)
          (let result Int32 (compile-load-node a ty-node 3 buf (addr-of Int32 temp-var)))
          (expect-eq result 5)
          (expect-eq temp-var 6)
          (let out String (buffer-to-string buf))
          (expect-eq (string-starts-with out "  %t5 = load i32") 1)
        )
      )
    )
  )

  (fn compile-store-node
    (doc "Store val-reg into ptr-reg using element type node.")
    (params (a (ptr Arena)) (ty-node Int32) (val-reg Int32) (ptr-reg Int32) (out Buffer))
    (returns Int32)
    (body
      (buffer-append-string out "  store ")
      (emit-type-node out a ty-node)
      (buffer-append-string out " ")
      (emit-temp out val-reg)
      (buffer-append-string out ", ")
      (emit-pointer-type-node out a ty-node)
      (buffer-append-string out " ")
      (emit-temp out ptr-reg)
      (buffer-append-string out "\n")
      (return val-reg)
    )
    (tests
      (test compile-store-node-basic
        (doc "Generates store instruction")
        (tags unit ir pointers)
        (body
          (let a (ptr Arena) (arena-create 256))
          (let ty-node Int32 (parse-string a "Int32"))
          (let buf Buffer (buffer-new))
          (let result Int32 (compile-store-node a ty-node 2 3 buf))
          (expect-eq result 2)
          (let out String (buffer-to-string buf))
          (expect-eq (string-starts-with out "  store i32 %t2") 1)
        )
      )
    )
  )

  (fn compile-bitcast-node
    (doc "Bitcast i8* source to to-ty-node (which should be a pointer type).")
    (params (a (ptr Arena)) (to-ty-node Int32) (src-reg Int32) (out Buffer) (temp (ptr Int32)))
    (returns Int32)
    (body
      (let t Int32 (load Int32 temp))
      (buffer-append-string out "  ")
      (emit-temp out t)
      (buffer-append-string out " = bitcast i8* ")
      (emit-temp out src-reg)
      (buffer-append-string out " to ")
      (emit-type-node out a to-ty-node)
      (buffer-append-string out "\n")
      (store Int32 temp (+ t 1))
      (return t)
    )
    (tests
      (test compile-bitcast-node-basic
        (doc "Generates bitcast instruction")
        (tags unit ir pointers)
        (body
          (let a (ptr Arena) (arena-create 256))
          (let to-ty Int32 (parse-string a "(ptr Int32)"))
          (let buf Buffer (buffer-new))
          (let temp-var Int32 10)
          (let result Int32 (compile-bitcast-node a to-ty 7 buf (addr-of Int32 temp-var)))
          (expect-eq result 10)
          (expect-eq temp-var 11)
          (let out String (buffer-to-string buf))
          (expect-eq (string-starts-with out "  %t10 = bitcast i8*") 1)
        )
      )
    )
  )

  (fn compile-get-field-node
    (doc "GEP into a struct or raw element pointer using type node.")
    (params
      (a (ptr Arena))
      (elem-ty-node Int32)
      (idx String)
      (ptr-reg Int32)
      (struct-names ArrayString)
      (struct-fields ArrayString)
      (out Buffer)
      (temp (ptr Int32))
    )
    (returns Int32)
    (body
      (let t Int32 (load Int32 temp))
      ;; Check if elem-ty-node is (struct Name)
      (if-stmt (== (arena-kind a elem-ty-node) (node-kind-list))
        (do
          (let head Int32 (arena-first-child a elem-ty-node))
          (let head-val String (arena-value a head))
          (if-stmt (string-eq head-val "struct")
            (do
              (let name-node Int32 (arena-next-sibling a head))
              (let sname String (arena-value a name-node))
              (let _ String (struct-field-type struct-names struct-fields sname (string-to-int idx)))
              (buffer-append-string out "  ")
              (emit-temp out t)
              (buffer-append-string out " = getelementptr inbounds %")
              (buffer-append-string out (sanitize-name sname))
              (buffer-append-string out ", %")
              (buffer-append-string out (sanitize-name sname))
              (buffer-append-string out "* ")
              (emit-temp out ptr-reg)
              (buffer-append-string out ", i32 0, i32 ")
              (buffer-append-string out idx)
              (buffer-append-string out "\n")
            )
            (do
              ;; Non-struct list type (e.g. ptr)
              (buffer-append-string out "  ")
              (emit-temp out t)
              (buffer-append-string out " = getelementptr inbounds ")
              (emit-type-node out a elem-ty-node)
              (buffer-append-string out ", ")
              (emit-pointer-type-node out a elem-ty-node)
              (buffer-append-string out " ")
              (emit-temp out ptr-reg)
              (buffer-append-string out ", i32 ")
              (buffer-append-string out idx)
              (buffer-append-string out "\n")
            )
          )
        )
        (do
          ;; Atom type
          (buffer-append-string out "  ")
          (emit-temp out t)
          (buffer-append-string out " = getelementptr inbounds ")
          (emit-type-node out a elem-ty-node)
          (buffer-append-string out ", ")
          (emit-pointer-type-node out a elem-ty-node)
          (buffer-append-string out " ")
          (emit-temp out ptr-reg)
          (buffer-append-string out ", i32 ")
          (buffer-append-string out idx)
          (buffer-append-string out "\n")
        )
      )
      (store Int32 temp (+ t 1))
      (return t)
    )
    (tests
      (test compile-get-field-node-struct
        (doc "Generates GEP for struct field access")
        (tags unit ir pointers)
        (body
          (let a (ptr Arena) (arena-create 256))
          (let elem-ty Int32 (parse-string a "(struct Point)"))
          (let buf Buffer (buffer-new))
          (let temp-var Int32 15)
          (let names ArrayString (array-str-new))
          (let fields ArrayString (array-str-new))
          (array-str-append names "Point")
          (array-str-append fields "x:Int32,y:Int32")
          (let result Int32 (compile-get-field-node a elem-ty "1" 8 names fields buf (addr-of Int32 temp-var)))
          (expect-eq result 15)
          (expect-eq temp-var 16)
          (let out String (buffer-to-string buf))
          (expect-eq (string-starts-with out "  %t15 = getelementptr") 1)
        )
      )
      (test compile-get-field-node-atom
        (doc "Generates GEP for atom element type")
        (tags unit ir pointers)
        (body
          (let a (ptr Arena) (arena-create 256))
          (let elem-ty Int32 (parse-string a "Int32"))
          (let buf Buffer (buffer-new))
          (let temp-var Int32 20)
          (let names ArrayString (array-str-new))
          (let fields ArrayString (array-str-new))
          (let result Int32 (compile-get-field-node a elem-ty "0" 5 names fields buf (addr-of Int32 temp-var)))
          (expect-eq result 20)
          (expect-eq temp-var 21)
          (let out String (buffer-to-string buf))
          (expect-eq (string-starts-with out "  %t20 = getelementptr") 1)
        )
      )
    )
  )

  (fn compile-ptr-add-node
    (doc "Pointer arithmetic: compute ptr + idx * sizeof(elem-ty-node).")
    (params
      (a (ptr Arena))
      (elem-ty-node Int32)
      (ptr-reg Int32)
      (idx-reg Int32)
      (out Buffer)
      (temp (ptr Int32))
    )
    (returns Int32)
    (body
      (let t Int32 (load Int32 temp))
      (buffer-append-string out "  ")
      (emit-temp out t)
      (buffer-append-string out " = getelementptr inbounds ")
      (emit-type-node out a elem-ty-node)
      (buffer-append-string out ", ")
      (emit-pointer-type-node out a elem-ty-node)
      (buffer-append-string out " ")
      (emit-temp out ptr-reg)
      (buffer-append-string out ", i32 ")
      (emit-temp out idx-reg)
      (buffer-append-string out "\n")
      (store Int32 temp (+ t 1))
      (return t)
    )
    (tests
      (test compile-ptr-add-node-basic
        (doc "Generates pointer arithmetic GEP")
        (tags unit ir pointers)
        (body
          (let a (ptr Arena) (arena-create 256))
          (let elem-ty Int32 (parse-string a "Int32"))
          (let buf Buffer (buffer-new))
          (let temp-var Int32 25)
          (let result Int32 (compile-ptr-add-node a elem-ty 10 11 buf (addr-of Int32 temp-var)))
          (expect-eq result 25)
          (expect-eq temp-var 26)
          (let out String (buffer-to-string buf))
          (expect-eq (string-starts-with out "  %t25 = getelementptr") 1)
          (expect-eq (> (string-length out) 30) 1)
        )
      )
    )
  )
