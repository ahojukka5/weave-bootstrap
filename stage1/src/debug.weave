(module
  (name "debug")
  (doc "Arena inspection helpers for debugging and tests.")

  (include "string.weave")
  (include "buffers.weave")
  (include "arrays.weave")
  (include "arena.weave")

  (namespace "compiler"
    ;; Simple tree dump for debugging the arena contents.
    (fn dump-indent
    (doc "Indent the buffer by n two-space groups.")
    (params
      (out Buffer)
      (n Int32)
    ) ;; params
    (returns Int32)
    (body (do
      (let i Int32 0)
      (while (< i n)
        (do
          (buffer-append-string out "  ")
          (set i (+ i 1))
        ) ;; do
      ) ;; while
      (return 0)
    )) ;; body
    (tests
      (test dump-indent-zero
        (doc "indent by 0 should add nothing")
        (tags unit debug)
        (body
          (let b Buffer (buffer-new))
          (dump-indent b 0)
          (let s String (buffer-to-string b))
          (let len Int32 (string-length s))
          (expect-eq len 0)
        )
      )
      (test dump-indent-two
        (doc "indent by 2 should add 4 spaces")
        (tags unit debug)
        (body
          (let b Buffer (buffer-new))
          (dump-indent b 2)
          (let s String (buffer-to-string b))
          (let len Int32 (string-length s))
          (expect-eq len 4)
        )
      )
    )
  ) ;; fn dump-indent

  (fn dump-node
    (doc "Recursively pretty-print a node and its children into out.")
    (params
      (a (ptr Arena))
      (node Int32)
      (out Buffer)
      (depth Int32)
    ) ;; params
    (returns Int32)
    (body (do
      (dump-indent out depth)
      (if-stmt (== (arena-kind a node) (node-kind-atom))
        (do
          (buffer-append-string out "(atom#")
          (buffer-append-string out (int-to-string node))
          (buffer-append-string out " ")
          (buffer-append-string out (arena-value a node))
          (buffer-append-string out ")\n")
        ) ;; do
        (do
          (buffer-append-string out "(list#")
          (buffer-append-string out (int-to-string node))
          (buffer-append-string out "\n")
          (let child Int32 (arena-first-child a node))
          (while (!= child (- 0 1))
            (do
              (dump-node a child out (+ depth 1))
              (set child (arena-next-sibling a child))
            ) ;; do
          ) ;; while
          (dump-indent out depth)
          (buffer-append-string out ")\n")
        ) ;; do
      ) ;; if-stmt
      (return 0)
    )) ;; body
    (tests
      (test dump-node-atom
        (doc "dumping atom should produce output")
        (tags unit debug)
        (body
          (let a (ptr Arena) (arena-new))
          (let id Int32 (arena-add-node a (node-kind-atom) "test"))
          (let b Buffer (buffer-new))
          (dump-node a id b 0)
          (let s String (buffer-to-string b))
          (let len Int32 (string-length s))
          (expect-true (> len 0))
        )
      )
    )
  ) ;; fn dump-node

  (fn dump-tree
    (doc "Return a full tree dump rooted at root.")
    (params
      (a (ptr Arena))
      (root Int32)
    ) ;; params
    (returns String)
    (body (do
      (let b Buffer (buffer-new))
      (dump-node a root b 0)
      (return (buffer-to-string b))
    )) ;; body
    (tests
      (test dump-tree-single-atom
        (doc "dumping single atom tree should produce string")
        (tags unit debug)
        (body
          (let a (ptr Arena) (arena-new))
          (let id Int32 (arena-add-node a (node-kind-atom) "hello"))
          (let s String (dump-tree a id))
          (let len Int32 (string-length s))
          (expect-true (> len 0))
        )
      )
    )
  ) ;; fn dump-tree

  ;; Dump a linked sibling chain starting at `start` using next-sibling.
  (fn dump-sibling-chain
    (doc "Render the sibling chain as id:value -> id:value ...")
    (params
      (a (ptr Arena))
      (start Int32)
    ) ;; params
    (returns String)
    (body (do
      (let b Buffer (buffer-new))
      (let n Int32 start)
      (while (!= n (- 0 1))
        (do
          (buffer-append-string b (int-to-string n))
          (buffer-append-string b ":")
          (buffer-append-string b (arena-value a n))
          (let next Int32 (arena-next-sibling a n))
          (if-stmt (!= next (- 0 1))
            (do (buffer-append-string b " -> "))
            (do (buffer-append-string b ""))
          ) ;; if-stmt
          (set n next)
        ) ;; do
      ) ;; while
      (return (buffer-to-string b))
    )) ;; body
    (tests
      (test dump-sibling-chain-single
        (doc "dumping single node chain should produce id:value")
        (tags unit debug)
        (body
          (let a (ptr Arena) (arena-new))
          (let id Int32 (arena-add-node a (node-kind-atom) "test"))
          (let s String (dump-sibling-chain a id))
          (let len Int32 (string-length s))
          (expect-true (> len 0))
        )
      )
      (test dump-sibling-chain-two
        (doc "dumping two-node chain should have arrow")
        (tags unit debug)
        (body
          (let a (ptr Arena) (arena-new))
          (let first Int32 (arena-add-node a (node-kind-atom) "a"))
          (let second Int32 (arena-add-node a (node-kind-atom) "b"))
          (arena-set-next-sibling a first second)
          (let s String (dump-sibling-chain a first))
          (let len Int32 (string-length s))
          (expect-true (> len 5))
        )
      )
    )
  ) ;; fn dump-sibling-chain
  ) ;; namespace "compiler"
) ;; module
