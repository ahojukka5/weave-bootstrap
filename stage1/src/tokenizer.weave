(module
  (name "stage1-tokenizer")
  (doc "Tokenize source text into a flat list of atoms/strings/parens.")

  (include "prelude.weave")

  (fn is-whitespace
    (doc "Return 1 if ch is ASCII whitespace.")
    (params
      (ch Int32)
    ) ;; params
    (returns Int32)
    (body
      (return
        (|| (== ch 32)
          (|| (== ch 9)
            (|| (== ch 10)
              (== ch 13)
            ) ;; ||
          ) ;; ||
        ) ;; ||
      )
    ) ;; body
    (tests
      (test is-whitespace-space
        (doc "ASCII 32 (space) is whitespace")
        (tags unit tokenizer)
        (body
          (let result Int32 (is-whitespace 32))
          (expect-eq result 1)
        )
      )
      (test is-whitespace-tab
        (doc "ASCII 9 (tab) is whitespace")
        (tags unit tokenizer)
        (body
          (let result Int32 (is-whitespace 9))
          (expect-eq result 1)
        )
      )
      (test is-whitespace-letter
        (doc "ASCII 65 (A) is not whitespace")
        (tags unit tokenizer)
        (body
          (let result Int32 (is-whitespace 65))
          (expect-eq result 0)
        )
      )
    )
  ) ;; fn is-whitespace

  (fn is-digit
    (doc "Return 1 if ch is an ASCII digit.")
    (params
      (ch Int32)
    ) ;; params
    (returns Int32)
    (body
      (return (&& (>= ch 48) (<= ch 57)))
    ) ;; body
    (tests
      (test is-digit-zero
        (doc "ASCII 48 (0) is a digit")
        (tags unit tokenizer)
        (body
          (let result Int32 (is-digit 48))
          (expect-eq result 1)
        )
      )
      (test is-digit-five
        (doc "ASCII 53 (5) is a digit")
        (tags unit tokenizer)
        (body
          (let result Int32 (is-digit 53))
          (expect-eq result 1)
        )
      )
      (test is-digit-letter
        (doc "ASCII 65 (A) is not a digit")
        (tags unit tokenizer)
        (body
          (let result Int32 (is-digit 65))
          (expect-eq result 0)
        )
      )
    )
  ) ;; fn is-digit

  (fn is-symbol-start
    (doc "Return 1 if ch can start a symbol.")
    (params
      (ch Int32)
    ) ;; params
    (returns Int32)
    (body
      (return
        (||
          (&& (>= ch 65) (<= ch 90))
          (||
            (&& (>= ch 97) (<= ch 122))
            (||
              (== ch 95) ;; _
              (||
                (== ch 46) ;; .
                (||
                  (== ch 43) ;; +
                  (||
                    (== ch 45) ;; -
                    (||
                      (== ch 42) ;; *
                      (||
                        (== ch 47) ;; /
                        (||
                          (== ch 60) ;; <
                          (||
                            (== ch 62) ;; >
                            (||
                              (== ch 61) ;; =
                              (||
                                (== ch 33) ;; !
                                (||
                                  (== ch 38) ;; &
                                  (== ch 124) ;; |
                                ) ;; ||
                              ) ;; ||
                            ) ;; ||
                          ) ;; ||
                        ) ;; ||
                      ) ;; ||
                    ) ;; ||
                  ) ;; ||
                ) ;; ||
              ) ;; ||
            ) ;; ||
          ) ;; ||
        ) ;; ||
      )
    ) ;; body
    (tests
      (test is-symbol-start-uppercase
        (doc "ASCII 65 (A) can start a symbol")
        (tags unit tokenizer)
        (body
          (let result Int32 (is-symbol-start 65))
          (expect-eq result 1)
        )
      )
      (test is-symbol-start-lowercase
        (doc "ASCII 97 (a) can start a symbol")
        (tags unit tokenizer)
        (body
          (let result Int32 (is-symbol-start 97))
          (expect-eq result 1)
        )
      )
      (test is-symbol-start-plus
        (doc "ASCII 43 (+) can start a symbol")
        (tags unit tokenizer)
        (body
          (let result Int32 (is-symbol-start 43))
          (expect-eq result 1)
        )
      )
      (test is-symbol-start-digit
        (doc "ASCII 48 (0) cannot start a symbol")
        (tags unit tokenizer)
        (body
          (let result Int32 (is-symbol-start 48))
          (expect-eq result 0)
        )
      )
    )
  ) ;; fn is-symbol-start

  (fn is-symbol-char
    (doc "Return 1 if ch can appear after the first char of a symbol.")
    (params
      (ch Int32)
    ) ;; params
    (returns Int32)
    (body
      (return (|| (is-digit ch) (is-symbol-start ch)))
    ) ;; body
    (tests
      (test is-symbol-char-digit
        (doc "digits can appear in symbol")
        (tags unit tokenizer)
        (body
          (let result Int32 (is-symbol-char 48))
          (expect-eq result 1)
        )
      )
      (test is-symbol-char-letter
        (doc "letters can appear in symbol")
        (tags unit tokenizer)
        (body
          (let result Int32 (is-symbol-char 97))
          (expect-eq result 1)
        )
      )
    )
  ) ;; fn is-symbol-char

  (fn skip-ws-and-comments
    (doc "Skip whitespace and ';' comments starting at idx; return next index.")
    (params
      (src String)
      (idx Int32)
    ) ;; params
    (returns Int32)
    (body
      (let len Int32
        (string-length src)
        (let i Int32
          idx
          (do
            (while (< i len)
              (do
                (let ch Int32
                  (string-char-at src i)
                  (if-stmt (is-whitespace ch)
                    (set i (+ i 1))
                    (if-stmt (== ch 59)
                      (do
                        (while (&& (< i len) (!= (string-char-at src i) 10))
                          (set i (+ i 1))
                        ) ;; while
                        (if-stmt (< i len)
                          (set i (+ i 1))
                          (set i i)
                        ) ;; if-stmt
                      ) ;; do
                      (return i)
                    ) ;; if-stmt
                  ) ;; if-stmt
                ) ;; let ch
              ) ;; do
            ) ;; while
            (return i)
          ) ;; do
        ) ;; let i
      ) ;; let len
    ) ;; body
    (tests
      (test skip-ws-and-comments-spaces
        (doc "skip multiple spaces returns correct index")
        (tags unit tokenizer)
        (body
          (let result Int32 (skip-ws-and-comments "   a" 0))
          (expect-eq result 3)
        )
      )
      (test skip-ws-and-comments-comment
        (doc "skip comment line returns correct index")
        (tags unit tokenizer)
        (body
          (let src String "; comment\na")
          (let result Int32 (skip-ws-and-comments src 0))
          (expect-eq result 10)
        )
      )
      (test skip-ws-and-comments-no-ws
        (doc "no whitespace returns same index")
        (tags unit tokenizer)
        (body
          (let result Int32 (skip-ws-and-comments "abc" 0))
          (expect-eq result 0)
        )
      )
    )
  ) ;; fn skip-ws-and-comments

  (fn read-while
    (doc "Read digits or symbol chars (mode 0/1) into out; return next index.")
    (params
      (src String)
      (idx Int32)
      (out Buffer)
      (mode Int32)
    ) ;; params
    (returns Int32)
    (body
      (let len Int32
        (string-length src)
        (let i Int32
          idx
          (do
            (buffer-clear out)
            (while (< i len)
              (do
                (let ch Int32
                  (string-char-at src i)
                  (if-stmt (== mode 0)
                    (if-stmt (is-digit ch)
                      (do
                        (buffer-append-byte out ch)
                        (set i (+ i 1))
                      ) ;; do
                      (return i)
                    ) ;; if-stmt
                    (if-stmt (is-symbol-char ch)
                      (do
                        (buffer-append-byte out ch)
                        (set i (+ i 1))
                      ) ;; do
                      (return i)
                    ) ;; if-stmt
                  ) ;; if-stmt
                ) ;; let ch
              ) ;; do
            ) ;; while
            (return i)
          ) ;; do
        ) ;; let i
      ) ;; let len
    ) ;; body
    (tests
      (test read-while-digits
        (doc "read-while mode 0 reads all digits")
        (tags unit tokenizer)
        (body
          (let b Buffer (buffer-new))
          (let idx Int32 (read-while "123abc" 0 b 0))
          (let s String (buffer-to-string b))
          (let len Int32 (string-length s))
          (expect-eq len 3)
        )
      )
      (test read-while-symbols
        (doc "read-while mode 1 reads symbol chars")
        (tags unit tokenizer)
        (body
          (let b Buffer (buffer-new))
          (let idx Int32 (read-while "abc123(" 0 b 1))
          (let s String (buffer-to-string b))
          (let len Int32 (string-length s))
          (expect-eq len 6)
        )
      )
    )
  ) ;; fn read-while

  (fn read-string
    (doc "Read a quoted string starting at idx; writes contents into out.")
    (params
      (src String)
      (idx Int32)
      (out Buffer)
    ) ;; params
    (returns Int32)
    (body
      (let len Int32
        (string-length src)
        (let i Int32
          (+ idx 1)
          (do
            (buffer-clear out)
            (while (< i len)
              (do
                (let ch Int32
                  (string-char-at src i)
                  (if-stmt (== ch 34)
                    (return (+ i 1))
                    (do
                      (buffer-append-byte out ch)
                      (set i (+ i 1))
                    ) ;; do
                  ) ;; if-stmt
                ) ;; let ch
              ) ;; do
            ) ;; while
            (return i)
          ) ;; do
        ) ;; let i
      ) ;; let len
    ) ;; body
    (tests
      (test read-string-simple
        (doc "read-string extracts content between quotes")
        (tags unit tokenizer)
        (body
          (let b Buffer (buffer-new))
          (let idx Int32 (read-string "\"hello\"x" 0 b))
          (let s String (buffer-to-string b))
          (let len Int32 (string-length s))
          (expect-eq len 5)
        )
      )
      (test read-string-empty
        (doc "read-string handles empty string")
        (tags unit tokenizer)
        (body
          (let b Buffer (buffer-new))
          (let idx Int32 (read-string "\"\"x" 0 b))
          (let s String (buffer-to-string b))
          (let len Int32 (string-length s))
          (expect-eq len 0)
        )
      )
    )
  ) ;; fn read-string

  (fn tokenize
    (doc "Convert the source text into token strings; appends to tokens.")
    (params
      (src String)
      (tokens ArrayString)
    ) ;; params
    (returns Int32)
    (body
      (let len Int32
        (string-length src)
        (let i Int32
          0
          (let tmp Buffer
            (buffer-new)
            (do
              (set i (skip-ws-and-comments src i))
              (while (< i len)
                (do
                  (let ch Int32
                    (string-char-at src i)
                    (if-stmt (== ch 40)
                      (do
                        (array-str-append tokens "LPAREN")
                        (set i (+ i 1))
                      ) ;; do
                      (if-stmt (== ch 41)
                        (do
                          (array-str-append tokens "RPAREN")
                          (set i (+ i 1))
                        ) ;; do
                        (if-stmt (== ch 34)
                          (do
                            (set i (read-string src i tmp))
                            (array-str-append
                              tokens
                              (string-concat
                                "STRING:"
                                (buffer-to-string tmp)
                              ) ;; string-concat
                            ) ;; array-str-append
                          ) ;; do
                          (if-stmt (is-digit ch)
                            (do
                              (set i (read-while src i tmp 0))
                              (array-str-append
                                tokens
                                (string-concat
                                  "NUMBER:"
                                  (buffer-to-string tmp)
                                ) ;; string-concat
                              ) ;; array-str-append
                            ) ;; do
                            (if-stmt (is-symbol-start ch)
                              (do
                                (set i (read-while src i tmp 1))
                                (array-str-append
                                  tokens
                                  (string-concat
                                    "SYMBOL:"
                                    (buffer-to-string tmp)
                                  ) ;; string-concat
                                ) ;; array-str-append
                              ) ;; do
                              (set i (+ i 1))
                            ) ;; if-stmt
                          ) ;; if-stmt
                        ) ;; if-stmt
                      ) ;; if-stmt
                    ) ;; if-stmt
                  ) ;; let ch
                  (set i (skip-ws-and-comments src i))
                ) ;; do
              ) ;; while
              (array-str-append tokens "EOF")
              (return 0)
            ) ;; do
          ) ;; let tmp
        ) ;; let i
      ) ;; let len
    ) ;; body
    (tests
      (test tokenize-parens
        (doc "tokenize should recognize parentheses")
        (tags unit tokenizer)
        (body
          (let tokens ArrayString (array-str-new))
          (tokenize "()" tokens)
          (let count Int32 (array-str-len tokens))
          (expect-eq count 3)
        )
      )
      (test tokenize-number
        (doc "tokenize should recognize numbers")
        (tags unit tokenizer)
        (body
          (let tokens ArrayString (array-str-new))
          (tokenize "42" tokens)
          (let count Int32 (array-str-len tokens))
          (expect-eq count 2)
        )
      )
      (test tokenize-symbol
        (doc "tokenize should recognize symbols")
        (tags unit tokenizer)
        (body
          (let tokens ArrayString (array-str-new))
          (tokenize "test" tokens)
          (let count Int32 (array-str-len tokens))
          (expect-eq count 2)
        )
      )
    )
  ) ;; fn tokenize
) ;; module
